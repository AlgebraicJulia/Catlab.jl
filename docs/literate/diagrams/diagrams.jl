# # Diagrams
# Catlab supports the expression of equations in an arbitrary category via diagrams, or functors from a finitely presented category. This view of diagrammatic equations builds on the Catlab approach to functorial semantics by asserting that a system of equations of shape J is a functor F: J ‚Üí ùêÇ. We can draw these equations with Graphviz, where each node is an object in X:Ob(J) labeled with its type F(X) and each edge is a morphism in J labeled with its image under F. 
using Catlab
using Catlab.CategoricalAlgebra
using Catlab.CategoricalAlgebra.FreeDiagrams
using Catlab.CategoricalAlgebra.Diagrams
using Catlab.Programs.DiagrammaticPrograms
using Catlab.Graphs
using Catlab.Graphs.BasicGraphs
using Catlab.Graphics
using Catlab.Graphics.Graphviz
using Catlab.Theories
using Catlab.Syntax
using Catlab.Graphics.FinFunctors

draw(D::FinFunctor) = to_graphviz(D, node_labels=true, edge_labels=true, prog="neato")

# ## Present a diagram in a given category.
# Recall that a *diagram* in a category ``C`` is a functor ``F: J ‚Üí C`` from a
# small category ``J`` into ``C``. Given the category ``C``, this macro presents a
# diagram in ``C``, i.e., constructs a finitely presented indexing category ``J``
# together with a functor ``F: J ‚Üí C``. This method of simultaneous definition is
# often more convenient than defining ``J`` and ``F`` separately.
# often more convenient than defining ``J`` and ``F`` separately, as could be
# accomplished by calling [`@fincat`](@ref) and then [`@finfunctor`](@ref).
# For example, the limit of the following diagram consists of the paths of length
# two in a graph:

D‚ÇÇ = @free_diagram BasicGraphs.TheoryGraph begin
    v::V
    (e‚ÇÅ, e‚ÇÇ)::E
    tgt(e‚ÇÅ) == v
    src(e‚ÇÇ) == v
end

# Morphisms in the indexing category can be left unnamed, which is convenient for defining free diagrams (see also [`@free_diagram`](@ref)). Of course, unnamed morphisms cannot be referenced by name within the `@diagram` call or in other settings, which can sometimes be problematic.
# 
# ## Presenting a free diagram in a given category.
# Recall that a *free diagram* in a category ``C`` is a functor ``F: J ‚Üí C`` where ``J`` is a free category on a graph, here assumed finite. This macro is functionally a special case of [`@diagram`](@ref) that provides a syntactic variant for equality expressions. Rather than interpreting them as equations between morphisms in ``J``, equality expresions can be used to introduce anonymous morphisms in a "pointful" style. For example, the limit of the following diagram consists of the paths of length two in a graph:
    
draw(D‚ÇÇ)

# For small equations the point-free notation commonly employed in functional programming is very convenient; however, there is a reason it is not the standard approach to presenting equations in mathematical writing. Variables are just too useful! As the size of the system of equations grows, it becomes more and more convenient to use variable names. This is why `Catlab.Programs.@program` exists to help people write SMC morphisms with the point-ful notation they are familiar with in imperative or procedural programming.

# We can describe a triangle in a graph using the vertex variables v‚ÇÅ, v‚ÇÇ, v‚ÇÉ and edge variables e‚ÇÅ, e‚ÇÇ, e‚ÇÉ. Then we use the equation notation to assert the `src` and `tgt` relationships between the edges and vertices. 
D‚ÇÉ = @free_diagram BasicGraphs.TheoryGraph begin
    (v‚ÇÅ, v‚ÇÇ, v‚ÇÉ)::V
    (e‚ÇÅ, e‚ÇÇ, e‚ÇÉ)::E
    src(e‚ÇÅ) == v‚ÇÅ
    tgt(e‚ÇÅ) == v‚ÇÇ
    src(e‚ÇÇ) == v‚ÇÇ
    src(e‚ÇÉ) == v‚ÇÅ
    tgt(e‚ÇÇ) == v‚ÇÉ
    tgt(e‚ÇÉ) == v‚ÇÉ
end

# You can see the shape of a triangle when you draw this diagram. This coincidence can be systematically understood (by an experienced category theorist) via the Grothendieck construction and representable functors. 
draw(D‚ÇÉ)

# ## Sequences in ùêÇ
# In any category with an endomorphism f: A ‚Üí A, we can think of recurrence equations as a‚Çô = f(f‚Åø‚Åª¬π(a‚ÇÄ))
@present ùóñ(FreeCartesianCategory) begin
    (A,B)::Ob
    f::Hom(A,A)
    g::Hom(A,B)
end

seq‚ÇÉ = @free_diagram ùóñ begin
    (a‚ÇÄ,a‚ÇÅ,a‚ÇÇ,a‚ÇÉ)::A
    a‚ÇÅ == f(a‚ÇÄ)
    a‚ÇÇ == f(a‚ÇÅ)
    a‚ÇÉ == f(a‚ÇÇ)
end

draw(seq‚ÇÉ)

# Inspired by linear recurrence relations like the Fibonacci sequence we can think of A and B as vector spaces. An endomorphism f: A ‚Üí A and morphism g: A ‚Üí B defines a linear recurrence by applying f to update the system state and g to compute the current term in the sequence. This can be visualized as follows.


obs_seq‚ÇÉ = @free_diagram ùóñ begin
(a‚ÇÄ,a‚ÇÅ,a‚ÇÇ,a‚ÇÉ)::A
(b‚ÇÅ, b‚ÇÇ, b‚ÇÉ )::B
a‚ÇÅ == f(a‚ÇÄ)
b‚ÇÅ == g(a‚ÇÅ)
a‚ÇÇ == f(a‚ÇÅ)
b‚ÇÇ == g(a‚ÇÇ)
a‚ÇÉ == f(a‚ÇÇ)
b‚ÇÉ == g(a‚ÇÉ)
end
draw(obs_seq‚ÇÉ)

# In the case of the Fibonacci sequence A is ‚Ñù¬≤ and B is ‚Ñù with f = [1 1; 1 0] and g = œÄ‚ÇÅ.

@present ùêÉ(FreeCartesianCategory) begin
    (‚Ñù¬≤,‚Ñù)::Ob
    f::Hom(‚Ñù¬≤,‚Ñù¬≤)
    œÄ‚ÇÅ::Hom(‚Ñù¬≤,‚Ñù)
end

fib_seq‚ÇÉ = @free_diagram ùêÉ begin
    (a‚ÇÄ,a‚ÇÅ,a‚ÇÇ,a‚ÇÉ)::‚Ñù¬≤
    (b‚ÇÅ, b‚ÇÇ, b‚ÇÉ )::‚Ñù
    a‚ÇÅ == f(a‚ÇÄ)
    b‚ÇÅ == œÄ‚ÇÅ(a‚ÇÅ)
    a‚ÇÇ == f(a‚ÇÅ)
    b‚ÇÇ == œÄ‚ÇÅ(a‚ÇÇ)
    a‚ÇÉ == f(a‚ÇÇ)
    b‚ÇÉ == œÄ‚ÇÅ(a‚ÇÉ)
end

draw(fib_seq‚ÇÉ)

# ## Newton's Method
# The equations that we have seen aren't particularly interesting, so we turn to a classic of numerical methods. Newton's method for root finding. For an overview of Netwon's method see [Fundamentals of Numerical Computation](https://fncbook.github.io/fnc/nonlineqn/newton.html). The following presentation doesn't know that f‚Ä≤ is the derivative of f, they are just two functions that are evocatively named. We could use [CombinatorialSpaces.jl](https://github.com/AlgebraicJulia/CombinatorialSpaces.jl) to formulate this in a richer categorical setting where we could assert `f := f`. 
@present Analytic(FreeCartesianCategory) begin
    (‚Ñù,‚Ñù¬≤)::Ob
    œÄ‚ÇÅ::Hom(‚Ñù¬≤, ‚Ñù)
    œÄ‚ÇÇ::Hom(‚Ñù¬≤, ‚Ñù)
    plus ::Hom(‚Ñù¬≤, ‚Ñù)
    times::Hom(‚Ñù¬≤, ‚Ñù)
    f    ::Hom(‚Ñù,‚Ñù)
    f‚Ä≤   ::Hom(‚Ñù,‚Ñù)
end
# According to the standard formula x‚Çñ‚Çä‚ÇÅ = x‚Çñ - f(x‚Çñ)/f‚Ä≤(x‚Çñ). The standard presentation of Newton's method relies on the fact that ‚Ñù is a field to use division in the definition of the iterative procedure. Because of the constraint that you can't divide by 0 in a field, fields are not models of any algebraic theory. Because of this, we can multiply both sides by f‚Ä≤(x‚Çñ) and define a Newton's method iteration without reference to division. We also can avoid negation by adding the f(x‚Çñ) term on both sides.
newtons = @free_diagram Analytic begin
    # times(f‚Ä≤(x‚Çñ‚Çä‚ÇÅ), x‚Çñ‚Çä‚ÇÅ) == times(f‚Ä≤(x‚Çñ‚Çä‚ÇÅ), x) - f(x‚Çñ)
    # plus(times(f‚Ä≤(x‚Çñ‚Çä‚ÇÅ), x‚Çñ‚Çä‚ÇÅ), f(x‚Çñ)) == times(f‚Ä≤(x‚Çñ‚Çä‚ÇÅ), x)
    (x‚Çñ, x‚Çñ‚Çä‚ÇÅ, d‚Çñ, fx, ‚àè, Œ£)::‚Ñù
    (p‚ÇÅ, p‚ÇÇ, p‚ÇÉ)::‚Ñù¬≤
    d‚Çñ  == f‚Ä≤(x‚Çñ)
    œÄ‚ÇÅ(p‚ÇÅ) == d‚Çñ
    œÄ‚ÇÇ(p‚ÇÅ) == x‚Çñ‚Çä‚ÇÅ
    ‚àè == times(p‚ÇÅ)
    fx == f(x‚Çñ)
    œÄ‚ÇÅ(p‚ÇÇ) == ‚àè 
    œÄ‚ÇÇ(p‚ÇÇ) == fx 
    plus(p‚ÇÇ) == Œ£
    œÄ‚ÇÅ(p‚ÇÉ) == d‚Çñ
    œÄ‚ÇÇ(p‚ÇÉ) == x‚Çñ
    times(p‚ÇÉ) == Œ£
end

draw(newtons)

# This is definitely a case where standard mathematical notation wins for brevity and clarity. We need a few ergonamic improvements to the diagrammatic equation approach in order to compete with tradtitional notation.
# 1. The ability to assert equations without introducing temporary variables,
# 2. The ability to represent morphisms f: A√óB ‚Üí C as bivariate functions like `f(a:A, b:B)`,
# While encoding simple equations can be more verbose than the traditional notation, the diagrammatic encoding provides a direct route to creating a category whose objects are systems of equations and whose morphisms are relationships between systems of equations. That category is the first step towards leveraging the constructive approach in Catlab to making hierarchical representations of complex systems of equations.
