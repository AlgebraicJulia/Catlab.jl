var documenterSearchIndex = {"docs":
[{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"EditURL = \"../../../literate/graphics/tikz_wiring_diagrams.jl\"","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Drawing-wiring-diagrams-in-TikZ","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"(Image: )","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"Catlab can draw morphism expressions as TikZ pictures. To use this feature, LaTeX must be installed and the Julia package TikzPictures.jl must be loaded.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"For best results, it is recommended to load the packages Convex.j and SCS.jl. When available they are used to optimize the layout of the outer ports.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"using Catlab.WiringDiagrams, Catlab.Graphics\n\nimport Convex, SCS\nimport TikzPictures","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Examples","page":"Drawing wiring diagrams in TikZ","title":"Examples","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/#Symmetric-monoidal-category","page":"Drawing wiring diagrams in TikZ","title":"Symmetric monoidal category","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"using Catlab.Theories\n\nA, B, C, D = Ob(FreeSymmetricMonoidalCategory, :A, :B, :C, :D)\nf, g = Hom(:f, A, B), Hom(:g, B, A);\nnothing #hide","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"To start, here are a few very simple examples.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(f, labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(f⋅g, labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(f⊗g, labels=true, orientation=TopToBottom)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"Here is a more complex example, involving generators with compound domains and codomains.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"h, k = Hom(:h, C, D),  Hom(:k, D, C)\nm, n = Hom(:m, B⊗A, A⊗B), Hom(:n, D⊗C, C⊗D)\nq = Hom(:l, A⊗B⊗C⊗D, D⊗C⊗B⊗A)\n\nto_tikz((f⊗g⊗h⊗k)⋅(m⊗n)⋅q⋅(n⊗m)⋅(h⊗k⊗f⊗g))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"Identities and braidings appear as wires.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(id(A), labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(braid(A,B), labels=true, labels_pos=0.25)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(braid(A,B) ⋅ (g⊗f) ⋅ braid(A,B))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"The isomorphism A otimes B otimes C to C otimes B otimes A induced by the permutation (3 2 1) is a composite of braidings and identities.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"σ = (braid(A,B) ⊗ id(C)) ⋅ (id(B) ⊗ braid(A,C) ⋅ (braid(B,C) ⊗ id(A)))\n\nto_tikz(σ, arrowtip=\"Stealth\", arrowtip_pos=\"-0.1pt\",\n        labels=true, labels_pos=\"0.1pt\")","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"By default, anchor points are added along identity and braiding wires to reproduce the expression structure in the layout. The anchors can be disabled to get a more \"unbiased\" layout.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(σ, anchor_wires=false, arrowtip=\"Stealth\", arrowtip_pos=\"-0.1pt\",\n        labels=true, labels_pos=\"0.1pt\")","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Biproduct-category","page":"Drawing wiring diagrams in TikZ","title":"Biproduct category","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"A, B, C = Ob(FreeBiproductCategory, :A, :B, :C)\nf = Hom(:f, A, B)\n\nto_tikz(mcopy(A), labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(delete(A), labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(mcopy(A)⋅(f⊗f)⋅mmerge(B), labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(mcopy(A⊗B), orientation=TopToBottom, labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(mcopy(A⊗B⊗C), orientation=TopToBottom, labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Compact-closed-category","page":"Drawing wiring diagrams in TikZ","title":"Compact closed category","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"The unit and co-unit of a compact closed category appear as caps and cups.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"A, B = Ob(FreeCompactClosedCategory, :A, :B)\n\nto_tikz(dunit(A), arrowtip=\"Stealth\", labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(dcounit(A), arrowtip=\"Stealth\", labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"In a self-dual compact closed category, such as a bicategory of relations, every morphism f A to B has a transpose f^dagger B to A given by bending wires:","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"A, B = Ob(FreeBicategoryRelations, :A, :B)\nf = Hom(:f, A, B)\n\nto_tikz((dunit(A) ⊗ id(B)) ⋅ (id(A) ⊗ f ⊗ id(B)) ⋅ (id(A) ⊗ dcounit(B)))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Abelian-bicategory-of-relations","page":"Drawing wiring diagrams in TikZ","title":"Abelian bicategory of relations","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"In an abelian bicategory of relations, such as the category of linear relations, the duplication morphisms Delta_X X to X oplus X and addition morphisms blacktriangledown_X X oplus X to X belong to a bimonoid. Among other things, this means that the following two morphisms are equal.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"X = Ob(FreeAbelianBicategoryRelations, :X)\n\nto_tikz(plus(X) ⋅ mcopy(X))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz((mcopy(X)⊕mcopy(X)) ⋅ (id(X)⊕swap(X,X)⊕id(X)) ⋅ (plus(X)⊕plus(X)))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Custom-styles","page":"Drawing wiring diagrams in TikZ","title":"Custom styles","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"The visual appearance of wiring diagrams can be customized using the builtin options or by redefining the TikZ styles for the boxes or wires.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"A, B, = Ob(FreeSymmetricMonoidalCategory, :A, :B)\nf, g = Hom(:f, A, B), Hom(:g, B, A)\n\npic = to_tikz(f⋅g, styles=Dict(\n  \"box\" => [\"draw\", \"fill\"=>\"{rgb,255: red,230; green,230; blue,250}\"],\n))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"X = Ob(FreeAbelianBicategoryRelations, :X)\n\nto_tikz(plus(X) ⋅ mcopy(X), styles=Dict(\n  \"junction\" => [\"circle\", \"draw\", \"fill\"=>\"red\", \"inner sep\"=>\"0\"],\n  \"variant junction\" => [\"circle\", \"draw\", \"fill\"=>\"blue\", \"inner sep\"=>\"0\"],\n))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"By default, the boxes are rectangular (:rectangle). Other available shapes include circles (:circle), ellipses (:ellipse), triangles (:triangle, :invtriangle), and trapezoids (:trapezium, :invtrapezium).","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(f⋅g, default_box_shape=:circle)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(f⋅g, rounded_boxes=false, box_shapes=Dict(\n  f => :triangle, g => :invtriangle,\n))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(f⋅g, orientation=TopToBottom, rounded_boxes=false, box_shapes=Dict(\n  f => :triangle, g => :invtriangle,\n))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"to_tikz(f⋅g, box_shapes=Dict(\n  f => :invtrapezium, g => :trapezium,\n))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Output-formats","page":"Drawing wiring diagrams in TikZ","title":"Output formats","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"The function to_tikz returns an object of type TikZ.Document, representing a TikZ picture and its TikZ library dependencies as an abstract syntax tree. When displayed interactively, this object is compiled by LaTeX to PDF and then converted to SVG.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"To generate the LaTeX source code, use the builtin pretty-printer. This feature does not require LaTeX or TikzPictures.jl to be installed.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/","page":"Drawing wiring diagrams in TikZ","title":"Drawing wiring diagrams in TikZ","text":"import Catlab.Graphics: TikZ\n\ndoc = to_tikz(f⋅g)\nTikZ.pprint(doc)","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"EditURL = \"../../../literate/graphics/layouts_vs_drawings.jl\"","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/#Layouts-versus-drawings-of-wiring-diagrams","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"","category":"section"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"(Image: )","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"In Catlab, layout and drawing (rendering) of wiring diagrams are mostly decoupled. This notebook shows how to lay out diagrams using Graphviz's rank-based layout or Catlab's series-parallel layout and then render them using Compose.jl or TikZ.","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"The morphism we will visualize is:","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"using Catlab.Theories\n\nX = Ob(FreeSymmetricMonoidalCategory, :X)\nf, g, h = (Hom(sym, X, X) for sym in (:f, :g, :h))\n\nexpr = otimes(f, compose(f,g), compose(f,g,h))","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"Let's convert this expression into a wiring diagram. This yields a purely combinatorial object, as evidenced by its underlying graph.","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"using Catlab.WiringDiagrams, Catlab.Graphics\n\ndiagram = to_wiring_diagram(expr)\nWiringDiagrams.graph(diagram)","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/#Graphviz-layout","page":"Layouts versus drawings of wiring diagrams","title":"Graphviz layout","text":"","category":"section"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"Calling to_graphviz both lays out and draws the diagram, entirely within Graphviz.","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"to_graphviz(diagram, orientation=LeftToRight)","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"To get just the layout from Graphviz, we call graphviz_layout instead. We can then render this layout using Compose.jl. Note that the Graphviz layout has units in points.","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"import Compose\n\nlayout = graphviz_layout(diagram, orientation=LeftToRight)\nlayout_to_composejl(layout, base_unit=Compose.pt)","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"The same layout can be rendered in TikZ:","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"import TikzPictures\n\nlayout_to_tikz(layout, base_unit=\"1pt\")","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/#Series-parallel-layout","page":"Layouts versus drawings of wiring diagrams","title":"Series-parallel layout","text":"","category":"section"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"Catlab has its own layout system based on series-parallel decomposition. In this case, the layout exactly recovers the structure of the morphism expression created at the beginning.","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"layout = layout_diagram(FreeSymmetricMonoidalCategory, diagram,\n                        orientation=LeftToRight)\nlayout_to_composejl(layout)","category":"page"},{"location":"generated/graphics/layouts_vs_drawings/","page":"Layouts versus drawings of wiring diagrams","title":"Layouts versus drawings of wiring diagrams","text":"layout_to_tikz(layout)","category":"page"},{"location":"apis/programs/#programs","page":"Programs","title":"Programs","text":"","category":"section"},{"location":"apis/programs/","page":"Programs","title":"Programs","text":"The module Catlab.Programs provides domain-specific languages (DSLs) for constructing diagrams of various kinds. The DSLs, implemented as Julia macros, are based on the syntax of the Julia language but often interpret that syntax very differently from standard Julia programs. Conversely, this module offers preliminary support for generating Julia code from wiring diagrams.","category":"page"},{"location":"apis/programs/","page":"Programs","title":"Programs","text":"There are two major macros for constructing wiring diagrams:","category":"page"},{"location":"apis/programs/","page":"Programs","title":"Programs","text":"@program, for directed wiring diagrams (DWDs)\n@relation, for undirected wiring diagrams (UWDs)","category":"page"},{"location":"apis/programs/","page":"Programs","title":"Programs","text":"In addition, there is a family of related macros for constructing category-theoretic diagrams:","category":"page"},{"location":"apis/programs/","page":"Programs","title":"Programs","text":"@graph, for constructing a graph\n@fincat, for presenting a category as a graph together with path equations\n@finfunctor, for defining a functor between two finitely presented categories\n@diagram and @free_diagram, for defining a diagram in a category","category":"page"},{"location":"apis/programs/","page":"Programs","title":"Programs","text":"Generalizing the last two macros, the modules provides DSLs for functorial data migration:","category":"page"},{"location":"apis/programs/","page":"Programs","title":"Programs","text":"@migrate, for migrating data between acsets\n@migration, for defining data migrations between schemas","category":"page"},{"location":"apis/programs/#API","page":"Programs","title":"API","text":"","category":"section"},{"location":"apis/programs/","page":"Programs","title":"Programs","text":"Modules = [\n  Programs.GenerateJuliaPrograms,\n  Programs.ParseJuliaPrograms,\n  Programs.RelationalPrograms,\n  Programs.DiagrammaticPrograms,\n]\nPrivate = false","category":"page"},{"location":"apis/programs/#Catlab.Programs.GenerateJuliaPrograms","page":"Programs","title":"Catlab.Programs.GenerateJuliaPrograms","text":"Compile or evaluate morphisms as Julia programs.\n\n\n\n\n\n","category":"module"},{"location":"apis/programs/#Catlab.Programs.GenerateJuliaPrograms.Block","page":"Programs","title":"Catlab.Programs.GenerateJuliaPrograms.Block","text":"A block of Julia code with input and output variables.\n\n\n\n\n\n","category":"type"},{"location":"apis/programs/#Catlab.Programs.GenerateJuliaPrograms.CompileState","page":"Programs","title":"Catlab.Programs.GenerateJuliaPrograms.CompileState","text":"Internal state for compilation of morphism into Julia code.\n\n\n\n\n\n","category":"type"},{"location":"apis/programs/#Catlab.Programs.GenerateJuliaPrograms.compile-Tuple{Module, HomExpr}","page":"Programs","title":"Catlab.Programs.GenerateJuliaPrograms.compile","text":"Compile a morphism expression into a Julia function.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.GenerateJuliaPrograms.compile_block-Tuple{HomExpr, Vector}","page":"Programs","title":"Catlab.Programs.GenerateJuliaPrograms.compile_block","text":"Compile a morphism expression into a block of Julia code.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.GenerateJuliaPrograms.compile_expr-Tuple{HomExpr}","page":"Programs","title":"Catlab.Programs.GenerateJuliaPrograms.compile_expr","text":"Compile a morphism expression into a Julia function expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.GenerateJuliaPrograms.evaluate-Tuple{HomExpr, Vararg{Any}}","page":"Programs","title":"Catlab.Programs.GenerateJuliaPrograms.evaluate","text":"Evaluate a morphism as a function.\n\nIf the morphism will be evaluated only once (possibly with vectorized inputs), then direct evaluation will be much faster than compiling (via compile) and evaluating a standard Julia function.\n\nCompare with functor.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.ParseJuliaPrograms","page":"Programs","title":"Catlab.Programs.ParseJuliaPrograms","text":"Parse Julia programs into morphisms represented as wiring diagrams.\n\n\n\n\n\n","category":"module"},{"location":"apis/programs/#Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram-Tuple{Presentation, Expr}","page":"Programs","title":"Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram","text":"Parse a wiring diagram from a Julia function expression.\n\nFor more information, see the corresponding macro @program.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any, Vararg{Any}}","page":"Programs","title":"Catlab.Programs.ParseJuliaPrograms.@program","text":"Parse a wiring diagram from a Julia program.\n\nFor the most part, this is standard Julia code but a few liberties are taken with the syntax. Products are represented as tuples. So if x and y are variables of type X and Y, then (x,y) has type X  Y. Also, both () and nothing are interpreted as the monoidal unit I.\n\nUnlike standard Julia, the function call expressions f(x,y) and f((x,y)) are equivalent. Consequently, given morphisms f W  X  Y and g X  Y  Z, the code\n\nx, y = f(w)\ng(x,y)\n\nis equivalent to g(f(w)). In standard Julia, at most one of these calls to g would be valid, unless g had multiple signatures.\n\nThe diagonals (copying and deleting) of a cartesian category are implicit in the Julia syntax: copying is variable reuse and deleting is variable non-use. For the codiagonals (merging and creating), a special syntax is provided, reinterpreting Julia's vector literals. The merging of x1 and x2 is represented by the vector [x1,x2] and creation by the empty vector []. For example, f([x1,x2]) translates to compose(mmerge(X),f).\n\nThis macro is a wrapper around parse_wiring_diagram.\n\n\n\n\n\n","category":"macro"},{"location":"apis/programs/#Catlab.Programs.RelationalPrograms","page":"Programs","title":"Catlab.Programs.RelationalPrograms","text":"Parse relation expressions in Julia syntax into undirected wiring diagrams.\n\n\n\n\n\n","category":"module"},{"location":"apis/programs/#Catlab.Programs.RelationalPrograms.RelationDiagram","page":"Programs","title":"Catlab.Programs.RelationalPrograms.RelationDiagram","text":"Abstract type for UWDs created by @relation macro.\n\n\n\n\n\n","category":"type"},{"location":"apis/programs/#Catlab.Programs.RelationalPrograms.TypedRelationDiagram","page":"Programs","title":"Catlab.Programs.RelationalPrograms.TypedRelationDiagram","text":"Typed UWD created by @relation macro.\n\n\n\n\n\n","category":"type"},{"location":"apis/programs/#Catlab.Programs.RelationalPrograms.UntypedRelationDiagram","page":"Programs","title":"Catlab.Programs.RelationalPrograms.UntypedRelationDiagram","text":"Untyped UWD created by @relation macro.\n\n\n\n\n\n","category":"type"},{"location":"apis/programs/#Catlab.Programs.RelationalPrograms.parse_relation_diagram-Tuple{Expr}","page":"Programs","title":"Catlab.Programs.RelationalPrograms.parse_relation_diagram","text":"Parse an undirected wiring diagram from a relation expression.\n\nFor more information, see the corresponding macro @relation.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.RelationalPrograms.@relation-Tuple","page":"Programs","title":"Catlab.Programs.RelationalPrograms.@relation","text":"Construct an undirected wiring diagram using relation notation.\n\nUnlike the @program macro for directed wiring diagrams, this macro departs significantly from the usual semantics of the Julia programming language. Function calls with n arguments are now interpreted as assertions that an n-ary relation holds at a particular point. For example, the composite of binary relations R  X  Y and S  Y  Z can be represented as an undirected wiring diagram by the macro call\n\n@relation (x,z) where (x::X, y::Y, z::Z) begin\n  R(x,y)\n  S(y,z)\nend\n\nIn general, the context in the where clause defines the set of junctions in the diagram and variable sharing defines the wiring of ports to junctions. If the where clause is omitted, the set of junctions is inferred from the variables used in the macro call.\n\nThe ports and junctions of the diagram may be typed or untyped, and the ports may be named or unnamed. Thus, four possible types of undirected wiring diagrams may be returned, with the type determined by the form of relation header:\n\nUntyped, unnamed: @relation (x,z) where (x,y,z) ...\nTyped, unnamed: @relation (x,z) where (x::X, y::Y, z::Z) ...\nUntyped, named: @relation (out1=x, out2=z) where (x,y,z) ...\nTyped, named: @relation (out=1, out2=z) where (x::X, y::Y, z::Z) ...\n\nAll four types of diagram are subtypes of RelationDiagram.\n\n\n\n\n\n","category":"macro"},{"location":"apis/programs/#Catlab.Programs.DiagrammaticPrograms","page":"Programs","title":"Catlab.Programs.DiagrammaticPrograms","text":"DSLs for defining categories, diagrams, and related structures.\n\nHere \"diagram\" means diagram in the standard category-theoretic sense, not string diagram or wiring diagram. DSLs for constructing wiring diagrams are provided by other submodules.\n\n\n\n\n\n","category":"module"},{"location":"apis/programs/#Catlab.Programs.DiagrammaticPrograms.@acset_colim-Tuple{Any, Any}","page":"Programs","title":"Catlab.Programs.DiagrammaticPrograms.@acset_colim","text":"Uses the output of yoneda:\n\n@acset_colim yGraph begin    (e1,e2)::E    src(e1) == tgt(e2)  end\n\n\n\n\n\n","category":"macro"},{"location":"apis/programs/#Catlab.Programs.DiagrammaticPrograms.@diagram-Tuple{Any, Any}","page":"Programs","title":"Catlab.Programs.DiagrammaticPrograms.@diagram","text":"Present a diagram in a given category.\n\nRecall that a diagram in a category C is a functor F J  C from a small category J into C. Given the category C, this macro presents a diagram in C, i.e., constructs a finitely presented indexing category J together with a functor F J  C. This method of simultaneous definition is often more convenient than defining J and F separately, as could be accomplished by calling @fincat and then @finfunctor.\n\nAs an example, the limit of the following diagram consists of the paths of length two in a graph:\n\n@diagram SchGraph begin\n  v::V\n  (e₁, e₂)::E\n  (t: e₁ → v)::tgt\n  (s: e₂ → v)::src\nend\n\nMorphisms in the indexing category can be left unnamed, which is convenient for defining free diagrams (see also @free_diagram). For example, the following diagram is isomorphic to the previous one:\n\n@diagram SchGraph begin\n  v::V\n  (e₁, e₂)::E\n  (e₁ → v)::tgt\n  (e₂ → v)::src\nend\n\nOf course, unnamed morphisms cannot be referenced by name within the @diagram call or in other settings, which can sometimes be problematic.\n\n\n\n\n\n","category":"macro"},{"location":"apis/programs/#Catlab.Programs.DiagrammaticPrograms.@fincat-Tuple{Any}","page":"Programs","title":"Catlab.Programs.DiagrammaticPrograms.@fincat","text":"Present a category by generators and relations.\n\nThe result is a finitely presented category (FinCat) represented by a graph, possibly with path equations. For example, the simplex category truncated to one dimension is:\n\n@fincat begin\n  V, E\n  (δ₀, δ₁): V → E\n  σ₀: E → V\n\n  σ₀ ∘ δ₀ == id(V)\n  σ₀ ∘ δ₁ == id(V)\nend\n\nThe objects and morphisms must be uniquely named.\n\n\n\n\n\n","category":"macro"},{"location":"apis/programs/#Catlab.Programs.DiagrammaticPrograms.@finfunctor-NTuple{4, Any}","page":"Programs","title":"Catlab.Programs.DiagrammaticPrograms.@finfunctor","text":"Define a functor between two finitely presented categories.\n\nSuch a functor is defined by sending the object and morphism generators of the domain category to generic object and morphism expressions in the codomain category. For example, the following functor embeds the schema for graphs into the schema for circular port graphs by ignoring the ports:\n\n@finfunctor SchGraph SchCPortGraph begin\n  V => Box\n  E => Wire\n  src => src ⨟ box\n  tgt => tgt ⨟ box\nend\n\nA constructor exists that purports to allow the user to check that a proposed functor satisfies relations in the domain, but this functionality doesn't yet exist (and the problem is undecidable in general.) Thus the only check is that the source and target of the image of an arrow are the image of its source and target.\n\n\n\n\n\n","category":"macro"},{"location":"apis/programs/#Catlab.Programs.DiagrammaticPrograms.@free_diagram-Tuple{Any, Any}","page":"Programs","title":"Catlab.Programs.DiagrammaticPrograms.@free_diagram","text":"Present a free diagram in a given category.\n\nRecall that a free diagram in a category C is a functor F J  C where J is a free category on a graph, here assumed finite. This macro is functionally a special case of @diagram but changes the interpretation of equality expressions. Rather than interpreting them as equations between morphisms in J, equality expresions can be used to introduce anonymous morphisms in a \"pointful\" style. For example, the limit of the following diagram consists of the paths of length two in a graph:\n\n@free_diagram SchGraph begin\n  v::V\n  (e₁, e₂)::E\n  tgt(e₁) == v\n  src(e₂) == v\nend\n\nAnonymous objects can also be introduced. For example, the previous diagram is isomorphic to this one:\n\n@free_diagram SchGraph begin\n  (e₁, e₂)::E\n  tgt(e₁) == src(e₂)\nend\n\nSome care must exercised when defining morphisms between diagrams with anonymous objects, since they cannot be referred to by name.\n\n\n\n\n\n","category":"macro"},{"location":"apis/programs/#Catlab.Programs.DiagrammaticPrograms.@graph-Tuple{Any, Any}","page":"Programs","title":"Catlab.Programs.DiagrammaticPrograms.@graph","text":"Construct a graph in a simple, declarative style.\n\nThe syntax is reminiscent of Graphviz. Each line a declares a vertex or set of vertices, or an edge. For example, the following defines a directed triangle:\n\n@graph begin\n  v0, v1, v2\n  fst: v0 → v1\n  snd: v1 → v2\n  comp: v0 → v2\nend\n\nVertices in the graph must be uniquely named, whereas edges names are optional.\n\n\n\n\n\n","category":"macro"},{"location":"apis/programs/#Catlab.Programs.DiagrammaticPrograms.@migrate-Tuple{Any, Any, Any}","page":"Programs","title":"Catlab.Programs.DiagrammaticPrograms.@migrate","text":"Contravariantly migrate data from one acset to another.\n\nThis macro is shorthand for defining a data migration using the @migration macro and then calling the migrate function. If the migration will be used multiple times, it is more efficient to perform these steps separately, reusing the functor defined by @migration.\n\nFor more about the syntax and supported features, see @migration.\n\n\n\n\n\n","category":"macro"},{"location":"apis/programs/#Catlab.Programs.DiagrammaticPrograms.@migration-Tuple{Any, Any}","page":"Programs","title":"Catlab.Programs.DiagrammaticPrograms.@migration","text":"Define a contravariant data migration.\n\nThis macro provides a DSL to specify a contravariant data migration from C-sets to D-sets for given schemas C and D. A data migration is defined by a functor from D to a category of queries on C. Thus, every object of D is assigned a query on C and every morphism of D is assigned a morphism of queries, in a compatible way. Example usages are in the unit tests. What follows is a technical reference.\n\nSeveral categories of queries are supported by this macro:\n\nTrivial queries, specified by a single object of C. In this case, the macro simply defines a functor D  C and is equivalent to @finfunctor or @diagram.\nConjunctive queries, specified by a diagram in C and evaluated as a finite limit.\nGluing queries, specified by a diagram in C and evaluated as a finite colimit. An important special case is linear queries, evaluated as a finite coproduct.\nGluc queries (gluings of conjunctive queries), specified by a diagram of diagrams in C and evaluated as a colimit of limits. An important special case is duc queries (disjoint unions of conjunctive queries), evaluated as a coproduct of limits.\n\nThe query category of the data migration is not specified explicitly but is inferred from the queries used in the macro call. Implicit conversion is performed: trivial queries can be coerced to conjunctive queries or gluing queries, and conjunctive queries and gluing queries can both be coerced to gluc queries. Due to the implicit conversion, the resulting functor out of D has a single query type and thus a well-defined codomain.\n\nSyntax for the right-hand sides of object assignments is:\n\na symbol, giving object of C (query type: trivial)\n@product ... (query type: conjunctive)\n@unit (alias: @terminal, query type: conjunctive)\n@join ... (alias: @limit, query type: conjunctive)\n@cases ... (alias: @coproduct, query type: gluing)\n@empty (alias: @initial, query type: gluing)\n@glue ... (alias: @colimit, query type: gluing)\n\nThes query types supported by this macro generalize the kind of queries familiar from relational databases. Less familiar is the concept of a morphism between queries, derived from the concept of a morphism between diagrams in a category. A query morphism is given by a functor between the diagrams' indexing categories together with a natural transformation filling a triangle of the appropriate shape. From a practical standpoint, the most important thing to remember is that a morphism between conjunctive queries is contravariant with respect to the diagram shapes, whereas a morphism between gluing queries is covariant. TODO: Reference for more on this.\n\n\n\n\n\n","category":"macro"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"EditURL = \"../../../literate/wiring_diagrams/wiring_diagram_basics.jl\"","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#wiring_diagram_basics","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"(Image: )","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"using Catlab.GATs, you can create, manipulate, serialize, and visualize wiring diagrams, also known as string diagrams. The flexible data structure for wiring diagrams allows arbitrary data to be attached to boxes, ports, and wires, and supports recursively nested diagrams.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"You can interact with wiring diagrams using two different progamming interfaces:","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"Categorical: A high-level, functional interface expressed in terms of categorical concepts, such as composition (compose), monoidal products (otimes), duplication (mcopy), and deletion (delete).\nImperative: A lower-level, mutating interface to directly manipulate boxes, ports, and wires, via operations like adding boxes (add_box) and wires (add_wire).","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"In this notebook, we introduce both interfaces. We do not explicitly cover the visualization API, although for illustrative purposes we will draw wiring diagrams using Graphviz. Thus, you should install Graphviz if you wish to run this notebook.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"using Catlab.WiringDiagrams\n\nusing Catlab.Graphics\nimport Catlab.Graphics: Graphviz\n\nshow_diagram(d::WiringDiagram) = to_graphviz(d,\n  orientation=LeftToRight,\n  labels=true, label_attr=:xlabel,\n  node_attrs=Graphviz.Attributes(\n    :fontname => \"Courier\",\n  ),\n  edge_attrs=Graphviz.Attributes(\n    :fontname => \"Courier\",\n  )\n)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Data-structures","page":"Basics of wiring diagrams","title":"Data structures","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"The basic building blocks of a wiring diagram are boxes, ports, and wires. The top-level data structure is WiringDiagram, defined in the module Catlab.WiringDiagrams. A wiring diagram consists of boxes (usually of type Box) connected by wires (of type Wire). Each box has a sequence of input ports and a sequence of output ports, as does the wiring diagram itself. The wires have sources and targets, both of which consist of a box and a port on that box.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"The boxes in a wiring diagram are indexed by integer IDs. Boxes can be retrieved by ID, and wires refer to boxes using their IDs. Two special IDs, obtained by input_id and output_id methods, refer to the inputs and outputs of the diagram itself. In this way, wires can connect the (inner) boxes of a diagram to the diagram's \"outer box\".","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"The WiringDiagram data structure is an elaborate wrapper around a directed graph from Graphs.jl. The underlying DiGraph object can be accessed using the graph method. The vertices of this graph are exactly the box IDs. The graph should never be mutated directly, on pain of creating inconsistent state, but it does allow convenient access to the large array of graph algorithms supported by Graphs.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"All this is somewhat abstract but should become clearer as we see concrete examples.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Categorical-interface","page":"Basics of wiring diagrams","title":"Categorical interface","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"In this example, the wiring diagrams will carry symbolic expressions (of type Catlab.ObExpr and Catlab.HomExpr).","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"using Catlab.Theories\n\nA, B, C, D = Ob(FreeBiproductCategory, :A, :B, :C, :D)\nf = Hom(:f, A, B)\ng = Hom(:g, B, C)\nh = Hom(:h, C, D)\n\nf","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Generators","page":"Basics of wiring diagrams","title":"Generators","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"Convert each of the morphism generators into a diagram with a single box.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"f, g, h = to_wiring_diagram(f), to_wiring_diagram(g), to_wiring_diagram(h)\nf","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(f)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Composition","page":"Basics of wiring diagrams","title":"Composition","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"compose(f,g)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(compose(f,g))","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Monoidal-products","page":"Basics of wiring diagrams","title":"Monoidal products","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"otimes(f,h)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(otimes(f,h))","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Copy-and-merge,-delete-and-create","page":"Basics of wiring diagrams","title":"Copy and merge, delete and create","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"mcopy(codom(f),2)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(mcopy(codom(f),2))","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(compose(f, mcopy(codom(f),2)))","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(compose(mcopy(dom(f),2), otimes(f,f)))","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Imperative-interface","page":"Basics of wiring diagrams","title":"Imperative interface","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"We now show how to manipulate wiring diagrams using the low-level, imperative interface. The diagrams will carry Julia symbols.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"f = Box(:f, [:A], [:B])\ng = Box(:g, [:B], [:C])\nh = Box(:h, [:C], [:D])\n\nf","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Composition-2","page":"Basics of wiring diagrams","title":"Composition","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"For example, here is how to manually construct a composition of two boxes.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"The add_box! method adds a box to a wiring diagrams and returns the ID assigned to the box. How the boxes are indexed is an implementation detail that you should not rely on; use the IDs that the system gives you.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"d = WiringDiagram([:A], [:C])\n\nfv = add_box!(d, f)\ngv = add_box!(d, g)\n\nadd_wires!(d, [\n  (input_id(d),1) => (fv,1),\n  (fv,1) => (gv,1),\n  (gv,1) => (output_id(d),1),\n])\n\nnboxes(d)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"nwires(d)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"d","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(d)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Products","page":"Basics of wiring diagrams","title":"Products","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"Here is how to manually construct a product of two boxes.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"d = WiringDiagram([:A,:C], [:B,:D])\n\nfv = add_box!(d, f)\nhv = add_box!(d, h)\n\nadd_wires!(d, [\n  (input_id(d),1) => (fv,1),\n  (input_id(d),2) => (hv,1),\n  (fv,1) => (output_id(d),1),\n  (hv,1) => (output_id(d),2),\n])\n\nd","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(d)","category":"page"},{"location":"apis/gats/#Theories,-instances,-and-expressions","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"","category":"section"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"At the core of Catlab is a system for defining generalized algebraic structures, such as categories and monoidal categories, and then creating instances of these structures in Julia code. The objects, morphisms, and even higher-order morphisms can also be represented as typed symbolic expressions, as in a computer algebra system. These expressions can be manipulated abstractly or transformed into more concrete representations, such as wiring diagrams or Julia functions.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"The basic elements of this system are:","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"Generalized algebraic theories (GATs), defined using the @theory macro. Categories and other typed (multisorted) algebraic structures can be defined as GATs. Alternatively, the @signature macro can be used when only the signature (not the axioms) of the GAT are to be specified.\nInstances, or concrete implementations, of theories, defined using the @instance macro.\nSyntax systems for theories, defined using the @syntax macro. These are type-safe expression trees constructed using ordinary Julia functions.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"We'll explain each of these elements in greater detail in the following sections. From the programming perspective, theories can be thought of as interfaces and bear some resemblance to type classes in languages like Haskell. Both instances and syntax systems can then be thought of as implementations of the interface.","category":"page"},{"location":"apis/gats/#gats","page":"Theories, instances, and expressions","title":"Theories","text":"","category":"section"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"Generalized algebraic theories (GATs) are the natural logical system in which to define categories and related algebraic structures. GATs generalize the typed (multisorted) algebraic theories of universal algebra by incorporating a fragment of dependent type theory; they are perhaps the simplest dependently typed logics.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"Catlab implements a version of the GAT formalism on top of Julia's type system, taking advantage of Julia macros to provide a pleasant syntax. GATs are defined using the @theory macro.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"For example, the theory of categories could be defined by:","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"using Catlab.GATs\nimport Catlab.Theories: Ob, Hom, ObExpr, HomExpr, dom, codom, compose, ⋅, id","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"@theory ThCategory{Ob,Hom} begin\n  @op begin\n    (→) := Hom\n    (⋅) := compose\n  end\n\n  Ob::TYPE\n  Hom(dom::Ob, codom::Ob)::TYPE\n\n  id(A::Ob)::(A → A)\n  compose(f::(A → B), g::(B → C))::(A → C) ⊣ (A::Ob, B::Ob, C::Ob)\n\n  (f ⋅ g) ⋅ h == f ⋅ (g ⋅ h) ⊣ (A::Ob, B::Ob, C::Ob, D::Ob,\n                                f::(A → B), g::(B → C), h::(C → D))\n  f ⋅ id(B) == f ⊣ (A::Ob, B::Ob, f::(A → B))\n  id(A) ⋅ f == f ⊣ (A::Ob, B::Ob, f::(A → B))\nend\nnothing # hide","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"The code is simplified only slightly from the official Catlab definition of ThCategory. The theory has two type constructors, Ob (object) and Hom (morphism). The type Hom is a dependent type, depending on two objects, named dom (domain) and codom (codomain). The theory has two term constructors, id (identity) and compose (composition).","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"Notice how the return types of the term constructors depend on the argument values. For example, the term id(A) has type Hom(A,A). The term constructor compose also uses context variables, listed to the right of the ⊣ symbol. These context variables can also be defined after a where clause, but the left hand side must be surrounded by parentheses. This allows us to write compose(f,g), instead of the more verbose compose(A,B,C,f,g) (for discussion, see Cartmell, 1986, Sec 10: Informal syntax).","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"Notice the @op call where we can create method aliases that can then be used throughout the rest of the theory and outside of definition. We can either use this block notation, or a single line notation such as @op (⋅) := compose to define a single alias. Here we utilize this functionality by replacing the Hom and compose methods with their equivalent Unicode characters, → and ⋅ respectively. These aliases are also automatically available to definitions that inherit a theory that already has the alias defined.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"note: Note\nIn general, a GAT consists of a signature, defining the types and terms of the theory, and a set of axioms, the equational laws satisfied by models of the theory. The theory of categories, for example, has axioms of unitality and associativity. At present, Catlab supports the specification of both signatures and the axioms, but is not currently utilizing the axiom definitions in any way, reflecting its status as a programming library, not a proof assistant. It is the programmer's responsibility to ensure any declared instances of an algebraic structure satisfy its axioms.","category":"page"},{"location":"apis/gats/#References","page":"Theories, instances, and expressions","title":"References","text":"","category":"section"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"Cartmell, 1986: Generalized algebraic theories and contextual categories, DOI:10.1016/0168-0072(86)90053-9\nCartmell, 1978, PhD thesis: Generalized algebraic theories and contextual categories\nPitts, 1995: Categorical logic, Sec 6: Dependent types","category":"page"},{"location":"apis/gats/#instances","page":"Theories, instances, and expressions","title":"Instances","text":"","category":"section"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"A theory can have one or more instances, or instantiations by ordinary Julia types and functions. This feature builds on Julia's support for generic functions with multiple dispatch.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"Instances are declared using the @instance macro. In an instance of a theory, each theory type is mapped to a Julia type and each term is mapped to a Julia method of the same name. For example, the category of matrices could be defined as an instance of the theory Category defined above:","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"using LinearAlgebra: I\n\nstruct MatrixDomain\n  eltype::Type\n  dim::Int\nend\n\n@instance ThCategory{MatrixDomain, Matrix} begin\n  dom(M::Matrix) = MatrixDomain(eltype(M), size(M,1))\n  codom(M::Matrix) = MatrixDomain(eltype(M), size(M,2))\n\n  id(m::MatrixDomain) = Matrix{m.eltype}(I, m.dim, m.dim)\n  compose(M::Matrix, N::Matrix) = M*N\nend","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"A = Matrix{Float64}([0 1; 1 0])\nid(dom(A))","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"In this instance, the theory type Ob is mapped to the custom Julia type MatrixDomain. The latter type has two fields, a Julia type eltype representing a field k and an integer dim representing the dimensionality n, and so can be interpreted as the n-dimensional vector space k^n. The theory Hom is mapped to the standard Julia type Matrix.","category":"page"},{"location":"apis/gats/#syntax-systems","page":"Theories, instances, and expressions","title":"Syntax systems","text":"","category":"section"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"Theories can also be instantiated as systems of symbolic expressions, using the @syntax macro. The symbolic expressions are expression trees, as commonly used in computer algebra systems. They are similar to Julia's Expr type but they are instead subtyped from Catlab's GATExpr type and they have a more refined type hierarchy.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"A single theory can have different syntax systems, treating different terms as primitive or performing different simplication or normalization procedures. Catlab tries to make it easy to define new syntax systems. Many of the theories included with Catlab have default syntax systems, but the user is encouraged to define their own to suit their needs.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"To get started, you can always call the @syntax macro with an empty body. Below, we subtype from Catlab's abstract types ObExpr and HomExpr to enable LaTeX pretty-printing and other convenient features, but this is not required.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"@syntax CategoryExprs{ObExpr, HomExpr} ThCategory begin\nend\n\nA, B, C, D = [ Ob(CategoryExprs.Ob, X) for X in [:A, :B, :C, :D] ]\nf, g, h = Hom(:f, A, B), Hom(:g, B, C), Hom(:h, C, D)\n\ncompose(compose(f,g),h)","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"The resulting symbolic expressions perform no simplification. For example, the associativity law is not satisfied:","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"compose(compose(f,g),h) == compose(f,compose(g,h))","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"Thus, unlike instances of a theory, syntactic expressions are not expected to obey all the axioms of the theory.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"However, the user may supply logic in the body of the @syntax macro to enforce the axioms or perform other kinds of simplification. Below, we use the associate function provided by Catlab to convert the binary expressions representing composition into n-ary expressions for any number n. The option strict=true tells Catlab to check that the domain and codomain objects are strictly equal and throw an error if they are not.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"@syntax SimplifyingCategoryExprs{ObExpr, HomExpr} ThCategory begin\n  compose(f::Hom, g::Hom) = associate(new(f,g; strict=true))\nend\n\nA, B, C, D = [ Ob(SimplifyingCategoryExprs.Ob, X) for X in [:A, :B, :C, :D] ]\nf, g, h = Hom(:f, A, B), Hom(:g, B, C), Hom(:h, C, D)\n\ncompose(compose(f,g),h)","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"Now the associativity law is satisfied:","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"compose(compose(f,g),h) == compose(f,compose(g,h))","category":"page"},{"location":"apis/gats/#Primitive-versus-derived-operations","page":"Theories, instances, and expressions","title":"Primitive versus derived operations","text":"","category":"section"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"In some algebraic structures, there is a choice as to which operations should be considered primitive and which should be derived. For example, in a cartesian monoidal category, the copy operation Delta_X X to X otimes X can be defined in terms of the pairing operation langle f g rangle, or vice versa. In addition, the projections pi_XY X otimes Y to X and pi_XY X otimes Y to Y can be defined in terms of the deleting operation (terminal morphism) or left as primitive.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"In Catlab, the recommended way to deal with such situations is to define all the operations in the theory and then allow particular syntax systems to determine which operations, if any, will be derived from others. In the case of the cartesian monoidal category, we could define a signature CartesianCategory by inheriting from the builtin theory SymmetricMonoidalCategory.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"using Catlab.GATs\nimport Catlab.Theories: Ob, Hom, ObExpr, HomExpr, ThSymmetricMonoidalCategory,\n  dom, codom, compose, id, otimes, munit, braid","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"@signature ThCartesianCategory{Ob,Hom} <: ThSymmetricMonoidalCategory{Ob,Hom} begin\n  mcopy(A::Ob)::(A → (A ⊗ A))\n  delete(A::Ob)::(A → munit())\n\n  pair(f::(A → B), g::(A → C))::(A → (B ⊗ C)) ⊣ (A::Ob, B::Ob, C::Ob)\n  proj1(A::Ob, B::Ob)::((A ⊗ B) → A)\n  proj2(A::Ob, B::Ob)::((A ⊗ B) → B)\nend\nnothing # hide","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"We could then define the copying operation in terms of the pairing.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"@syntax CartesianCategoryExprsV1{ObExpr,HomExpr} ThCartesianCategory begin\n  mcopy(A::Ob) = pair(id(A), id(A))\nend\n\nA = Ob(CartesianCategoryExprsV1.Ob, :A)\nmcopy(A)","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"Alternatively, we could define the pairing and projections in terms of the copying and deleting operations.","category":"page"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"@syntax CartesianCategoryExprsV2{ObExpr,HomExpr} ThCartesianCategory begin\n  pair(f::Hom, g::Hom) = compose(mcopy(dom(f)), otimes(f,g))\n  proj1(A::Ob, B::Ob) = otimes(id(A), delete(B))\n  proj2(A::Ob, B::Ob) = otimes(delete(A), id(B))\nend\n\nA, B, C = [ Ob(CartesianCategoryExprsV2.Ob, X) for X in [:A, :B, :C] ]\nf, g = Hom(:f, A, B), Hom(:g, A, C)\npair(f, g)","category":"page"},{"location":"apis/gats/#API","page":"Theories, instances, and expressions","title":"API","text":"","category":"section"},{"location":"apis/gats/","page":"Theories, instances, and expressions","title":"Theories, instances, and expressions","text":"Modules = [\n  GATs.TheoriesInstances,\n  GATs.SyntaxSystems,\n  GATs.Rewriting,\n  GATs.Presentations,\n]\nPrivate = false","category":"page"},{"location":"apis/gats/#Catlab.GATs.TheoriesInstances","page":"Theories, instances, and expressions","title":"Catlab.GATs.TheoriesInstances","text":"Generalized algebraic theories (GATs) and their models in Julia (instances).\n\n\n\n\n\n","category":"module"},{"location":"apis/gats/#Catlab.GATs.TheoriesInstances.invoke_term-Tuple{Type, Tuple, Symbol, Vararg{Any}}","page":"Theories, instances, and expressions","title":"Catlab.GATs.TheoriesInstances.invoke_term","text":"Invoke a term constructor by name on an instance.\n\nThis method provides reflection for GATs. In everyday use the generic method for the constructor should be called directly, not through this function.\n\nCf. Julia's builtin invoke() function.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.TheoriesInstances.theory","page":"Theories, instances, and expressions","title":"Catlab.GATs.TheoriesInstances.theory","text":"Retrieve generalized algebraic theory associated with abstract type.\n\nFor example, if Category is imported from Catlab.Theories, then theory(Category)returns the theory of a category.\n\n\n\n\n\n","category":"function"},{"location":"apis/gats/#Catlab.GATs.TheoriesInstances.@instance-Tuple{Any, Any}","page":"Theories, instances, and expressions","title":"Catlab.GATs.TheoriesInstances.@instance","text":"Define an instance of a generalized algebraic theory (GAT).\n\n\n\n\n\n","category":"macro"},{"location":"apis/gats/#Catlab.GATs.TheoriesInstances.@signature-Tuple{Any, Any}","page":"Theories, instances, and expressions","title":"Catlab.GATs.TheoriesInstances.@signature","text":"Define a signature for a generalized algebraic theory (GAT).\n\nA signature is the same as a theory, except it may not contain axioms, and therefore only three kinds of things can go in the signature body:\n\nType constructors, indicated by the special type TYPE, e.g., Hom(X::Ob,Y::Ob)::TYPE\nTerm constructors, e.g., id(X::Ob)::Hom(X,X)\nFunction aliases, e.g., @op Hom :→\n\nA signature can extend existing theories (at present only one).\n\n\n\n\n\n","category":"macro"},{"location":"apis/gats/#Catlab.GATs.TheoriesInstances.@theory-Tuple{Any, Any}","page":"Theories, instances, and expressions","title":"Catlab.GATs.TheoriesInstances.@theory","text":"Define a generalized algebraic theory (GAT).\n\nFour kinds of things can go in the theory body:\n\nType constructors, indicated by the special type TYPE, e.g., Hom(X::Ob,Y::Ob)::TYPE\nTerm constructors, e.g., id(X::Ob)::Hom(X,X)\nFunction aliases, e.g., @op Hom :→\nEquality axioms, e.g., f ⋅ id(B) == f ⊣ (A::Ob, B::Ob, f::(A → B))\n\nA theory can extend existing theories (at present only one).\n\n\n\n\n\n","category":"macro"},{"location":"apis/gats/#Catlab.GATs.SyntaxSystems","page":"Theories, instances, and expressions","title":"Catlab.GATs.SyntaxSystems","text":"Syntax systems for generalized algebraic theories (GATs).\n\nIn general, a single theory may have many different syntaxes. The purpose of this module to enable the simple but flexible construction of syntax systems.\n\n\n\n\n\n","category":"module"},{"location":"apis/gats/#Catlab.GATs.SyntaxSystems.GATExpr","page":"Theories, instances, and expressions","title":"Catlab.GATs.SyntaxSystems.GATExpr","text":"Base type for expression in the syntax of a GAT.\n\nWe define Julia types for each type constructor in the theory, e.g., object, morphism, and 2-morphism in the theory of 2-categories. Of course, Julia's type system does not support dependent types, so the type parameters are incorporated in the Julia types. (They are stored as extra data in the expression instances.)\n\nThe concrete types are structurally similar to the core type Expr in Julia. However, the term constructor is represented as a type parameter, rather than as a head field. This makes dispatch using Julia's type system more convenient.\n\n\n\n\n\n","category":"type"},{"location":"apis/gats/#Base.Meta.show_sexpr-Tuple{GATExpr}","page":"Theories, instances, and expressions","title":"Base.Meta.show_sexpr","text":"Show the syntax expression as an S-expression.\n\nCf. the standard library function Meta.show_sexpr.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.SyntaxSystems.functor-Tuple{Tuple, GATExpr}","page":"Theories, instances, and expressions","title":"Catlab.GATs.SyntaxSystems.functor","text":"Functor from GAT expression to GAT instance.\n\nStrictly speaking, we should call these \"structure-preserving functors\" or, better, \"model homomorphisms of GATs\". But this is a category theory library, so we'll go with the simpler \"functor\".\n\nA functor is completely determined by its action on the generators. There are several ways to specify this mapping:\n\nSpecify a Julia instance type for each GAT type, using the required types tuple. For this to work, the generator constructors must be defined for the instance types.\nExplicitly map each generator term to an instance value, using the generators dictionary.\nFor each GAT type (e.g., object and morphism), specify a function mapping generator terms of that type to an instance value, using the terms dictionary.\n\nThe terms dictionary can also be used for special handling of non-generator expressions. One use case for this capability is defining forgetful functors, which map non-generators to generators.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.SyntaxSystems.parse_json_sexpr-Tuple{Module, Any}","page":"Theories, instances, and expressions","title":"Catlab.GATs.SyntaxSystems.parse_json_sexpr","text":"Deserialize expression from JSON-able S-expression.\n\nIf symbols is true (the default), strings are converted to symbols.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.SyntaxSystems.show_latex-Tuple{GATExpr}","page":"Theories, instances, and expressions","title":"Catlab.GATs.SyntaxSystems.show_latex","text":"Show the expression in infix notation using LaTeX math.\n\nDoes not include $ or \\[begin|end]{equation} delimiters.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.SyntaxSystems.show_unicode-Tuple{GATExpr}","page":"Theories, instances, and expressions","title":"Catlab.GATs.SyntaxSystems.show_unicode","text":"Show the expression in infix notation using Unicode symbols.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.SyntaxSystems.to_json_sexpr-Tuple{GATExpr}","page":"Theories, instances, and expressions","title":"Catlab.GATs.SyntaxSystems.to_json_sexpr","text":"Serialize expression as JSON-able S-expression.\n\nThe format is an S-expression encoded as JSON, e.g., \"compose(f,g)\" is represented as [\"compose\", f, g].\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.TheoriesInstances.invoke_term-Tuple{Module, Symbol, Vararg{Any}}","page":"Theories, instances, and expressions","title":"Catlab.GATs.TheoriesInstances.invoke_term","text":"Invoke a term constructor by name in a syntax system.\n\nThis method provides reflection for syntax systems. In everyday use the generic method for the constructor should be called directly, not through this function.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.SyntaxSystems.@syntax","page":"Theories, instances, and expressions","title":"Catlab.GATs.SyntaxSystems.@syntax","text":"Define a syntax system for a generalized algebraic theory (GAT).\n\nA syntax system consists of Julia types (with top type GATExpr) for each type constructor in the signature, plus Julia functions for\n\nGenerators: creating new generator terms, e.g., objects or morphisms\nAccessors: accessing type parameters, e.g., domains and codomains\nTerm constructors: applying term constructors, e.g., composition and monoidal products\n\nJulia code for all this is generated by the macro. Any of the methods can be overriden with custom simplification logic.\n\n\n\n\n\n","category":"macro"},{"location":"apis/gats/#Catlab.GATs.Rewriting","page":"Theories, instances, and expressions","title":"Catlab.GATs.Rewriting","text":"Rewriting for GAT expressions.\n\nThe current content of this module is just a stopgap until I can implement a generic term rewriting system.\n\n\n\n\n\n","category":"module"},{"location":"apis/gats/#Catlab.GATs.Rewriting.associate-Tuple{E} where E<:GATExpr","page":"Theories, instances, and expressions","title":"Catlab.GATs.Rewriting.associate","text":"Simplify associative binary operation.\n\nMaintains the normal form op(e1,e2,...) where e1,e2,... are expressions that are not applications of op()\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Rewriting.associate_unit-Tuple{GATExpr, Function}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Rewriting.associate_unit","text":"Simplify associative binary operation with unit.\n\nReduces a freely generated (typed) monoid to normal form.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Rewriting.associate_unit_inv-Union{Tuple{E}, Tuple{E, Function, Function}} where E<:GATExpr","page":"Theories, instances, and expressions","title":"Catlab.GATs.Rewriting.associate_unit_inv","text":"Simplify associative binary operation with unit and inverses.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Rewriting.distribute_unary-Tuple{GATExpr, Function, Function}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Rewriting.distribute_unary","text":"Distribute unary operation over binary operation.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Rewriting.involute-Tuple{GATExpr}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Rewriting.involute","text":"Simplify involutive unary operation.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Presentations","page":"Theories, instances, and expressions","title":"Catlab.GATs.Presentations","text":"Finite presentations of a model of a generalized algebraic theory (GAT).\n\nWe support two methods for defining models of a GAT: as Julia objects using the @instance macro and as syntactic objects using the @present macro. Instances are useful for casting generic data structures, such as matrices, abstract tensor systems, and wiring diagrams, in categorical language. Presentations define small categories by generators and relations and are useful in applications like knowledge representation.\n\n\n\n\n\n","category":"module"},{"location":"apis/gats/#Catlab.GATs.Presentations.add_definition!-Tuple{Presentation, Symbol, GATExpr}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Presentations.add_definition!","text":"Add a generator defined by an equation.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Presentations.add_equation!-Tuple{Presentation, GATExpr, GATExpr}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Presentations.add_equation!","text":"Add an equation between terms to a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Presentations.add_equations!-Tuple{Presentation, Any}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Presentations.add_equations!","text":"Add sequence of equations to a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Presentations.add_generator!-Tuple{Presentation, Any}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Presentations.add_generator!","text":"Add a generator to a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Presentations.add_generators!-Tuple{Presentation, Any}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Presentations.add_generators!","text":"Add iterable of generators to a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Presentations.equations-Tuple{Presentation}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Presentations.equations","text":"Get all equations of a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Presentations.generator-Tuple{Presentation, Any}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Presentations.generator","text":"Retrieve generators by name.\n\nGenerators can also be retrieved using indexing notation, so that generator(pres, name) and pres[name] are equivalent.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Presentations.generator_index-Union{Tuple{Name}, Tuple{T}, Tuple{Presentation{T, Name}, Name}} where {T, Name}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Presentations.generator_index","text":"Get the index of a generator, relative to generators of same GAT type.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Presentations.generators-Tuple{Presentation}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Presentations.generators","text":"Get all generators of a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Presentations.has_generator-Tuple{Presentation, Any}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Presentations.has_generator","text":"Does the presentation contain a generator with the given name?\n\n\n\n\n\n","category":"method"},{"location":"apis/gats/#Catlab.GATs.Presentations.@present-Tuple{Any, Any}","page":"Theories, instances, and expressions","title":"Catlab.GATs.Presentations.@present","text":"Define a presentation using a convenient syntax.\n\n\n\n\n\n","category":"macro"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"EditURL = \"../../../literate/graphs/graphs.jl\"","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"using Catlab.GATs, Catlab.Theories\nusing Catlab.CategoricalAlgebra\nusing Catlab.Graphs\nusing Catlab.Graphics\n\ndraw(g; kw...) = to_graphviz(g; node_labels=true, edge_labels=true, kw...)\ndraw(f::ACSetTransformation; kw...) =\n  to_graphviz(f; node_labels=true, edge_labels=true, draw_codom=false, kw...)\n\nto_graphviz(SchGraph)","category":"page"},{"location":"generated/graphs/graphs/#The-Category-of-Graphs","page":"The Category of Graphs","title":"The Category of Graphs","text":"","category":"section"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"The Theory of Graphs is given by the following Schema:","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"@present SchGraph(FreeSchema) begin\n  V::Ob\n  E::Ob\n  src::Hom(E,V)\n  tgt::Hom(E,V)\nend\n\n\"\"\" Abstract type for graphs, aka directed multigraphs.\n\"\"\"\n@abstract_acset_type AbstractGraph <: HasGraph\n\n\"\"\" A graph, also known as a directed multigraph.\n\"\"\"\n@acset_type Graph(SchGraph, index=[:src,:tgt]) <: AbstractGraph","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"That is all we need to do to generate the functor category [SchGraph, FinSet]. Catlab knows how to take a finitely presented category and generate all the data structures that you need to represent functors into FinSet and natural transformations between those functors. Note: the index=[:src, :tgt] keyword argument tells Catlab that you want to have an efficient index the preimages of those morphisms. in this example, we want to be able to find the incoming and outgoing edges of a vertex in O(1) time.","category":"page"},{"location":"generated/graphs/graphs/#Creating-some-Graphs","page":"The Category of Graphs","title":"Creating some Graphs","text":"","category":"section"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"Once you have fixed the schema (aka indexing category or theory), you can make some instances. Catlab has a DSL for specifying instances of any schema. It is called @acset. In order to specify a Functor F=(F₀, F₁) into FinSet, you need to provide some data.     1. For every A:Ob(C), you need F₀(A):FinSet     2. For every f:A→B, you need to specify a FinFunction F₁(f):F₀(A)→F₀(B) If the theory C has some equations, the data you provide would have to also satisfy those equations. The theory of graphs has no equations, so there are no constraints on the data you provide, except for those that come from functoriality.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"e = @acset Graph begin\n    V = 2\n    E = 1\n    src = [1]\n    tgt = [2]\nend\n\ndraw(e)","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"a wedge is two edges that share a target","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"w = @acset Graph begin\n    V = 3\n    E = 2\n    src=[1,3]\n    tgt=[2,2]\nend\n\ndraw(w)","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"The CSet API generalizes the traditional Graph API","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"parts(w, :V)  # vertex set\n\nparts(w,:E) # edge set\n\nw[:src] # source map\n\nw[:tgt] # target map\n\n\nincident(w, 1, :src) # edges out of vertex 1\n\nincident(w, 2, :tgt) # edges into vertex 2\n\nw[incident(w, 2, :tgt), :src] # vertices that are the source of edges whose target is vertex 2\n\nw[incident(w, 1, :src), :tgt] # vertices that are the target of edges whose src is vertex 1","category":"page"},{"location":"generated/graphs/graphs/#Exercise:","page":"The Category of Graphs","title":"Exercise:","text":"","category":"section"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"Use the @acset macro to make a graph with at least 5 vertices\nDraw the graph\nCompute in neighbors and out neighbors and make sure they match your expectations.\nWrite a function that computes the 2-hop out-neighbors of a vertex.","category":"page"},{"location":"generated/graphs/graphs/#Graph-Homomorphisms","page":"The Category of Graphs","title":"Graph Homomorphisms","text":"","category":"section"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"We can construct some graph homomorphisms between our two graphs. What data do we need to specify?","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"ϕ = ACSetTransformation(e,w,E=[1], V=[1,2])\n\nis_natural(ϕ)","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"The ACSetTransformation constructor does not automatically validate that the naturality squares commute!","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"ϕᵦ = ACSetTransformation(e,w,E=[1], V=[3,2])\nis_natural(ϕᵦ)","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"Our ϕᵦ in't natural because the edge map e₁ ↦ e₁ is not consistent with our vertex map, which sends v₁ ↦ v₃ and v₂ ↦ v₂. We can fix this by sending e₁ to e₂","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"ϕᵦ′ = ACSetTransformation(e,w,E=[2], V=[3,2])\nis_natural(ϕᵦ′)","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"So how does Catlab store the data of the natural transformation? the domain","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"ϕ.dom","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"the codomain","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"ϕ.codom","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"the components","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"ϕ.components","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"you can see the components using standard indexing notation with the object names. Notice that while CSets are indexed by morphisms, natural transformations are indexed by objects.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"ϕ[:V]\nϕ[:E]","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"We can check the  naturality squares ourselves The sources are preserved: src ⋅ ϕᵥ == ϕₑ ⋅ src","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"ϕ[:V](dom(ϕ)[:,:src]) == codom(ϕ)[collect(ϕ[:E]), :src]","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"The targets are preserved: tgt ⋅ ϕᵥ == ϕₑ ⋅ tgt","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"ϕ[:V](dom(ϕ)[:,:tgt]) == codom(ϕ)[collect(ϕ[:E]), :tgt]","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"This approach generalizes to the following:","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"function is_natural(α::ACSetTransformation{S}) where {S}\n   X, Y = dom(α), codom(α)\n   for (f, c, d) in zip(hom(S), dom(S), codom(S))\n     Xf, Yf, α_c, α_d = subpart(X,f), subpart(Y,f), α[c], α[d]\n     all(Yf[α_c(i)] == α_d(Xf[i]) for i in eachindex(Xf)) || return false\n   end\n   return true\nend","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"Notice how we iterate over the homs in the schema category S (f, c, d) in zip(hom(S), dom(S), codom(S)) We get one universally quantified equation all(Yf[α_c(i)] == α_d(Xf[i]) for i in eachindex(Xf)) for each morphism in the indexing category","category":"page"},{"location":"generated/graphs/graphs/#Exercise:-2","page":"The Category of Graphs","title":"Exercise:","text":"","category":"section"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"Take your graph from the previous exercise and construct a graph homomorphism from the wedge (w) into it.\nCheck that the naturality equations are satisfied.\nExplain why we don't need to specify any data for the source and target morphisms in SchGraph when definining a graph homomorphism","category":"page"},{"location":"generated/graphs/graphs/#Finding-Homomorphisms-Automatically","page":"The Category of Graphs","title":"Finding Homomorphisms Automatically","text":"","category":"section"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"As you saw in the previous exercise, constructing a natural transformation can be quite tedious. We want computers to automate tedious things for us. So we use an algorithm to enumerate all the homomorphisms between two CSets.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"CSet homomorphisms f:A→B are ways of finding a part of B that is shaped like A. You can view this as pattern matching. The graph A is the pattern and the graph B is the data. A morphism f:A→B is a collection of vertices and edges in B that is shaped like A. Note that you can ask Catlab to enforce constraints on the homomorphisms it will find including computing monic (injective) morphisms by passing the keyword monic=true. A monic morphism into B is a subobject of B.  You can pass iso=true to get isomorphisms.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"t = @acset Graph begin\n    V = 3\n    E = 3\n    src = [1,2,1]\n    tgt = [2,3,3]\nend\n\ndraw(t)\n\nT = @acset Graph begin\n    V = 6\n    E = 9\n    src = [1,2,1, 3, 1,5,2,2,4]\n    tgt = [2,3,3, 4, 4,6,5,6,6]\nend\n\ndraw(T)","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"The simplest pattern in a graph is just a single edge and each homomorphism ϕ:e→G is a single edge in G.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"length(homomorphisms(e, T, monic=true)) == nparts(T,:E) # number of edges\n\n\nlength(homomorphisms(t, T))","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"We can define this helper function to print out all the homomorphisms between graphs. Because all our graphs are simple, we only need to look at the vertex components.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"graphhoms(g,h) = begin\n    map(homomorphisms(g,h)) do ϕ\n        collect(ϕ[:V])\n    end\nend\n\ngraphhoms(t, T)","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"Homs ϕ:t→T are little triangles in T, but homs ϕ:T→t are colorings of T with 3 colors. The fact that there are edges in t that are missing, means that it provides constraints on what graphs have morphisms into it. For example, there are no morphisms T→t.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"graphhoms(T, t)","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"The reason we don't have a morphism into t is vertices 2,3,4,5 aren't arranged into a triangle. We can relax those constraints by adding loops to the codomain. Loops in the codomain allow you to merge adjacent vertices when you construct the homomorphism.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"add_loops!(g) = add_parts!(g, :E, nparts(g,:V), src=parts(g,:V), tgt=parts(g,:V))\nadd_loops(g) = begin\n    h = copy(g)\n    add_loops!(h)\n    return h\nend\n\ndraw(add_loops(t))","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"Once we add loops, then we have morphisms.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"length(homomorphisms(T,add_loops(t)))","category":"page"},{"location":"generated/graphs/graphs/#Bipartite-Graphs","page":"The Category of Graphs","title":"Bipartite Graphs","text":"","category":"section"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"Many computer science problems involve graphs that have two types of vertices. For example, when matching students to classes, you might represent the students as one type of vertex and the classes as another type of vertex. Then the edges (s,c) represent \"student s is enrolled in class c\". In this scenario there can be no edges from a class vertex to another class vertex, or from a student vertex to a student vertex. Graphs for which there exists such a classification are called bipartite graphs. In Category Theory, we shift from thinking about graphs with properties to graph homomorphisms that witness that property and think of bipartitioned graphs.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"First we construct a bipartite graph:","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"sq = apex(product(add_loops(e), add_loops(e)))\nrem_parts!(sq, :E, [1,5,6,8,9])\ndraw(sq)","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"We will use the symmetric edge graph to identify the bipartitions of this graph.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"esym = @acset Graph begin\n    V = 2\n    E = 2\n    src = [1,2]\n    tgt = [2,1]\nend\n\ndraw(id(esym))","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"There are two ways to bipartition sq.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"graphhoms(sq, esym)","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"This comes from the fact that esym has 2 automorphisms!","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"graphhoms(esym, esym)","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"the first coloring","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"draw(homomorphisms(sq, esym)[1])","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"but we can also swap the roles of the colors","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"draw(homomorphisms(sq, esym)[2])","category":"page"},{"location":"generated/graphs/graphs/#Exercise:-3","page":"The Category of Graphs","title":"Exercise:","text":"","category":"section"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"Construct a graph representation of a checkerboard\nDraw the two bipartitions of the checkerboard","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"We can generalize the notion of Bipartite graph to any number of parts. I like to call Kₖ the k-coloring classifier because homomorphims into α:G → Kₖ are k-colorings of G.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"clique(k::Int) = begin\n    Kₖ = Graph(k)\n    for i in 1:k\n        for j in 1:k\n            if j ≠ i\n                add_parts!(Kₖ, :E, 1, src=i, tgt=j)\n            end\n        end\n    end\n    return Kₖ\nend\n\nK₃ = clique(3)\ndraw(id(K₃))","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"Our graph T is not 2-colorable,","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"length(homomorphisms(T, esym))","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"but we can use 3 colors to color T.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"draw(homomorphism(T, K₃))","category":"page"},{"location":"generated/graphs/graphs/#Exercise:-4","page":"The Category of Graphs","title":"Exercise:","text":"","category":"section"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"Find a graph that is not 3-colorable\nFind a graph that is not 4-colorable","category":"page"},{"location":"generated/graphs/graphs/#Homomorphisms-in-[C,-Set]-are-like-Types","page":"The Category of Graphs","title":"Homomorphisms in [C, Set] are like Types","text":"","category":"section"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"Any graph can play the role of the codomain. If you pick a graph that is incomplete, you get a more constrained notion of coloring where there are color combinations that are forbidden.","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"triloop = @acset Graph begin\n    V = 3\n    E = 3\n    src = [1,2,3]\n    tgt = [2,3,1]\nend\n\ndraw(id(triloop))","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"With this graph, we can pick out directed 3-cycles in a graph like T2,","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"T2 = @acset Graph begin\n    V = 6\n    E = 6\n    src = [1,2,3,4,5,6]\n    tgt = [2,3,1,5,6,4]\nend\ngraphhoms(T2, triloop)","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"and we can draw those cyclic roles with colors","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"draw(homomorphisms(T2, triloop)[1])\n\nT3 = @acset Graph begin\n    V = 6\n    E = 7\n    src = [1,2,3,4,5,6, 2]\n    tgt = [2,3,1,5,6,4, 4]\nend\ngraphhoms(T3, triloop)","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"Using the colors as shown:","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"draw(id(triloop))","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"We can see our coloring of T3:","category":"page"},{"location":"generated/graphs/graphs/","page":"The Category of Graphs","title":"The Category of Graphs","text":"draw(homomorphisms(T3, triloop)[1])","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"EditURL = \"../../../literate/sketches/meets.jl\"","category":"page"},{"location":"generated/sketches/meets/#Meets-in-Preorders","page":"Meets in Preorders","title":"Meets in Preorders","text":"","category":"section"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"(Image: )","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"Our first example of a concept defined by a universal mapping property is a meet respectively meet.","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"The first step is our Catlab imports","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"using Core: GeneratedFunctionStub\nusing Test\n\nusing Catlab.GATs, Catlab.Theories, Catlab.CategoricalAlgebra\nusing Catlab.Graphics\n\nimport Catlab.Theories: compose\nusing DataStructures","category":"page"},{"location":"generated/sketches/meets/#Defining-some-basic-preorders","page":"Meets in Preorders","title":"Defining some basic preorders","text":"","category":"section"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"@present P(FreeSchema) begin\n  (a₁,a₂,a₃,a₄)::Ob\n  f::Hom(a₁, a₂)\n  g::Hom(a₁, a₃)\n  h::Hom(a₂, a₄)\n  k::Hom(a₃, a₄)\nend","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"We can draw a picture of our preorder as a Hasse Diagram.","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"to_graphviz(P)","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"It will be convenient to program with our preorders based on the Hasse Diagram represent as a labeled graph so we convert the Presentation{Schema, Symbol} into a FreeDigram. FreeDiagrams are implemented as an ACSet which you can think of as an in-memory database. ACSets are a key feature of Catlab that allow you to represent many data structures in a common framework.","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"g = FreeDiagram(P)","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"To give ourselves a graph-like API for Hasse Diagrams, we define parents and children.","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"parents(g, y::Int) = subpart(g, incident(g, y, :tgt), :src)\nchildren(g, x::Int) = subpart(g, incident(g, x, :src), :tgt)","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"We can compute upsets/downsets with breadth first search.","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"function bfs(g, x::Int, f=children)\n  explored = falses(nparts(g, :V))\n  explored[x] = 1\n  q = Queue{Int}()\n  enqueue!(q, x)\n  while !isempty(q)\n    v = dequeue!(q)\n    S = f(g,v)\n    map(filter(s -> !explored[s], S)) do s\n      enqueue!(q, s)\n    end\n    explored[S] .= true\n  end\n  return findall(explored)\nend","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"The upset of a preorder element is all the elements that come after it in the preorder.","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"upset(g,x) = bfs(g,x,children)","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"The downset is the dual notion, which we compute by reversing the role of children and parents.","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"downset(g,x) = bfs(g,x,parents)\n\nupset(g, 1)","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"We can use upsets to define the less than or equal two relation implied by any Hasse Diagram","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"function leq(g::FreeDiagram, x::Int, y::Int)\n  return y in upset(g, x)\nend","category":"page"},{"location":"generated/sketches/meets/#Exercise-1","page":"Meets in Preorders","title":"Exercise 1","text":"","category":"section"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"Define a more efficient algorithm for checking whether two elements satisfy the leq relation.","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"Multiple dispatch allows us to overload the leq function with another method for symbols.","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"function leq(g::FreeDiagram, x::Symbol, y::Symbol)\n  leq(g, incident(g, x, :ob), incident(g, y, :ob))\nend","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"the meet of two elements is the largest element in the intersection of their downsets.","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"function meet(g::FreeDiagram, x::Int, y::Int)\n  U = downset(g, x) ∩ downset(g,y)\n  maxima(g, U)\n  return maximum(g, U)\nend\n\nfunction meet(g::FreeDiagram, x, y)\n  meet(g, incident(g, x, :ob)[1], incident(g, y, :ob)[1])\nend","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"assuming that D is a downset, the maxima are those elements whose children are disjoint from D.","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"function maxima(g::FreeDiagram, D::Vector{Int})\n  X = Set(D)\n  M = filter(D) do x\n    Pₓ = children(g, x) ∩ X\n    length(Pₓ) == 0\n  end\n  return M\nend\n\nfunction hastop(g::FreeDiagram, xs::Vector{Int})\n  length(maxima(g, xs)) == 1\nend\n\nfunction maximum(g::FreeDiagram, xs::Vector{Int})\n  m = maxima(g, xs::Vector{Int})\n  if length(m) == 1\n    return m[1]\n  end\n  if length(m) > 1\n    all_iso = all(m) do a\n      Uₐ = downset(g, a)\n      a_le_allb = all(m) do b\n        b in Uₐ\n      end\n      return a_le_allb\n    end\n    if all_iso\n      return  m[1]\n    end\n  end\n  return nothing\nend","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"From the definition of minimum, you can see that when you want to do many leq queries in sequence, you can reuse the upsets that you compute with bfs. This is a place where mathematical abstractions don't work well with the operational needs of computer programming. In a mathematical definition you can define x ≤ y as y ∈ upset(x), but in programming, that is inefficient when you want to check a property like for all y in Y, x ≤ y. Programming requires you to reason about not only the correctness of the code, but also the performance. Much of the complexity of software engineering comes from the fact that computational performance requires the programmers to break down their clean abstractions to optimize the code.","category":"page"},{"location":"generated/sketches/meets/#Exercise-2","page":"Meets in Preorders","title":"Exercise 2","text":"","category":"section"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"If you wanted to perform many x ≤ y queries in a loop, you might want to precompute the matrix L where L[i,j] = 1 if and only if i ≤ j in the preorder P. Implement an algorithm that performs this computation in O(V⋅E) time where V is the number of elements in P and E is the number of edges in the corresponding FreeDiagram.","category":"page"},{"location":"generated/sketches/meets/#Testing-it-out","page":"Meets in Preorders","title":"Testing it out","text":"","category":"section"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"Let's make sure we get the answers that we expect.","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"using Test\n@testset \"Upsets\" begin\n  @test upset(g, 3) == [3,4]\n  @test upset(g, 2) == [2,4]\n  @test upset(g, 1) == [1,2,3,4]\n  @test upset(g, 4) == [4]\nend\n@testset \"Downsets\" begin\n  @test downset(g, 3) == [1,3]\n  @test downset(g, 2) == [1,2]\n  @test downset(g, 4) == [1,2,3,4]\n  @test downset(g, 1) == [1]\nend\n\n@testset \"Meets\" begin\n  @test meet(g, 2,3) == 1\n  @test meet(g, 1,2) == 1\n  @test meet(g, 3,4) == 3\n  @test meet(g, 1, 4) == 1\n  @test meet(g, 1, 1) == 1\n  @test meet(g, 2, 2) == 2\nend","category":"page"},{"location":"generated/sketches/meets/#Another-Example:","page":"Meets in Preorders","title":"Another Example:","text":"","category":"section"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"@present P(FreeSchema) begin\n  (a₁,a₂,a₃,a₄, a₅)::Ob\n  f::Hom(a₁, a₂)\n  g::Hom(a₁, a₃)\n  h::Hom(a₂, a₄)\n  k::Hom(a₃, a₄)\n  l::Hom(a₅, a₂)\nend","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"Which can be viewed as a picture:","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"to_graphviz(P)","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"Or, as tables:","category":"page"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"g = FreeDiagram(P)","category":"page"},{"location":"generated/sketches/meets/#Test-suite","page":"Meets in Preorders","title":"Test suite","text":"","category":"section"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"@testset \"meets2\" begin\n  @test meet(g, 2,3) == 1\n  @test meet(g, 1,2) == 1\n  @test meet(g, 3,4) == 3\n  @test meet(g, 1, 4) == 1\n  @test meet(g, 1, 1) == 1\n  @test meet(g, 2, 2) == 2\n  @test meet(g, 3, 5) == nothing\n  @test meet(g, 2, 5) == 5\nend","category":"page"},{"location":"generated/sketches/meets/#Exercise-3","page":"Meets in Preorders","title":"Exercise 3","text":"","category":"section"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"Make bigger preorders to test corner cases in the above code. If you find an example that breaks these implementations, please report it.","category":"page"},{"location":"generated/sketches/meets/#Exercise-4","page":"Meets in Preorders","title":"Exercise 4","text":"","category":"section"},{"location":"generated/sketches/meets/","page":"Meets in Preorders","title":"Meets in Preorders","text":"Implement the dual constructions for joins.","category":"page"},{"location":"apis/graphs/#graphs","page":"Graphs","title":"Graphs","text":"","category":"section"},{"location":"apis/graphs/","page":"Graphs","title":"Graphs","text":"Modules = [\n  Graphs.BasicGraphs,\n  Graphs.PropertyGraphs,\n  Graphs.GraphAlgorithms,\n]\nPrivate = false","category":"page"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs","page":"Graphs","title":"Catlab.Graphs.BasicGraphs","text":"Data structures for graphs, based on C-sets.\n\nProvides the category theorist's four basic kinds of graphs: graphs (aka directed multigraphs), symmetric graphs, reflexive graphs, and symmetric reflexive graphs. Also defines half-edge graphs. The API generally follows that of Graphs.jl, with some departures due to differences between the data structures.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.AbstractGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.AbstractGraph","text":"Abstract type for graphs, aka directed multigraphs.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.AbstractHalfEdgeGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.AbstractHalfEdgeGraph","text":"Abstract type for half-edge graphs, possibly with data attributes.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.AbstractLabeledGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.AbstractLabeledGraph","text":"Abstract type for labeled graphs.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.AbstractReflexiveGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.AbstractReflexiveGraph","text":"Abstract type for reflexive graphs, possibly with data attributes.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.AbstractSymmetricGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.AbstractSymmetricGraph","text":"Abstract type for symmetric graph, possibly with data attributes.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.AbstractSymmetricReflexiveGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.AbstractSymmetricReflexiveGraph","text":"Abstract type for symmetric reflexive graphs, possibly with data attributes.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.AbstractSymmetricWeightedGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.AbstractSymmetricWeightedGraph","text":"Abstract type for symmetric weighted graphs.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.AbstractWeightedGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.AbstractWeightedGraph","text":"Abstract type for weighted graphs.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.Graph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.Graph","text":"A graph, also known as a directed multigraph.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.HalfEdgeGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.HalfEdgeGraph","text":"A half-edge graph.\n\nHalf-edge graphs are a variant of undirected graphs whose edges are pairs of \"half-edges\" or \"darts\". Half-edge graphs are isomorphic to symmetric graphs but have a different data model.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.HasGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.HasGraph","text":"Abstract type for C-sets that contain a graph.\n\nThis type encompasses C-sets where the schema for graphs is a subcategory of C. This includes, for example, graphs, symmetric graphs, and reflexive graphs, but not half-edge graphs.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.HasVertices","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.HasVertices","text":"Abstract type for C-sets that contain vertices.\n\nThis type encompasses C-sets where the schema C contains an object V interpreted as vertices. This includes, for example, graphs and half-edge graphs, but not bipartite graphs or wiring diagrams.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.LabeledGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.LabeledGraph","text":"A labeled graph.\n\nBy convention, a \"labeled graph\" without qualification is a vertex-labeled graph. We do not require that the label be unique, and in this data type, the label attribute is not indexed.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.ReflexiveGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.ReflexiveGraph","text":"A reflexive graph.\n\nReflexive graphs are graphs in which every vertex has a distinguished self-loop.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.SymmetricGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.SymmetricGraph","text":"A symmetric graph, or graph with an orientation-reversing edge involution.\n\nSymmetric graphs are closely related, but not identical, to undirected graphs.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.SymmetricReflexiveGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.SymmetricReflexiveGraph","text":"A symmetric reflexive graph.\n\nSymmetric reflexive graphs are both symmetric graphs (SymmetricGraph) and reflexive graphs (ReflexiveGraph) such that the reflexive loops are fixed by the edge involution.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.SymmetricWeightedGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.SymmetricWeightedGraph","text":"A symmetric weighted graph.\n\nA symmetric graph in which every edge has a numerical weight, preserved by the edge involution.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.WeightedGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.WeightedGraph","text":"A weighted graph.\n\nA graph in which every edge has a numerical weight.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Base.inv-Tuple{AbstractHalfEdgeGraph, Vararg{Any}}","page":"Graphs","title":"Base.inv","text":"Involution on half-edge(s) in a half-edge graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Base.inv-Tuple{HasGraph, Vararg{Any}}","page":"Graphs","title":"Base.inv","text":"Involution on edge(s) in a symmetric graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.add_dangling_edge!-Tuple{AbstractHalfEdgeGraph, Int64}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.add_dangling_edge!","text":"Add a dangling edge to a half-edge graph.\n\nA \"dangling edge\" is a half-edge that is paired with itself under the half-edge involution. They are usually interpreted differently than \"self-loops\", i.e., a pair of distinct half-edges incident to the same vertex.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.add_dangling_edges!-Tuple{AbstractHalfEdgeGraph, AbstractVector{Int64}}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.add_dangling_edges!","text":"Add multiple dangling edges to a half-edge graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.add_edge!-Tuple{HasGraph, Int64, Int64}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.add_edge!","text":"Add an edge to a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.add_edges!-Tuple{HasGraph, AbstractVector{Int64}, AbstractVector{Int64}}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.add_edges!","text":"Add multiple edges to a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.add_vertex!-Tuple{HasVertices}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.add_vertex!","text":"Add a vertex to a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.add_vertices!-Tuple{HasVertices, Int64}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.add_vertices!","text":"Add multiple vertices to a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.add_vertices_with_indices!-Tuple{HasVertices, Int64, Int64}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.add_vertices_with_indices!","text":"Add vertices with preallocated src/tgt indexes\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.all_neighbors-Tuple{AbstractGraph, Int64}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.all_neighbors","text":"Union of in-neighbors and out-neighbors in a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.degree-Tuple{Any, Any}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.degree","text":"Total degree of a vertex\n\nEquivalent to length(all_neighbors(g,v)) but faster\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.edges-Tuple{HasGraph}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.edges","text":"Edges in a graph, or between two vertices in a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.half_edges-Tuple{AbstractHalfEdgeGraph}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.half_edges","text":"Half-edges in a half-edge graph, or incident to a vertex.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.has_edge-Tuple{HasGraph, Any}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.has_edge","text":"Whether the graph has the given edge, or an edge between two vertices.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.has_vertex-Tuple{HasVertices, Any}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.has_vertex","text":"Whether the graph has the given vertex.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.induced_subgraph-Union{Tuple{G}, Tuple{G, AbstractVector{Int64}}} where G<:HasGraph","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.induced_subgraph","text":"Subgraph induced by a set of a vertices.\n\nThe induced subgraph consists of the given vertices and all edges between vertices in this set.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.inedges-Tuple{HasGraph, Any}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.inedges","text":"Edges coming into a vertex\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.inneighbors-Tuple{AbstractGraph, Int64}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.inneighbors","text":"In-neighbors of vertex in a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.ne-Tuple{HasGraph}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.ne","text":"Number of edges in a graph, or between two vertices in a graph.\n\nIn a symmetric graph, this function counts both edges in each edge pair, so that the number of edges in a symmetric graph is twice the number of edges in the corresponding undirected graph (at least when the edge involution has no fixed points).\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.neighbors-Tuple{AbstractGraph, Int64}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.neighbors","text":"Neighbors of vertex in a graph.\n\nIn a graph, this function is an alias for outneighbors; in a symmetric graph, a vertex has the same out-neighbors and as in-neighbors, so the distinction is moot.\n\nIn the presence of multiple edges, neighboring vertices are given with multiplicity. To get the unique neighbors, call unique(neighbors(g)).\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.nv-Tuple{HasVertices}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.nv","text":"Number of vertices in a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.outedges-Tuple{HasGraph, Any}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.outedges","text":"Edges coming out of a vertex\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.outneighbors-Tuple{AbstractGraph, Int64}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.outneighbors","text":"Out-neighbors of vertex in a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.refl-Tuple{HasGraph, Vararg{Any}}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.refl","text":"Reflexive loop(s) of vertex (vertices) in a reflexive graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.rem_edge!-Tuple{HasGraph, Int64}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.rem_edge!","text":"Remove an edge from a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.rem_edges!-Tuple{HasGraph, Any}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.rem_edges!","text":"Remove multiple edges from a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.rem_vertex!-Tuple{HasVertices, Int64}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.rem_vertex!","text":"Remove a vertex from a graph.\n\nWhen keep_edges is false (the default), all edges incident to the vertex are also deleted. When keep_edges is true, incident edges are preserved but their source/target vertices become undefined.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.rem_vertices!-Tuple{AbstractGraph, Any}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.rem_vertices!","text":"Remove multiple vertices from a graph.\n\nEdges incident to any of the vertices are treated as in rem_vertex!.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.vertex-Tuple{AbstractHalfEdgeGraph, Vararg{Any}}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.vertex","text":"Incident vertex (vertices) of half-edge(s) in a half-edge graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.vertices-Tuple{HasVertices}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.vertices","text":"Vertices in a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.BasicGraphs.weight-Tuple{HasGraph, Vararg{Any}}","page":"Graphs","title":"Catlab.Graphs.BasicGraphs.weight","text":"Weight(s) of edge(s) in a weighted graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Theories.src-Tuple{HasGraph, Vararg{Any}}","page":"Graphs","title":"Catlab.Theories.src","text":"Source vertex (vertices) of edges(s) in a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Theories.tgt-Tuple{HasGraph, Vararg{Any}}","page":"Graphs","title":"Catlab.Theories.tgt","text":"Target vertex (vertices) of edges(s) in a graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.AbstractPropertyGraph","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.AbstractPropertyGraph","text":"Abstract type for graph with properties.\n\nConcrete types are PropertyGraph and SymmetricPropertyGraph.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.PropertyGraph","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.PropertyGraph","text":"Graph with properties.\n\n\"Property graphs\" are graphs with arbitrary named properties on the graph, vertices, and edges. They are intended for applications with a large number of ad-hoc properties. If you have a small number of known properties, it is better and more efficient to create a specialized C-set type using @acset_type.\n\nSee also: SymmetricPropertyGraph.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.SymmetricPropertyGraph","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.SymmetricPropertyGraph","text":"Symmetric graphs with properties.\n\nThe edge properties are preserved under the edge involution, so these can be interpreted as \"undirected\" property (multi)graphs.\n\nSee also: PropertyGraph.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.eprops-Tuple{AbstractPropertyGraph, Any}","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.eprops","text":"Properties of edge in a property graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.get_eprop-Tuple{AbstractPropertyGraph, Any, Symbol}","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.get_eprop","text":"Get property of edge or edges in a property graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.get_gprop-Tuple{AbstractPropertyGraph, Symbol}","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.get_gprop","text":"Get graph-level property of a property graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.get_vprop-Tuple{AbstractPropertyGraph, Any, Symbol}","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.get_vprop","text":"Get property of vertex or vertices in a property graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.gprops-Tuple{AbstractPropertyGraph}","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.gprops","text":"Graph-level properties of a property graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.set_eprop!-Tuple{AbstractPropertyGraph, Any, Symbol, Any}","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.set_eprop!","text":"Set property of edge or edges in a property graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.set_eprops!-Tuple{AbstractPropertyGraph, Int64}","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.set_eprops!","text":"Set multiple properties of an edge in a property graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.set_gprop!-Tuple{AbstractPropertyGraph, Symbol, Any}","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.set_gprop!","text":"Set graph-level property in a property graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.set_gprops!-Tuple{AbstractPropertyGraph}","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.set_gprops!","text":"Set multiple graph-level properties in a property graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.set_vprop!-Tuple{AbstractPropertyGraph, Any, Symbol, Any}","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.set_vprop!","text":"Set property of vertex or vertices in a property graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.set_vprops!-Tuple{AbstractPropertyGraph, Int64}","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.set_vprops!","text":"Set multiple properties of a vertex in a property graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.PropertyGraphs.vprops-Tuple{AbstractPropertyGraph, Any}","page":"Graphs","title":"Catlab.Graphs.PropertyGraphs.vprops","text":"Properties of vertex in a property graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.GraphAlgorithms","page":"Graphs","title":"Catlab.Graphs.GraphAlgorithms","text":"Algorithms on graphs based on C-sets.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphs/#Catlab.Graphs.GraphAlgorithms.connected_component_projection","page":"Graphs","title":"Catlab.Graphs.GraphAlgorithms.connected_component_projection","text":"Projection onto (weakly) connected components of a graph.\n\nReturns a function in FinSet{Int} from the vertex set to the set of components.\n\n\n\n\n\n","category":"function"},{"location":"apis/graphs/#Catlab.Graphs.GraphAlgorithms.connected_components-Tuple{ACSet}","page":"Graphs","title":"Catlab.Graphs.GraphAlgorithms.connected_components","text":"(Weakly) connected components of a graph.\n\nReturns a vector of vectors, which are the components of the graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.GraphAlgorithms.enumerate_paths-Tuple{Graph}","page":"Graphs","title":"Catlab.Graphs.GraphAlgorithms.enumerate_paths","text":"Enumerate all paths of an acyclic graph, indexed by src+tgt\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.GraphAlgorithms.topological_sort-Tuple{ACSet}","page":"Graphs","title":"Catlab.Graphs.GraphAlgorithms.topological_sort","text":"Topological sort of a directed acyclic graph.\n\nThe depth-first search algorithm is adapted from the function topological_sort_by_dfs in Graphs.jl.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphs/#Catlab.Graphs.GraphAlgorithms.transitive_reduction!-Tuple{ACSet}","page":"Graphs","title":"Catlab.Graphs.GraphAlgorithms.transitive_reduction!","text":"Transitive reduction of a DAG.\n\nThe algorithm computes the longest paths in the DAGs and keeps only the edges corresponding to longest paths of length 1. Requires a topological sort, which is computed if it is not supplied.\n\n\n\n\n\n","category":"method"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"EditURL = \"../../../literate/categorical_algebra/diagrams.jl\"","category":"page"},{"location":"generated/categorical_algebra/diagrams/#Diagrams","page":"Diagrams","title":"Diagrams","text":"","category":"section"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"Catlab supports the expression of equations in an arbitrary category via diagrams, or functors from a finitely presented category. This view of diagrammatic equations builds on the Catlab approach to functorial semantics by asserting that a system of equations of shape J is a functor F: J → 𝐂. We can draw these equations with Graphviz, where each node is an object in X:Ob(J) labeled with its type F(X) and each edge is a morphism in J labeled with its image under F.","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"using Catlab.GATs, Catlab.Theories, Catlab.CategoricalAlgebra\nusing Catlab.Graphs, Catlab.Graphics, Catlab.Programs\n\ndraw(d::Diagram) = to_graphviz(d, prog=\"neato\", node_labels=true, edge_labels=true)","category":"page"},{"location":"generated/categorical_algebra/diagrams/#Present-a-diagram-in-a-given-category","page":"Diagrams","title":"Present a diagram in a given category","text":"","category":"section"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"Recall that a diagram in a category C is a functor F J  C from a small category J into C. Given the category C, this macro presents a diagram in C, i.e., constructs a finitely presented indexing category J together with a functor F J  C. This method of simultaneous definition is often more convenient than defining J and F separately, as could be accomplished by calling @fincat and then @finfunctor. For example, the limit of the following diagram consists of the paths of length two in a graph:","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"D₂ = @free_diagram SchGraph begin\n  v::V\n  (e₁, e₂)::E\n  tgt(e₁) == v\n  src(e₂) == v\nend","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"Morphisms in the indexing category can be left unnamed, which is convenient for defining free diagrams (see also @free_diagram. Of course, unnamed morphisms cannot be referenced by name within the @diagram call or in other settings, which can sometimes be problematic.","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"We can also draw the resulting diagrams.","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"draw(D₂)","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"For small equations the point-free notation commonly employed in functional programming is very convenient; however, there is a reason it is not the standard approach to presenting equations in mathematical writing. Variables are just too useful! As the size of the system of equations grows, it becomes more and more convenient to use variable names. This is why Catlab.Programs.@program exists to help people write SMC morphisms with the point-ful notation they are familiar with in imperative or procedural programming.","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"We can describe a triangle in a graph using the vertex variables v₁, v₂, v₃ and edge variables e₁, e₂, e₃. Then we use the equation notation to assert the src and tgt relationships between the edges and vertices.","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"D₃ = @free_diagram SchGraph begin\n  (v₁, v₂, v₃)::V\n  (e₁, e₂, e₃)::E\n  src(e₁) == v₁\n  tgt(e₁) == v₂\n  src(e₂) == v₂\n  src(e₃) == v₁\n  tgt(e₂) == v₃\n  tgt(e₃) == v₃\nend","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"You can see the shape of a triangle when you draw this diagram. This coincidence can be systematically understood (by an experienced category theorist) via the Grothendieck construction and representable functors.","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"draw(D₃)","category":"page"},{"location":"generated/categorical_algebra/diagrams/#Sequences-in","page":"Diagrams","title":"Sequences in","text":"","category":"section"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"In any category with an endomorphism f: A → A, we can think of recurrence equations as aₙ = f(aₙ₋₁)) starting at a₀.","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"@present 𝗖(FreeCartesianCategory) begin\n  (A,B)::Ob\n  f::Hom(A,A)\n  g::Hom(A,B)\nend\n\nseq₃ = @free_diagram 𝗖 begin\n  (a₀,a₁,a₂,a₃)::A\n  a₁ == f(a₀)\n  a₂ == f(a₁)\n  a₃ == f(a₂)\nend\n\ndraw(seq₃)","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"Inspired by linear recurrence relations like the Fibonacci sequence we can think of A and B as vector spaces. An endomorphism f: A → A and morphism g: A → B defines a linear recurrence by applying f to update the system state and g to compute the current term in the sequence. This can be visualized as follows.","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"obs_seq₃ = @free_diagram 𝗖 begin\n  (a₀,a₁,a₂,a₃)::A\n  (b₁, b₂, b₃ )::B\n  a₁ == f(a₀)\n  b₁ == g(a₁)\n  a₂ == f(a₁)\n  b₂ == g(a₂)\n  a₃ == f(a₂)\n  b₃ == g(a₃)\nend\ndraw(obs_seq₃)","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"In the case of the Fibonacci sequence A is ℝ² and B is ℝ with f = [1 1; 1 0] and g = π₁.","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"@present 𝐃(FreeCartesianCategory) begin\n  (ℝ²,ℝ)::Ob\n  f::Hom(ℝ²,ℝ²)\n  π₁::Hom(ℝ²,ℝ)\nend\n\nfib_seq₃ = @free_diagram 𝐃 begin\n  (a₀,a₁,a₂,a₃)::ℝ²\n  (b₁, b₂, b₃ )::ℝ\n  a₁ == f(a₀)\n  b₁ == π₁(a₁)\n  a₂ == f(a₁)\n  b₂ == π₁(a₂)\n  a₃ == f(a₂)\n  b₃ == π₁(a₃)\nend\n\ndraw(fib_seq₃)","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"A lift of this diagram is a choice of vectors a₀,…,a₃ and scalars b₁,…,b₃ that satisfy the linear recurrence formulation of the Fibonacci sequence. The arrows in 𝐃 are treated as fixed for the purpose of the lifting problem. Suppose you knew b₁,…,b₃, and wanted to infer the state vectors a₁,…,a₃. This can be seen as a boundary value problem where you have observations on a subspace playing the role of boundary conditions and want to infer the system state on the interior of the domain. As you can see from this diagram, solving the lifting problem with only partial information can require some creativity. You need to use the structure of the codomain category, in this case 𝐃 which is a subcategory of finite dimensional vector spaces over ℝ and the combinatorics of 𝐉 to set up some equations you can solve. In order to obtain an efficient algorithm for the lifting problem, you would need to exploit the structure of the morphisms f,π₁ to create a system of equations.","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"An observation that [π₁f;π₁] = f lets you set up the equation [b₃ ; b₂] = f a₂ and then you can use the fact that f is invertable to solve for a unique a₂. Once you have a single value of aᵢ you can get the rest from the application of f or f⁻¹. A general purpose algorithm for solving lifting problems in arbitrary categories would be a wildly powerful tool.","category":"page"},{"location":"generated/categorical_algebra/diagrams/#Newton's-Method","page":"Diagrams","title":"Newton's Method","text":"","category":"section"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"The equations that we have seen aren't particularly interesting, so we turn to a classic of numerical methods. Newton's method for root finding. For an overview of Netwon's method see Fundamentals of Numerical Computation. The following presentation doesn't know that f′ is the derivative of f, they are just two functions that are evocatively named. We could use CombinatorialSpaces.jl to formulate this in a richer categorical setting where we could assert f′ := d/dx(f).","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"@present Analytic(FreeCartesianCategory) begin\n  (ℝ,ℝ²)::Ob\n  π₁::Hom(ℝ², ℝ)\n  π₂::Hom(ℝ², ℝ)\n  plus ::Hom(ℝ², ℝ)\n  times::Hom(ℝ², ℝ)\n  f    ::Hom(ℝ,ℝ)\n  f′   ::Hom(ℝ,ℝ)\nend","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"According to the standard formula xₖ₊₁ = xₖ - f(xₖ)/f′(xₖ). The standard presentation of Newton's method relies on the fact that ℝ is a field to use division in the definition of the iterative procedure. Because of the constraint that you can't divide by 0 in a field, fields are not models of any algebraic theory. Because of this, we can multiply both sides by f′(xₖ) and define a Newton's method iteration without reference to division. We also can avoid negation by adding the f(xₖ) term on both sides.","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"Once we have put Newton's method into this relational form we can use a prefix notation for operators which makes the structure closer to the diagrammatic approach plus(times(f′(xₖ), xₖ₊₁), f(xₖ)) == times(f′(xₖ), xₖ).","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"newtons = @free_diagram Analytic begin\n  (xₖ, xₖ₊₁, dₖ, fx, v, ∏)::ℝ\n  (p₁, p₂, p₃)::ℝ²\n  dₖ  == f′(xₖ)\n  π₁(p₁) == dₖ\n  π₂(p₁) == xₖ₊₁\n  ∏ == times(p₁)\n  fx == f(xₖ)\n  π₁(p₂) == ∏\n  π₂(p₂) == fx\n  plus(p₂) == v\n  π₁(p₃) == dₖ\n  π₂(p₃) == xₖ\n  times(p₃) == v\nend\n\ndraw(newtons)","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"This is definitely a case where standard mathematical notation wins for brevity and clarity. To compete with traditional notation, we need a few ergonamic improvements to the diagrammatic equation approach.","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"The ability to assert equations without introducing temporary variables,\nThe ability to represent morphisms f: A×B → C as bivariate functions like f(a:A, b:B),","category":"page"},{"location":"generated/categorical_algebra/diagrams/","page":"Diagrams","title":"Diagrams","text":"While encoding simple equations can be more verbose than the traditional notation, the diagrammatic encoding provides a direct route to creating a category whose objects are systems of equations and whose morphisms are relationships between systems of equations. That category is the first step towards leveraging the constructive approach in Catlab to making hierarchical representations of complex systems of equations.","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"EditURL = \"../../../literate/sketches/partitions.jl\"","category":"page"},{"location":"generated/sketches/partitions/#Partitions","page":"Partitions","title":"Partitions","text":"","category":"section"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"(Image: )","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"Partitions are a categorical construction that we derive from sets and functions. Given a set A, you can think of all of the ways to partition A into parts. These ways of partitioning are isomorphic to equivalence relations R ⊆ A × A.","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"The first step is our Catlab imports","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"using Core: GeneratedFunctionStub\nusing Test\n\nusing Catlab.GATs, Catlab.Theories, Catlab.CategoricalAlgebra\nimport Catlab.Theories: compose\nusing DataStructures\nusing PrettyTables\nPrettyTables.pretty_table(f::FinFunction, name::Symbol=:f) =\n  pretty_table(OrderedDict(:x=>1:length(dom(f)), Symbol(\"$(name)(x)\")=>collect(f)))\nusing LaTeXStrings","category":"page"},{"location":"generated/sketches/partitions/#FinSet:-the-category-of-Finite-Sets","page":"Partitions","title":"FinSet: the category of Finite Sets","text":"","category":"section"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"In FinSet the objects are sets n = {1...n} and the morphisms are functions between finite sets. You can wrap a plain old Int into a finite set with the FinSet(n::Int) function. These sets will serve as the domain and codomains of our functions.","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"n = FinSet(3)\nm = FinSet(4)","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"once you have some sets, you can define functions between them. A FinFunction from n to m, f:n→m, can be specified as an array of length n with elements from m.","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"f = FinFunction([2,4,3], n, m)\n\npretty_table(f)","category":"page"},{"location":"generated/sketches/partitions/#Surjective-maps","page":"Partitions","title":"Surjective maps","text":"","category":"section"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"In order to use a map to represent a partition, we have to make sure that it is surjective. Given a FinFunction, we can compute the preimage of any element in its codomain.","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"preimage(f, 2)\n\npreimage(f, 1)","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"If the preimage is empty, then there is no element in the domain that maps to that element of the codomain. This gives us a definition of surjective functions by asserting that all the preimages are nonempty. Julia note: !p is the predicate x ↦ ¬p(x), f.(A) applies f to all of the elements in A.","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"is_surjective(f::FinFunction) = all((!isempty).(preimage(f,i) for i in codom(f)))\nis_surjective(f)","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"Our function f, wasn't surjective so it can't be used to induce a partition via its preimages. Let's try again,","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"g = FinFunction([1,2,3,3], m, n)\npretty_table(g, :g)\nis_surjective(g)","category":"page"},{"location":"generated/sketches/partitions/#Refinements-of-a-Partition","page":"Partitions","title":"Refinements of a Partition","text":"","category":"section"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"When defining partitions classically as A = ∪ₚ Aₚ with p ≠ r ⟹ Aₚ ≠ Aᵣ, it is not immediately obvious how to define comparisons between partitions. With the \"a partition of A is a surjective map out of A\" definition, the comparisons are obvious. The composition of surjective maps is surjective, so we can define the refinement order in terms of a diagram in Set.","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"You can see a graphical definition in quiver","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"using TikzCDs\n\ntriangle = L\"\"\"\nA &&& Q \\\\\n\\\\\n&&& P\n\\arrow[\"h\", two heads, from=1-4, to=3-4]\n\\arrow[\"f\", two heads, from=1-1, to=1-4]\n\\arrow[\"g\"', two heads, from=1-1, to=3-4]\n\"\"\";\n\nTikzCD(triangle, preamble=TikzCDs.Styles.Quiver)","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"Let's take a look at an example:","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"A = FinSet(4)\nQ = FinSet(3)\nP = FinSet(2)\n\nf = FinFunction([1,2,3,3], A, Q)\ng = FinFunction([1,1,2,2], A, P)\nh = FinFunction([1,1,2], Q, P)\n\n@test_throws ErrorException compose(g,h) #Catlab checks the domains match\n\npretty_table(compose(f,h), Symbol(\"(f⋅h)\"))\n\ncompose(f,h) == g","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"This triangle commutes, so f is a refinement of g equivalently g is coarser than f.","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"h′ = FinFunction([1,1], P, FinSet(1))\n\npretty_table(f⋅h⋅h′, Symbol(\"f⋅h⋅h′\"))","category":"page"},{"location":"generated/sketches/partitions/#Properties-of-refinements","page":"Partitions","title":"Properties of refinements","text":"","category":"section"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"We can show that refinement gives us a preorder on partitions directly from the nice properties of surjective maps.","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"Reflexive: Any partition is a refinement of itself.\nTransitive: If f ≤ g ≤ h as partitions, then f ≤ h","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"You can read these directly off the definition of refinements as a commutative triangle in the category of (Set, Surjections). You can edit this diagram in quiver","category":"page"},{"location":"generated/sketches/partitions/","page":"Partitions","title":"Partitions","text":"refinement = L\"\"\"\nA &&& Q \\\\\n\\\\\n&&& P \\\\\n\\\\\n&&& {Q^\\prime}\n\\arrow[\"h\", from=1-4, to=3-4]\n\\arrow[\"f\", two heads, from=1-1, to=1-4]\n\\arrow[\"g\"', two heads, from=1-1, to=3-4]\n\\arrow[\"{h^\\prime}\", from=3-4, to=5-4]\n\\arrow[\"{f\\cdot h\\cdot h^\\prime = g\\cdot h^\\prime}\"', two heads, from=1-1, to=5-4]\n\"\"\";\n\nTikzCD(refinement, preamble=TikzCDs.Styles.Quiver)","category":"page"},{"location":"apis/theories/#Standard-library-of-theories","page":"Standard library of theories","title":"Standard library of theories","text":"","category":"section"},{"location":"apis/theories/","page":"Standard library of theories","title":"Standard library of theories","text":"Through the module Catlab.Theories, Catlab provides a standard library of generalized algebraic theories for categories, monoidal categories, and other categorical structures. The theories correspond, in most cases, to standard definitions in category theory and they are used throughout Catlab and the AlgebraicJulia ecosystem to structure programs and provide a common interface for applied category theory. The module also provides default syntax systems for many of the theories.","category":"page"},{"location":"apis/theories/","page":"Standard library of theories","title":"Standard library of theories","text":"Categorical structures for which theories are provided include:","category":"page"},{"location":"apis/theories/","page":"Standard library of theories","title":"Standard library of theories","text":"categories\nmonoidal and symmetric monoidal categories\ncartesian and cocartesian categories\nsemiadditive categories/biproduct categories\nhypergraph categories\nbicategories of relations\ncategories with two monoidal products, such as distributive monoidal categories","category":"page"},{"location":"apis/theories/","page":"Standard library of theories","title":"Standard library of theories","text":"The contents of this module can be supplemented by the user, and it is even possible to use many parts of Catlab without using this module. The user is free to create new syntax systems for the theories defined here and also to define entirely new theories.","category":"page"},{"location":"apis/theories/","page":"Standard library of theories","title":"Standard library of theories","text":"Modules = [ Theories ]\nPrivate = false","category":"page"},{"location":"apis/theories/#Catlab.Theories","page":"Standard library of theories","title":"Catlab.Theories","text":"Catlab's standard library of generalized algebraic theories.\n\nThe focus is on categories and monoidal categories, but other related structures are also included.\n\n\n\n\n\n","category":"module"},{"location":"apis/theories/#Catlab.Theories.CategoryExpr","page":"Standard library of theories","title":"Catlab.Theories.CategoryExpr","text":"Base type for GAT expressions in categories or other categorical structures.\n\nAll symbolic expression types exported by Catlab.Theories are subtypes of this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.HomExpr","page":"Standard library of theories","title":"Catlab.Theories.HomExpr","text":"Base type for morphism expressions in categorical structures.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ObExpr","page":"Standard library of theories","title":"Catlab.Theories.ObExpr","text":"Base type for object expressions in categorical structures.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThAbelianBicategoryRelations","page":"Standard library of theories","title":"Catlab.Theories.ThAbelianBicategoryRelations","text":"Theory of abelian bicategories of relations\n\nUnlike ThBicategoryRelations, this theory uses additive notation.\n\nReferences:\n\nCarboni & Walters, 1987, \"Cartesian bicategories I\", Sec. 5\nBaez & Erbele, 2015, \"Categories in control\"\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThAdditiveCategory","page":"Standard library of theories","title":"Catlab.Theories.ThAdditiveCategory","text":"Theory of additive categories\n\nAn additive category is a biproduct category enriched in abelian groups. Thus, it is a semiadditive category where the hom-monoids have negatives.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThAlgebraicLattice","page":"Standard library of theories","title":"Catlab.Theories.ThAlgebraicLattice","text":"Theory of lattices as algebraic structures\n\nThis is one of two standard axiomatizations of a lattice, the other being ThLattice. Because the partial order is not present, this theory is merely an algebraic theory (no dependent types).\n\nThe partial order is recovered as A  B iff A  B = A iff A  B = B. This definition could be reintroduced into a generalized algebraic theory using an equality type Eq(lhs::El, rhs::El)::TYPE combined with term constructors `meet_leq(eq::Eq(A∧B, A))::(A ≤ B) and join_leq(eq::Eq(A∨B, B))::(A ≤ B). We do not employ that trick here because at that point it is more convenient to just start with the poset structure, as in ThLattice.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThBicategoryRelations","page":"Standard library of theories","title":"Catlab.Theories.ThBicategoryRelations","text":"Theory of bicategories of relations\n\nTODO: The 2-morphisms are missing.\n\nReferences:\n\nCarboni & Walters, 1987, \"Cartesian bicategories I\"\nWalters, 2009, blog post, \"Categorical algebras of relations\", http://rfcwalters.blogspot.com/2009/10/categorical-algebras-of-relations.html\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThBiproductCategory","page":"Standard library of theories","title":"Catlab.Theories.ThBiproductCategory","text":"Theory of biproduct categories\n\nMathematically the same as ThSemiadditiveCategory but written multiplicatively, instead of additively.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThCartesianCategory","page":"Standard library of theories","title":"Catlab.Theories.ThCartesianCategory","text":"Theory of cartesian (monoidal) categories\n\nFor the traditional axiomatization of products, see ThCategoryWithProducts.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThCartesianClosedCategory","page":"Standard library of theories","title":"Catlab.Theories.ThCartesianClosedCategory","text":"Theory of cartesian closed categories, aka CCCs\n\nA CCC is a cartesian category with internal homs (aka, exponential objects).\n\nFIXME: This theory should also extend ThClosedMonoidalCategory, but multiple inheritance is not yet supported.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThCartesianDoubleCategory","page":"Standard library of theories","title":"Catlab.Theories.ThCartesianDoubleCategory","text":"Theory of a cartesian double category\n\nLoosely speaking, a cartesian double category is a double category D such that the underlying catgories D₀ and D₁ are both cartesian categories, in a compatible way.\n\nReference: Aleiferi 2018, PhD thesis.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThCategory","page":"Standard library of theories","title":"Catlab.Theories.ThCategory","text":"Theory of categories\n\nNote: Throughout Catlab, we compose morphisms in diagrammatic order (from left to right), i.e., if fAB and gBC then the composite morphism fgAC is compose(f,g). Under this convention, functions are applied on the right, e.g., if a  A then af  B.\n\nWe retain the usual meaning of the symbol  (\\circ), i.e., gf is compose(f,g). This usage is too entrenched to overturn. However, we use the symbol  (\\cdot) for composition in diagrammatic order.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThCategory2","page":"Standard library of theories","title":"Catlab.Theories.ThCategory2","text":"Theory of 2-categories\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThCategoryWithCoproducts","page":"Standard library of theories","title":"Catlab.Theories.ThCategoryWithCoproducts","text":"Theory of a category with (finite) coproducts\n\nFinite coproducts are presented in biased style, via the nullary case (initial objects) and the binary case (binary coproducts). The axioms are dual to those of ThCategoryWithProducts.\n\nFor a monoidal category axiomatization of finite coproducts, see ThCocartesianCategory.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThCategoryWithProducts","page":"Standard library of theories","title":"Catlab.Theories.ThCategoryWithProducts","text":"Theory of a category with (finite) products\n\nFinite products are presented in biased style, via the nullary case (terminal objects) and the binary case (binary products). The equational axioms are standard, especially in type theory (Lambek & Scott, 1986, Section 0.5 or Section I.3). Strictly speaking, this theory is not of a \"category with finite products\" (a category in which finite products exist) but of a \"category with chosen finite products\".\n\nFor a monoidal category axiomatization of finite products, see ThCartesianCategory.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThClosedMonoidalCategory","page":"Standard library of theories","title":"Catlab.Theories.ThClosedMonoidalCategory","text":"Theory of (symmetric) closed monoidal categories\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThCocartesianCategory","page":"Standard library of theories","title":"Catlab.Theories.ThCocartesianCategory","text":"Theory of cocartesian (monoidal) categories\n\nFor the traditional axiomatization of coproducts, see ThCategoryWithCoproducts.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThCocompleteCategory","page":"Standard library of theories","title":"Catlab.Theories.ThCocompleteCategory","text":"Theory of a (finitely) cocomplete category\n\nFinite colimits are presented in biased style, via finite coproducts and coequalizers. The axioms are dual to those of ThCompleteCategory.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThCompactClosedCategory","page":"Standard library of theories","title":"Catlab.Theories.ThCompactClosedCategory","text":"Theory of compact closed categories\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThCompleteCategory","page":"Standard library of theories","title":"Catlab.Theories.ThCompleteCategory","text":"Theory of a (finitely) complete category\n\nFinite limits are presented in biased style, via finite products and equalizers. The equational axioms for equalizers are obscure, but can found in (Lambek & Scott, 1986, Section 0.5), who in turn attribute them to \"Burroni's pioneering ideas\". Strictly speaking, this theory is not of a \"finitely complete category\" (a category in which finite limits exist) but of a \"category with chosen finite limits\".\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThCopresheaf","page":"Standard library of theories","title":"Catlab.Theories.ThCopresheaf","text":"Theory of copresheaves.\n\nAxiomatized as a covariant category action.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThDaggerCategory","page":"Standard library of theories","title":"Catlab.Theories.ThDaggerCategory","text":"Theory of dagger categories\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThDaggerCompactCategory","page":"Standard library of theories","title":"Catlab.Theories.ThDaggerCompactCategory","text":"Theory of dagger compact categories\n\nIn a dagger compact category, there are two kinds of adjoints of a morphism f::Hom(A,B), the adjoint mate mate(f)::Hom(dual(B),dual(A)) and the dagger adjoint dagger(f)::Hom(B,A). In the category of Hilbert spaces, these are respectively the Banach space adjoint and the Hilbert space adjoint (Reed-Simon, Vol I, Sec VI.2). In Julia, they would correspond to transpose and adjoint in the official LinearAlegbra module. For the general relationship between mates and daggers, see Selinger's survey of graphical languages for monoidal categories.\n\nFIXME: This theory should also extend ThDaggerCategory, but multiple inheritance is not yet supported.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThDaggerSymmetricMonoidalCategory","page":"Standard library of theories","title":"Catlab.Theories.ThDaggerSymmetricMonoidalCategory","text":"Theory of dagger symmetric monoidal categories\n\nAlso known as a symmetric monoidal dagger category.\n\nFIXME: This theory should also extend ThDaggerCategory, but multiple inheritance is not yet supported.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThDisplayedCategory","page":"Standard library of theories","title":"Catlab.Theories.ThDisplayedCategory","text":"Theory of a displayed category.\n\nMore precisely, this is the theory of a category C (Ob,Hom) together with a displayed category over C (Fib,FibHom). Displayed categories axiomatize lax functors C  **Span**, or equivalently objects of a slice category **Cat**C, in a generalized algebraic style.\n\nReference: Ahrens & Lumsdaine 2019, \"Displayed categories\", Definition 3.1.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThDistributiveBicategoryRelations","page":"Standard library of theories","title":"Catlab.Theories.ThDistributiveBicategoryRelations","text":"Theory of a distributive bicategory of relations\n\nReferences:\n\nCarboni & Walters, 1987, \"Cartesian bicategories I\", Remark 3.7 (mention in passing only)\nPatterson, 2017, \"Knowledge representation in bicategories of relations\", Section 9.2\n\nFIXME: Should also inherit ThBicategoryOfRelations, but multiple inheritance is not yet supported.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThDistributiveCategory","page":"Standard library of theories","title":"Catlab.Theories.ThDistributiveCategory","text":"Theory of a distributive category\n\nA distributive category is a distributive monoidal category whose tensor product is the cartesian product, see ThDistributiveMonoidalCategory.\n\nFIXME: Should also inherit ThCartesianCategory.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThDistributiveMonoidalCategory","page":"Standard library of theories","title":"Catlab.Theories.ThDistributiveMonoidalCategory","text":"Theory of a distributive (symmetric) monoidal category\n\nReference: Jay, 1992, LFCS tech report LFCS-92-205, \"Tail recursion through universal invariants\", Section 3.2\n\nFIXME: Should also inherit ThCocartesianCategory.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThDistributiveSemiadditiveCategory","page":"Standard library of theories","title":"Catlab.Theories.ThDistributiveSemiadditiveCategory","text":"Theory of a distributive semiadditive category\n\nThis terminology is not standard but the concept occurs frequently. A distributive semiadditive category is a semiadditive category (or biproduct) category, written additively, with a tensor product that distributes over the biproduct.\n\nFIXME: Should also inherit ThSemiadditiveCategory\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThDoubleCategory","page":"Standard library of theories","title":"Catlab.Theories.ThDoubleCategory","text":"Theory of double categories\n\nA strict double category D is an internal category\n\n(ST D₁  D₀ U D₀  D₁ * D₁ _D₀ D₁  D₁)\n\nin Cat where\n\nobjects of D₀ are objects of D\nmorphisms of D₀ are arrows (vertical morphisms) of D\nobjects of D₁ are proarrows (horizontal morphisms) of D\nmorphisms of D₁ are cells of D.\n\nThe domain and codomain (top and bottom) of a cell are given by the domain and codomain in D₁ and the source and target (left and right) are given by the functors ST.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThDoubleCategoryWithTabulators","page":"Standard library of theories","title":"Catlab.Theories.ThDoubleCategoryWithTabulators","text":"Theory of a double category with tabulators\n\nA tabulator of a proarrow is a double-categorical limit. It is a certain cell with identity domain to the given proarrow that is universal among all cells of that form. A double category \"has tabulators\" if the external identity functor has a right adjoint. The values of this right adjoint are the apex objects of its tabulators. The counit of the adjunction provides the universal cells. Tabulators figure in the double-categorical limit construction theorem of Grandis-Pare 1999. In the case where the double category is actually a 2-category, tabulators specialize to cotensors, a more familiar 2-categorical limit.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThEquipment","page":"Standard library of theories","title":"Catlab.Theories.ThEquipment","text":"Theory of a proarrow equipment, or equipment for short\n\nEquipments have also been called \"framed bicategories,\" \"fibrant double categories,\" and \"gregarious double categories\" (?!).\n\nReferences:\n\nShulman, 2008: Framed bicategories and monoidal fibrations\nCruttwell & Shulman, 2010: A unified framework for generalized multicategories\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThGroupoid","page":"Standard library of theories","title":"Catlab.Theories.ThGroupoid","text":"Theory of groupoids.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThHypergraphCategory","page":"Standard library of theories","title":"Catlab.Theories.ThHypergraphCategory","text":"Theory of hypergraph categories\n\nHypergraph categories are also known as \"well-supported compact closed categories\" and \"spidered/dungeon categories\", among other things.\n\nFIXME: Should also inherit ThClosedMonoidalCategory and ThDaggerCategory, but multiple inheritance is not yet supported.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThHypergraphCategoryAdditive","page":"Standard library of theories","title":"Catlab.Theories.ThHypergraphCategoryAdditive","text":"Theory of hypergraph categories, in additive notation\n\nMathematically the same as ThHypergraphCategory but with different notation.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThIndexedCategory","page":"Standard library of theories","title":"Catlab.Theories.ThIndexedCategory","text":"Theory of a (covariantly) indexed category.\n\nAn indexed category is a Cat-valued pseudofunctor. For simplicitly, we assume that the functor is strict.\n\nJust as a copresheaf, or Set-valued functor, can be seen as a category action of a family of sets, an indexed category can be seen as a category action on a family of categories. This picture guides our axiomatization of an indexed category as a generalized algebraic theory.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThIndexedMonoidalCategory","page":"Standard library of theories","title":"Catlab.Theories.ThIndexedMonoidalCategory","text":"Theory of a (covariantly) indexed monoidal category.\n\nAn indexed monoidal category is a pseudofunctor into MonCat, the 2-category of monoidal categories, lax monoidal functor, and monoidal natural transformations. As usual, we take both the pseudofunctor and the monoidal categories to be strict. However, unlike the most common definition of an indexed monoidal category (see nLab), we allow the transition functors between monoidal categories to be lax monoidal. This follows the usage in (Hofstra & De Marchi 2006).\n\nReferences:\n\nHofstra & De Marchi, 2006: Descent for monads\nMoeller & Vasilakopoulou, 2020: Monoidal Grothendieck construction, Remark 3.18 [this paper is about a different notion!]\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThLattice","page":"Standard library of theories","title":"Catlab.Theories.ThLattice","text":"Theory of lattices as posets\n\nA (bounded) lattice is a poset with all finite meets and joins. Viewed as a thin category, this means that the category has all finite products and coproducts, hence the names for the inequality constructors in the theory. Compare with ThCartesianCategory and ThCocartesianCategory.\n\nThis is one of two standard axiomatizations of a lattice, the other being ThAlgebraicLattice.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThMCategory","page":"Standard library of theories","title":"Catlab.Theories.ThMCategory","text":"Theory of an ℳ-category.\n\nThe term \"ℳ-category\", used on the nLab is not very common, but the concept itself shows up commonly. An ℳ-category is a category with a distinguished wide subcategory, whose morphisms are suggestively called tight; for contrast, a generic morphism is called loose. Equivalently, an ℳ-category is a category enriched in the category ℳ of injections, the full subcategory of the arrow category of Set spanned by injections.\n\nIn the following GAT, tightness is axiomatized as a property of morphisms: a dependent family of sets over the hom-sets, each having at most one inhabitant.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThMonoidalCategory","page":"Standard library of theories","title":"Catlab.Theories.ThMonoidalCategory","text":"Theory of monoidal categories\n\nTo avoid associators and unitors, we assume that the monoidal category is strict. By the coherence theorem this involves no loss of generality, but we might add a theory for weak monoidal categories later.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThMonoidalCategoryAdditive","page":"Standard library of theories","title":"Catlab.Theories.ThMonoidalCategoryAdditive","text":"Theory of monoidal categories, in additive notation\n\nMathematically the same as ThMonoidalCategory but with different notation.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThMonoidalCategoryWithBidiagonals","page":"Standard library of theories","title":"Catlab.Theories.ThMonoidalCategoryWithBidiagonals","text":"Theory of monoidal categories with bidiagonals\n\nThe terminology is nonstandard (is there any standard terminology?) but is supposed to mean a monoidal category with coherent diagonals and codiagonals. Unlike in a biproduct category, the naturality axioms need not be satisfied.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThMonoidalCategoryWithBidiagonalsAdditive","page":"Standard library of theories","title":"Catlab.Theories.ThMonoidalCategoryWithBidiagonalsAdditive","text":"Theory of monoidal categories with bidiagonals, in additive notation\n\nMathematically the same as ThMonoidalCategoryWithBidiagonals but written additively, instead of multiplicatively.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThMonoidalCategoryWithCodiagonals","page":"Standard library of theories","title":"Catlab.Theories.ThMonoidalCategoryWithCodiagonals","text":"Theory of monoidal categories with codiagonals\n\nA monoidal category with codiagonals is a symmetric monoidal category equipped with coherent collections of merging and creating morphisms (monoids). Unlike in a cocartesian category, the naturality axioms need not be satisfied.\n\nFor references, see ThMonoidalCategoryWithDiagonals.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThMonoidalCategoryWithDiagonals","page":"Standard library of theories","title":"Catlab.Theories.ThMonoidalCategoryWithDiagonals","text":"Theory of monoidal categories with diagonals\n\nA monoidal category with diagonals is a symmetric monoidal category equipped with coherent operations of copying and deleting, also known as a supply of commutative comonoids. Unlike in a cartesian category, the naturality axioms need not be satisfied.\n\nReferences:\n\nFong & Spivak, 2019, \"Supplying bells and whistles in symmetric monoidal categories\" (arxiv:1908.02633)\nSelinger, 2010, \"A survey of graphical languages for monoidal categories\", Section 6.6: \"Cartesian center\"\nSelinger, 1999, \"Categorical structure of asynchrony\"\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThMonoidalDoubleCategory","page":"Standard library of theories","title":"Catlab.Theories.ThMonoidalDoubleCategory","text":"Theory of monoidal double categories\n\nTo avoid associators and unitors, we assume that the monoidal double category is fully strict: both the double category and its monoidal product are strict. Apart from assuming strictness, this theory agrees with the definition of a monoidal double category in (Shulman 2010) and other recent works.\n\nIn a monoidal double category (DI), the underlying categories D₀ and D₁ are each monoidal categories, (D₀₀I₀) and (D₁₁I₁), subject to further axioms such as the source and target functors S T D₁  D₀ being strict monoidal functors.\n\nDespite the apparent asymmetry in this setup, the definition of a monoidal double category unpacks to be nearly symmetric with respect to arrows and proarrows, except that the monoidal unit I₀ of D₀ induces the monoidal unit of D₁ as I₁ = U(I₀).\n\nReferences:\n\nShulman, 2010: Constructing symmetric monoidal bicategories\n\nFIXME: Should also inherit ThMonoidalCategory{Ob,Hom} but multiple inheritance is not supported.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThPoset","page":"Standard library of theories","title":"Catlab.Theories.ThPoset","text":"Theory of partial orders (posets)\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThPreorder","page":"Standard library of theories","title":"Catlab.Theories.ThPreorder","text":"Theory of preorders\n\nThe generalized algebraic theory of preorders encodes inequalities AB as dependent types `Leq(AB) and the axioms of reflexivity and transitivity as term constructors.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThPresheaf","page":"Standard library of theories","title":"Catlab.Theories.ThPresheaf","text":"Theory of presheaves.\n\nAxiomatized as a contravariant category action.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThRigCategory","page":"Standard library of theories","title":"Catlab.Theories.ThRigCategory","text":"Theory of a rig category, also known as a bimonoidal category\n\nRig categories are the most general in the hierarchy of distributive monoidal structures.\n\nQuestion: Do we also want the distributivty and absorption isomorphisms? Usually we ignore coherence isomorphisms such as associators and unitors.\n\nFIXME: This theory should also inherit ThMonoidalCategory, but multiple inheritance is not supported.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThSchema","page":"Standard library of theories","title":"Catlab.Theories.ThSchema","text":"The GAT that parameterizes Attributed C-sets A schema is comprised of a category C, a discrete category D, and a profunctor Attr : C^op x D → Set. In GAT form, this is given by extending the theory of categories with two extra types, AttrType for objects of D, and Attr, for elements of the sets given by the profunctor.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThSemiadditiveCategory","page":"Standard library of theories","title":"Catlab.Theories.ThSemiadditiveCategory","text":"Theory of semiadditive categories\n\nMathematically the same as ThBiproductCategory but written additively, instead of multiplicatively.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThSymmetricMonoidalCategory","page":"Standard library of theories","title":"Catlab.Theories.ThSymmetricMonoidalCategory","text":"Theory of (strict) symmetric monoidal categories\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThSymmetricMonoidalCategoryAdditive","page":"Standard library of theories","title":"Catlab.Theories.ThSymmetricMonoidalCategoryAdditive","text":"Theory of symmetric monoidal categories, in additive notation\n\nMathematically the same as ThSymmetricMonoidalCategory but with different notation.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThSymmetricMonoidalCopresheaf","page":"Standard library of theories","title":"Catlab.Theories.ThSymmetricMonoidalCopresheaf","text":"Theory of a symmetric monoidal copresheaf\n\nThe name is not standard but refers to a lax symmetric monoidal functor into Set. This can be interpreted as an action of a symmetric monoidal category, just as a copresheaf (set-valued functor) is an action of a category. The theory is simpler than that of a general lax monoidal functor because (1) the domain is a strict monoidal category and (2) the codomain is fixed to the cartesian monoidal category Set.\n\nFIXME: This theory should also extend ThCopresheaf but multiple inheritance is not yet supported.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThSymmetricMonoidalDoubleCategory","page":"Standard library of theories","title":"Catlab.Theories.ThSymmetricMonoidalDoubleCategory","text":"Theory of symmetric monoidal double categories\n\nUnlike the classical notion of strict double categories, symmetric monoidal double categories do not treat the two directions on an equal footing, even when everything (except the braiding) is strict. See ThMonoidalDoubleCategory for references.\n\nFIXME: Should also inherit ThSymmetricMonoidalCategory{Ob,Hom} but multiple inheritance is not supported.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThSymmetricRigCategory","page":"Standard library of theories","title":"Catlab.Theories.ThSymmetricRigCategory","text":"Theory of a symmetric rig category\n\nFIXME: Should also inherit ThSymmetricMonoidalCategory.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThThinCategory","page":"Standard library of theories","title":"Catlab.Theories.ThThinCategory","text":"Theory of thin categories\n\nThin categories have at most one morphism between any two objects and are isomorphic to preorders.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThThinSymmetricMonoidalCategory","page":"Standard library of theories","title":"Catlab.Theories.ThThinSymmetricMonoidalCategory","text":"Theory of thin symmetric monoidal category\n\nThin SMCs are isomorphic to commutative monoidal prosets.\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Catlab.Theories.ThTracedMonoidalCategory","page":"Standard library of theories","title":"Catlab.Theories.ThTracedMonoidalCategory","text":"Theory of traced monoidal categories\n\n\n\n\n\n","category":"type"},{"location":"apis/theories/#Base.collect-Tuple{ObExpr}","page":"Standard library of theories","title":"Base.collect","text":"Collect generators of object in monoidal category as a vector.\n\n\n\n\n\n","category":"method"},{"location":"apis/theories/#Base.ndims-Tuple{ObExpr}","page":"Standard library of theories","title":"Base.ndims","text":"Number of \"dimensions\" of object in monoidal category.\n\n\n\n\n\n","category":"method"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"EditURL = \"../../../literate/graphics/graphviz_wiring_diagrams.jl\"","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Drawing-wiring-diagrams-in-Graphviz","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"(Image: )","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"Catlab can draw wiring diagrams using Graphviz. Directed wiring diagrams are drawn using the dot program and undirected wiring diagrams using neato and fdp. This feature requires that Graphviz be installed, but does not require any additional Julia packages.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"using Catlab.WiringDiagrams, Catlab.Graphics","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Directed-wiring-diagrams","page":"Drawing wiring diagrams in Graphviz","title":"Directed wiring diagrams","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Symmetric-monoidal-category","page":"Drawing wiring diagrams in Graphviz","title":"Symmetric monoidal category","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"using Catlab.Theories\n\nA, B = Ob(FreeSymmetricMonoidalCategory, :A, :B)\nf = Hom(:f, A, B)\ng = Hom(:g, B, A)\nh = Hom(:h, otimes(A,B), otimes(A,B));\nnothing #hide","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"To start, here are a few very simple examples.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"to_graphviz(f)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"to_graphviz(compose(f,g))","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"to_graphviz(otimes(f,g))","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"In the next example, notice how Graphviz automatically \"untwists\" the double braiding to minimize edge crossings.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"to_graphviz(compose(braid(A,A), otimes(f,f), braid(B,B)))","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"Here is a larger composite morphism.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"composite = compose(otimes(g,f), h, otimes(f,g))\nto_graphviz(composite)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"By default, the wiring diagram is laid out from top to bottom. Other layout orientations can be requested, such as left-to-right or bottom-to-top:","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"to_graphviz(composite, orientation=LeftToRight)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"to_graphviz(composite, orientation=BottomToTop)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"When working with very large diagrams (larger than the ones shown here), it is sometimes convenient to omit the ports of the outer box and any wires attached to them.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"to_graphviz(composite, outer_ports=false)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Biproduct-category","page":"Drawing wiring diagrams in Graphviz","title":"Biproduct category","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"A, B = Ob(FreeBiproductCategory, :A, :B)\nf = Hom(:f, A, B)\ng = Hom(:g, B, A);\nnothing #hide","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"By default, copies and merges are drawn the way they are represented internally, as multiple wires.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"f1 = compose(mcopy(A), otimes(f,f))\nto_graphviz(f1)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"f2 = compose(mcopy(A), otimes(f,f), mmerge(B))\nto_graphviz(f2)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"To draw nodes for copies and merges, we need to add junctions to the wiring diagram.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"to_graphviz(add_junctions!(to_wiring_diagram(f1)))","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"to_graphviz(add_junctions!(to_wiring_diagram(f2)))","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Traced-monoidal-category","page":"Drawing wiring diagrams in Graphviz","title":"Traced monoidal category","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"A, B, X, Y = Ob(FreeTracedMonoidalCategory, :A, :B, :X, :Y)\nf = Hom(:f, otimes(X,A), otimes(X,B))\n\nto_graphviz(trace(X, A, B, f))","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"to_graphviz(trace(X, A, B, f), orientation=LeftToRight)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"g, h = Hom(:g, A, A), Hom(:h, B, B)\n\ntrace_naturality = trace(X, A, B, compose(otimes(id(X),g), f, otimes(id(X),h)))\nto_graphviz(trace_naturality, orientation=LeftToRight)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Undirected-wiring-diagrams","page":"Drawing wiring diagrams in Graphviz","title":"Undirected wiring diagrams","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"The composite of two binary relations:","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"using Catlab.Programs: @relation\n\ndiagram = @relation (x,z) where (x,y,z) begin\n    R(x,y)\n    S(y,z)\nend\nto_graphviz(diagram, box_labels=:name)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"A \"wheel\"-shaped composition of relations:","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"diagram = @relation (x,y,z) where (w,x,y,z) begin\n    R(x,w)\n    S(y,w)\n    T(z,w)\nend\nto_graphviz(diagram, box_labels=:name)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"As these examples show, the box_labels keyword argument specifies the data attribute of boxes to use for box labels, if any. The boolean argument port_labels controls the labeling of ports by numerical values and the argument junction_labels specifies the data attribute of junctions to use for junction labels. Note that the macro @relation creates wiring diagrams with name attribute for boxes and variable attribute for junctions.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"to_graphviz(diagram, box_labels=:name,\n            port_labels=false, junction_labels=:variable)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"By default, all junctions are shown. The keyword argument implicit_junctions omits any junctions which have exactly two incident ports.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"to_graphviz(diagram, box_labels=:name,\n            port_labels=false, implicit_junctions=true)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Custom-styles","page":"Drawing wiring diagrams in Graphviz","title":"Custom styles","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"The visual appearance of wiring diagrams can be customized by setting Graphviz attributes at the graph, node, edge, and cell levels. Graph, node, and edge attributes are described in the Graphviz documentation. Cell attributes are passed to the primary cell of the HTML-like label used for the boxes.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"A, B, C = Ob(FreeSymmetricMonoidalCategory, :A, :B, :C)\nf, g = Hom(:f, A, B), Hom(:g, B, C)\n\nto_graphviz(compose(f,g),\n  labels = true, label_attr=:headlabel,\n  node_attrs = Dict(\n    :fontname => \"Courier\",\n  ),\n  edge_attrs = Dict(\n    :fontname => \"Courier\",\n    :labelangle => \"25\",\n    :labeldistance => \"2\",\n  ),\n  cell_attrs = Dict(\n    :bgcolor => \"lavender\",\n  )\n)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Output-formats","page":"Drawing wiring diagrams in Graphviz","title":"Output formats","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"The function to_graphviz returns an object of a type Graphviz.Graph, representing a Graphviz graph as an abstract syntax tree. When displayed interactively, this object is automatically run through Graphviz and rendered as an SVG image. Sometimes it is convenient to perform this process manually, to change the output format or further customize the generated dot file.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"To generate a dot file, use the builtin pretty-printer. This feature does not require Graphviz to be installed.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"using Catlab.Graphics: Graphviz\n\ngraph = to_graphviz(compose(f,g))\nGraphviz.pprint(graph)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"Catlab provides a simple wrapper around the Graphviz command-line programs. For example, here is the JSON output for the graph.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/","page":"Drawing wiring diagrams in Graphviz","title":"Drawing wiring diagrams in Graphviz","text":"import JSON\n\nJSON.parse(Graphviz.run_graphviz(graph, format=\"json0\"))","category":"page"},{"location":"devdocs/style/#Style-Guide-for-AlgebraicJulia","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"","category":"section"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"The purpose of this document is to have a consistent style across AlgebraicJulia, for interests of maintainability and professionalism.","category":"page"},{"location":"devdocs/style/#Folder-structure","page":"Style Guide for AlgebraicJulia","title":"Folder structure","text":"","category":"section"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"We follow the Julia project folder structure, where the most important elements are","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"A Project.toml file, describing dependencies and metadata.\nA src directory. Most functionality should be implemented in this directory.\nA test directory. Functionality implemented in src should be tested here.\nA README.md. This should describe the purpose of the project.","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Additional directories one might also use","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"A notebooks directory for explanatory notebooks.\nA docs directory with Documenter.jl-generated docs.\nA scripts directory with executable scripts. Note: these scripts should not contain many functions or types, they should be thin wrappers around functions from src. It is acceptable to develop some functionality in a script if that functionality is eventually migrated into src.","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"For most repositories in AlgebraicJulia, this should describe the top-level structure. However, some repositories might be multi-project. In that case, there is a top-level directory consisting of project directories, some of which may depend on each other.","category":"page"},{"location":"devdocs/style/#Naming-conventions","page":"Style Guide for AlgebraicJulia","title":"Naming conventions","text":"","category":"section"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"There are two ways of joining words together without spaces that are in use across AlgebraicJulia.","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"UpperCamelCase, in which each word is capitalized, and then joined together without a separating character.\nlower_snake_case, in which each word is lowercase, and then joined together with underscores. The use of uppercase acronyms in lower_snake_case is tolerable but discouraged.","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Occasionally, it is also acceptable to join lowercase words together without underscores, e.g., setindex! instead of set_index!; judgement about readability and consistency should be used when making the decision to use underscores or not.","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Here are some example of names that are not consistent with the AlgebraicJulia style.","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"camelCase\nUpperCamel_and_snake\nDashed-name","category":"page"},{"location":"devdocs/style/#Projects","page":"Style Guide for AlgebraicJulia","title":"Projects","text":"","category":"section"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Projects should be named using UpperCamelCase with a .jl suffix, e.g. AlgebraicPetri.jl or Semagrams.jl.","category":"page"},{"location":"devdocs/style/#Files-and-directories","page":"Style Guide for AlgebraicJulia","title":"Files and directories","text":"","category":"section"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Directories should all be lower_snake_case, except for top-level directories that are named after projects.","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Library julia files and test julia files should be named with UpperCamelCase. Scripts and notebooks should be lower_snake_case.","category":"page"},{"location":"devdocs/style/#Julia-values","page":"Style Guide for AlgebraicJulia","title":"Julia values","text":"","category":"section"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Modules and types should always be UpperCamelCase. Functions should always be lower_snake_case, and ideally single words. Constants should be lower_snake_case, or occasionally SCREAMING_SNAKE_CASE (judgement should be exercised about use of SCREAMING_SNAKE_CASE). Fields of structs should be lower_snake_case, or ideally lowercase single words.","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Arguments to functions should have short names, often just single letters. If your function is so specific that the arguments need to be described with long argument names, consider generalizing your function. If arguments need to be longer, then lower_snake_case should be used. Additionally, you can use types and comments to document what a variable is for instead of making the names long. Some examples:","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"f(a_natural_number) # BAD\nf(n::Nat) # GOOD\nf(graph, vector_of_weights) # BAD\nf(g::AbstractGraph, v::AbstractVector) # GOOD","category":"page"},{"location":"devdocs/style/#General-style-tips","page":"Style Guide for AlgebraicJulia","title":"General style tips","text":"","category":"section"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"See the official Julia style guide for general guidelines but note the following additions and exceptions:","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Indent width is 2 spaces. For VSCode, go to settings and set Editor: Tab Size to 2.\nTry to avoid lines longer than 80 characters. Occasionally it may be convenient to go over slightly, but never do so egregiously. To hard wrap docstrings in VSCode, the extension Rewrap adds the keybinding Alt+Q (as in Emacs).\nIntroduce a new struct when many (≥3) functions have overlapping arguments that are common aspects of a shared concept\nCatlab uses modules more often than most Julia packages. While this may be idiosyncratic, it helps keep different components of Catlab isolated, which will be useful in the future when we spin out modules as their own packages.\nPrefer accessor and mutator functions (e.g. dom(f)) over direct manipulation of struct fields or keys (e.g. f.dom), especially when the functions already exist. This convention supports writing generic code and makes it easier to change data structure internals without breaking existing code.\nIn long files, using comment headers can improve readability and navigability. Top-level headers and sub-headers should be formatted as:","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"# Section\n#########\n\n# Subsection\n#-----------","category":"page"},{"location":"devdocs/style/#Guidelines-for-pull-requests","page":"Style Guide for AlgebraicJulia","title":"Guidelines for pull requests","text":"","category":"section"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Every pull request to Catlab should be reviewed by at least one person. Following are some things to check when making a PR yourself or reviewing someone else's PR. The goal of this list is to ensure that the Catlab codebase is robust and maintainable. When any of these guidelines are violated, it should be documented in a comment on the PR page.","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Note: This list only includes the mechanical things. When a reviewing a PR you should always use your own judgment in asking questions and making comments about API and algorithm design. That's the hard part!","category":"page"},{"location":"devdocs/style/#Tests-and-code-coverage","page":"Style Guide for AlgebraicJulia","title":"Tests and code coverage","text":"","category":"section"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Enhancements (new features) must have accompanying unit tests\nBug fixes should come with unit tests exposing the bug, unless producing a minimal example is unusually difficult\nDo not delete existing unit tests, unless you have a very good reason (e.g., the relevant functionality is being moved to another package), which is documented in the PR\nIf you are adding a new module, make sure to add the test module to the test runner (test/runtests.jl or file included therein)\nCode coverage on the Catlab repo exceeds 90% and we try to keep it that way. We do not insist on 100% coverage, which is impractical, nor do we set a hard threshold applicable to all PRs, but generally you should aim for 90%+ code coverage. Any reductions in test coverage should be justified in the PR.","category":"page"},{"location":"devdocs/style/#Documentation","page":"Style Guide for AlgebraicJulia","title":"Documentation","text":"","category":"section"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"All exported functions, types, and constants must have docstrings\nDocstrings should be written in complete sentences, with correct capitalization and punctuation. Likewise for comments, except for fragmentary end-of-line comments.\nWhere possible, provide citations for constructions and algorithms that you implement. This reflects good scholarly values and also aids the understanding of your code by other people.","category":"page"},{"location":"devdocs/style/#Version-control","page":"Style Guide for AlgebraicJulia","title":"Version control","text":"","category":"section"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Commit messages should be informative and be written in complete sentences\nAvoid one-word commit messages like \"fix\" or \"bug\". If you need to make very simple fixes on your branch, amend a previous commit and force push.\nAvoid repeatedly merging the main branch back into your PR branch. Instead, rebase off main and force push.","category":"page"},{"location":"devdocs/style/#Backwards-compatibility","page":"Style Guide for AlgebraicJulia","title":"Backwards compatibility","text":"","category":"section"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Reflecting Catlab's dual status as a research project and a user-facing library, we want to give ourselves space to experiment while also not annoying our users and each other by needlessly breaking things.","category":"page"},{"location":"devdocs/style/","page":"Style Guide for AlgebraicJulia","title":"Style Guide for AlgebraicJulia","text":"Like other Julia packages, Catlab aims to follow semantic versioning\nAll else equal, it is better to make breaking changes to new APIs, especially very new ones, than old APIs\nIf you plan to make major breaking changes, please coordinate with the senior developers to ensure that it makes senses and aligns with the release schedule","category":"page"},{"location":"apis/graphics/#graphics","page":"Graphics","title":"Graphics","text":"","category":"section"},{"location":"apis/graphics/","page":"Graphics","title":"Graphics","text":"Modules = [\n  Graphics.GraphvizGraphs,\n  Graphics.ComposeWiringDiagrams,\n  Graphics.GraphvizWiringDiagrams,\n  Graphics.TikZWiringDiagrams,\n  Graphics.WiringDiagramLayouts,\n]\nPrivate = false","category":"page"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizGraphs","page":"Graphics","title":"Catlab.Graphics.GraphvizGraphs","text":"Graphviz support for Catlab's graph types.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizGraphs.parse_graphviz-Tuple{AbstractDict}","page":"Graphics","title":"Catlab.Graphics.GraphvizGraphs.parse_graphviz","text":"Parse Graphviz output in JSON format.\n\nReturns a property graph with graph layout and other metadata. Each node has a position and size.\n\nAll units are in points. Note that Graphviz has 72 points per inch.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizGraphs.to_graphviz-Tuple{AbstractPropertyGraph}","page":"Graphics","title":"Catlab.Graphics.GraphvizGraphs.to_graphviz","text":"Convert a property graph to a Graphviz graph.\n\nThis method is usually more convenient than direct AST manipulation for creating simple Graphviz graphs. For more advanced features, like nested subgraphs, you must use the Graphviz AST.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizGraphs.to_graphviz-Tuple{AbstractUndirectedBipartiteGraph}","page":"Graphics","title":"Catlab.Graphics.GraphvizGraphs.to_graphviz","text":"Visualize a bipartite graph using Graphviz.\n\nWorks for both directed and undirected bipartite graphs. Both types of vertices in the bipartite graph become nodes in the Graphviz graph.\n\nArguments\n\nprog=\"dot\": Graphviz program to use\ngraph_attrs: Graph-level Graphviz attributes\nnode_attrs: Node-level Graphviz attributes\nedge_attrs: Edge-level Graphviz attributes\nnode_labels=false: whether to label nodes and if so, which pair of data attributes to use\nedge_labels=false: whether to label edges and if so, which data attribute (undirected case) or pair of attributes (directed case) to use\ninvis_edge=true: whether to add invisible edges between vertices of same type, which ensures that the order of the nodes is preserved.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizGraphs.to_graphviz-Tuple{HasGraph}","page":"Graphics","title":"Catlab.Graphics.GraphvizGraphs.to_graphviz","text":"Convert a graph to a Graphviz graph.\n\nA simple default style is applied. For more control over the visual appearance, first convert the graph to a property graph, define the Graphviz attributes as needed, and finally convert the property graph to a Graphviz graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizGraphs.to_graphviz-Union{Tuple{StructACSetTransformation{S, Comp, <:AbstractGraph, <:AbstractGraph}}, Tuple{Comp}, Tuple{S}} where {S, Comp}","page":"Graphics","title":"Catlab.Graphics.GraphvizGraphs.to_graphviz","text":"Visualize a graph homomorphism using Graphviz.\n\nVisualize a homomorphism (ACSetTransformation) between two graphs (instances of AbstractGraph). By default, the domain and codomain are drawn as subgraphs and the vertex mapping is drawn using dotted edges, whereas the edge map is suppressed. The vertex and edge mapping can also be shown using colors, via the node_colors and edge_colors keyword arguments.\n\nArguments\n\ndraw_codom=true: whether to draw the codomain graph\ndraw_mapping=true: whether to draw the vertex mapping using edges\nprog=\"dot\": Graphviz program to use\ngraph_attrs: Graph-level Graphviz attributes\nnode_attrs: Node-level Graphviz attributes\nedge_attrs: Edge-level Graphviz attributes\nnode_labels=false: whether to draw node labels and which vertex attribute to use\nedge_labels=false: whether to draw edge labels and which edge attribute to use\nnode_colors=!draw_codom: whether and how to color nodes based on vertex map\nedge_colors=!draw_codom: whether and how to color edges based on edge map\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizGraphs.to_graphviz_property_graph-Tuple{AbstractGraph}","page":"Graphics","title":"Catlab.Graphics.GraphvizGraphs.to_graphviz_property_graph","text":"Convert graph or other structure to a property graph suitable for Graphviz.\n\nThis function is an intermediate step in many methods of the generic function to_graphviz, but can be useful in its own right for customizing the Graphviz graph beyond whatever options are supported by to_graphviz.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.ComposeWiringDiagrams","page":"Graphics","title":"Catlab.Graphics.ComposeWiringDiagrams","text":"Draw wiring diagrams using Compose.jl.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.ComposeWiringDiagrams.ComposePicture","page":"Graphics","title":"Catlab.Graphics.ComposeWiringDiagrams.ComposePicture","text":"A Compose context together with a given width and height.\n\nWe need this type because contexts have no notion of size or aspect ratio, but wiring diagram layouts have fixed aspect ratios.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphics/#Catlab.Graphics.ComposeWiringDiagrams.layout_to_composejl-Tuple{WiringDiagram}","page":"Graphics","title":"Catlab.Graphics.ComposeWiringDiagrams.layout_to_composejl","text":"Draw a wiring diagram in Compose.jl using the given layout.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.ComposeWiringDiagrams.to_composejl-Tuple","page":"Graphics","title":"Catlab.Graphics.ComposeWiringDiagrams.to_composejl","text":"Draw a wiring diagram in Compose.jl.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizWiringDiagrams","page":"Graphics","title":"Catlab.Graphics.GraphvizWiringDiagrams","text":"Lay out and draw wiring diagrams using Graphviz.\n\nThis module requires Graphviz v2.42 or higher.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizGraphs.to_graphviz-Tuple{AbstractUWD}","page":"Graphics","title":"Catlab.Graphics.GraphvizGraphs.to_graphviz","text":"Draw an undirected wiring diagram using Graphviz.\n\nCreates an undirected, bipartite Graphviz graph, with the boxes and outer ports of the diagram becoming nodes of one kind and the junctions of the diagram becoming nodes of the second kind.\n\nArguments\n\ngraph_name=\"G\": name of Graphviz graph\nprog=\"neato\": Graphviz program, usually \"neato\" or \"fdp\"\nbox_labels=false: if boolean, whether to label boxes with their number;  if a symbol, name of data attribute for box label\nport_labels=false: whether to label ports with their number\njunction_labels=false: if boolean, whether to label junctions with their number; if a symbol, name of data attribute for junction label\njunction_size=\"0.075\": size of junction nodes, in inches\nimplicit_junctions=false: whether to represent a junction implicity as a wire when it has exactly two incident ports\ngraph_attrs=Dict(): top-level graph attributes\nnode_attrs=Dict(): top-level node attributes\nedge_attrs=Dict(): top-level edge attributes\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizGraphs.to_graphviz-Tuple{CPortGraph}","page":"Graphics","title":"Catlab.Graphics.GraphvizGraphs.to_graphviz","text":"Draw a circular port graph using Graphviz.\n\nCreates a Graphviz graph. Ports are currently not respected in the image, but the port index for each box can be displayed to provide clarification.\n\nArguments\n\ngraph_name=\"G\": name of Graphviz graph\nprog=\"neato\": Graphviz program, usually \"neato\" or \"fdp\"\nbox_labels=false: whether to label boxes with their number\nport_labels=false: whether to label ports with their number\ngraph_attrs=Dict(): top-level graph attributes\nnode_attrs=Dict(): top-level node attributes\nedge_attrs=Dict(): top-level edge attributes\n\nTODO: The lack of ports might be able to be resolved by introducing an extra node per port which is connected to its box with an edge of length 0.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizGraphs.to_graphviz-Tuple{WiringDiagram}","page":"Graphics","title":"Catlab.Graphics.GraphvizGraphs.to_graphviz","text":"Draw a wiring diagram using Graphviz.\n\nThe input can also be a morphism expression, in which case it is first converted into a wiring diagram. This function requires Graphviz v2.42 or higher.\n\nArguments\n\ngraph_name=\"G\": name of Graphviz digraph\norientation=TopToBottom: orientation of layout. One of LeftToRight, RightToLeft, TopToBottom, or BottomToTop.\nnode_labels=true: whether to label the nodes\nlabels=false: whether to label the edges\nlabel_attr=:label: what kind of edge label to use (if labels is true). One of :label, :xlabel, :headlabel, or :taillabel.\nport_size=\"24\": minimum size of ports on box, in points\njunction_size=\"0.05\": size of junction nodes, in inches\nouter_ports=true: whether to display the outer box's input and output ports. If disabled, no incoming or outgoing wires will be shown either!\nanchor_outer_ports=true: whether to enforce ordering of the outer box's input and output, i.e., ordering of the incoming and outgoing wires\ngraph_attrs=Dict(): top-level graph attributes\nnode_attrs=Dict(): top-level node attributes\nedge_attrs=Dict(): top-level edge attributes\ncell_attrs=Dict(): main cell attributes in node HTML-like label\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizWiringDiagrams.graphviz_layout-Tuple{WiringDiagram}","page":"Graphics","title":"Catlab.Graphics.GraphvizWiringDiagrams.graphviz_layout","text":"Lay out directed wiring diagram using Graphviz.\n\nNote: At this time, only the positions and sizes of the boxes, and the positions of the outer ports, are used. The positions of the box ports and the splines for the wires are ignored.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams","page":"Graphics","title":"Catlab.Graphics.TikZWiringDiagrams","text":"Draw wiring diagrams using TikZ.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.layout_to_tikz-Tuple{WiringDiagram}","page":"Graphics","title":"Catlab.Graphics.TikZWiringDiagrams.layout_to_tikz","text":"Draw a wiring diagram in TikZ using the given layout.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.to_tikz-Tuple","page":"Graphics","title":"Catlab.Graphics.TikZWiringDiagrams.to_tikz","text":"Draw a wiring diagram in TikZ.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.WiringDiagramLayouts","page":"Graphics","title":"Catlab.Graphics.WiringDiagramLayouts","text":"Backend-agnostic layout of wiring diagrams via morphism expressions.\n\nThis module lays out wiring diagrams for visualization, independent of any specific graphics system. It uses the structure of a morphism expression to determine the layout. Thus, the first step of the algorithm is to convert the wiring diagram to a symbolic expression, using the submodule WiringDiagrams.Expressions. Morphism expressions may also be given directly.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.WiringDiagramLayouts.LayoutOrientation","page":"Graphics","title":"Catlab.Graphics.WiringDiagramLayouts.LayoutOrientation","text":"Orientation of wiring diagram.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphics/#Catlab.Graphics.WiringDiagramLayouts.layout_box-Tuple{Vector, Vector, Catlab.Graphics.WiringDiagramLayouts.LayoutOptions}","page":"Graphics","title":"Catlab.Graphics.WiringDiagramLayouts.layout_box","text":"Lay out a box and its ports.\n\nBy default the box is rectangular, but other shapes are also supported.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.WiringDiagramLayouts.layout_diagram-Tuple{Module, WiringDiagram}","page":"Graphics","title":"Catlab.Graphics.WiringDiagramLayouts.layout_diagram","text":"Lay out a wiring diagram or morphism expression for visualization.\n\nIf a wiring diagram is given, it is first to converted to a morphism expression.\n\nThe layout is calculated with respect to a cartesian coordinate system with origin at the center of the diagram and the positive y-axis pointing downwards. Box positions are relative to their centers. All positions and sizes are dimensionless (unitless).\n\n\n\n\n\n","category":"method"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"EditURL = \"../../../literate/graphs/subgraphs.jl\"","category":"page"},{"location":"generated/graphs/subgraphs/#Algebra-of-subgraphs","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"","category":"section"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"(Image: )","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"using Catlab.Graphs, Catlab.Graphics\nusing Catlab.Theories, Catlab.CategoricalAlgebra","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"A subgraph of a graph G is a monomorphism A rightarrowtail G. Because the category of graphs is a presheaf topos, its subobjects have a rich algebraic structure, which we will explore in this vignette.","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"Throughout the vignette, we will work with subgraphs of the following graph.","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"G = cycle_graph(Graph, 4) ⊕ path_graph(Graph, 2) ⊕ cycle_graph(Graph, 1)\nadd_edge!(G, 3, add_vertex!(G))\n\nto_graphviz(G, node_labels=true, edge_labels=true)","category":"page"},{"location":"generated/graphs/subgraphs/#Meet-and-join","page":"Algebra of subgraphs","title":"Meet and join","text":"","category":"section"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"The basic operations of meet or intersection (wedge), join or union (vee), top or maximum (top), bottom or minimum (bot) are all computed pointwise: separately on vertices and edges.","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"Consider the following two subgraphs.","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"(A = Subobject(G, V=1:4, E=[1,2,4])) |> to_graphviz","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"(B = Subobject(G, V=[2,3,4,7,8], E=[2,3,6,7])) |> to_graphviz","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"The join is defined as left adjoint to the diagonal, making it the least upper bound:","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"A vee B leq C qquadtextiffqquad A leq C text and  B leq C","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"A ∨ B |> to_graphviz","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"Dually, the meet is defined as right adjoint to the diagonal, making it the greatest lower bound:","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"C leq A text and  C leq B qquadtextiffqquad C leq A wedge B","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"A ∧ B |> to_graphviz","category":"page"},{"location":"generated/graphs/subgraphs/#Implication-and-negation","page":"Algebra of subgraphs","title":"Implication and negation","text":"","category":"section"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"The other operations, beginning with implication (Rightarrow) and negation (neg) are more interesting because they do not have pointwise formulas.","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"Implication is defined as the right adjoint to the meet:","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"C wedge A leq B qquadtextiffqquad C leq A Rightarrow B","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"(A ⟹ B) |> to_graphviz","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"Negation is defined by setting B = bot in the above formula:","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"C wedge A = bot qquadtextiffqquad C leq neg A","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"¬A |> to_graphviz","category":"page"},{"location":"generated/graphs/subgraphs/#Induced-subgraph-as-a-double-negation","page":"Algebra of subgraphs","title":"Induced subgraph as a double negation","text":"","category":"section"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"The logic of subgraphs, and of subobjects in presheaf toposes generally, is not classical. Specifically, subobjects form a Heyting algebra but not a Boolean algebra. This means that the law of excluded middle does not hold: in general, neg neg A neq A.","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"Applying the double negation to a discrete subgraph gives the subgraph induced by those vertices.","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"(C = Subobject(G, V=1:4)) |> to_graphviz","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"¬(¬C) |> to_graphviz","category":"page"},{"location":"generated/graphs/subgraphs/#Subtraction-and-non","page":"Algebra of subgraphs","title":"Subtraction and non","text":"","category":"section"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"The subojects also form co-Heyting algebra and hence a bi-Heyting algebra.","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"Subtraction is defined dually to implication as the left adjoint to the join:","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"A leq B vee C qquadtextiffqquad A setminus B leq C","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"(A \\ B) |> to_graphviz","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"Non is defined by setting A = top in the above formula:","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"top = B vee C qquadtextiffqquad sim B leq C","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"~A |> to_graphviz","category":"page"},{"location":"generated/graphs/subgraphs/#Boundary-via-non","page":"Algebra of subgraphs","title":"Boundary via non","text":"","category":"section"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"A boundary operator can be defined using the non operator:","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"partial A = A wedge sim A","category":"page"},{"location":"generated/graphs/subgraphs/","page":"Algebra of subgraphs","title":"Algebra of subgraphs","text":"(A ∧ ~A) |> to_graphviz","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"EditURL = \"../../../literate/wiring_diagrams/diagrams_and_expressions.jl\"","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#Wiring-diagrams-and-syntactic-expressions","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"","category":"section"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"(Image: )","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"Morphisms in a monoidal category can be represented as syntactic expressions, such as f cdot g and f otimes g, and also as wiring diagrams, aka string diagrams. Catlab provides facilities for transforming between these two representations.","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"using Catlab.Theories, Catlab.WiringDiagrams\nusing Catlab.Graphics\n\nfunction show_diagram(d::WiringDiagram)\n  to_graphviz(d, orientation=LeftToRight, labels=false)\nend","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#Expressions-to-diagrams","page":"Wiring diagrams and syntactic expressions","title":"Expressions to diagrams","text":"","category":"section"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"Converting a morphism expression to a wiring diagram is conceptually and algorithmically simple, because every expression determines a unique diagram.","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"As a simple example, here is the monoidal product of two generators, f and g, first as an expression (displayed using LaTeX) and then as a wiring diagram (displayed using Graphviz).","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"A, B, C, D, E = Ob(FreeCartesianCategory, :A, :B, :C, :D, :E)\nf = Hom(:f, A, B)\ng = Hom(:g, B, C)\n\nexpr = f ⊗ g","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"show_diagram(to_wiring_diagram(expr))","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"Here is a monoidal product of compositions:","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"h = Hom(:h, C, D)\nk = Hom(:k, D, E)\n\nexpr = (f ⋅ g) ⊗ (h ⋅ k)","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"show_diagram(to_wiring_diagram(expr))","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#Diagrams-to-expressions","page":"Wiring diagrams and syntactic expressions","title":"Diagrams to expressions","text":"","category":"section"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"Converting a wiring diagram to a syntactic expression is algorithmically more challenging, due to the fact that a single wiring diagram generally admits many different representations as an expression. Thus, a particular expression must be singled out.","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"To bring this out, we define a function that round-trips a morphism expression to a wiring diagram and then back to an expression.","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"function roundtrip_expr(expr::FreeCartesianCategory.Hom)\n  d = to_wiring_diagram(expr)\n  to_hom_expr(FreeCartesianCategory, d)\nend","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"We can recover the expression just considered above:","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"roundtrip_expr((f ⋅ g) ⊗ (h ⋅ k))","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"But here is a different expression that round-trips to the same thing:","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"roundtrip_expr((f ⊗ h) ⋅ (g ⊗ k))","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"The equality of these two expressions,","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"(f cdot g) otimes (h cdot k) = (f otimes h) cdot (g otimes k)","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"is the interchange law in a monoidal category. It says that composition and monoidal products can be interchanged. As this example shows, the conversion algorithm in Catlab favors products over composition, placing products towards the root of the expression tree wherever possible. Other laws can be discovered by this procedure. Since we are working in a cartesian monoidal category, operations of copying, Delta_A A to A otimes A, and deleting, lozenge_A A to I, are available.","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"Consider the operation of copying the product A otimes B.","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"expr = mcopy(A ⊗ B)","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"show_diagram(add_junctions!(to_wiring_diagram(expr)))","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"roundtrip_expr(expr)","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"The equation just witnessed,","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"Delta_A otimes B = (Delta_A otimes Delta_B) cdot (1_A otimes sigma_AB otimes 1_B)","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"is one of the coherence laws for cartesian products (arXiv:0908.3347, Table 7). Another coherence law for products is","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"lozenge_A otimes B = lozenge_A otimes lozenge_B","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"expr = delete(A ⊗ B)","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"roundtrip_expr(expr)","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"EditURL = \"../../../literate/sketches/cat_elements.jl\"","category":"page"},{"location":"generated/sketches/cat_elements/#The-Category-of-Elements","page":"The Category of Elements","title":"The Category of Elements","text":"","category":"section"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"A very useful construction in applied category theory is the Category of Elements, which is also called the Grothendieck construction. This is a very general technique in category theory, but we will look at how you can use it to explain why graphs are so useful in computer science. We have already seen that C-Sets are a model of relational databases that can be used to store data as a collection of interlocking tables. Relational databases are the bread and butter of the computing industry. Every company on earth uses software that is backed by a relational database. Most data that is not stored in a relational DB is often stored in some kind of graph data structure. This sketch will show how these approaches are interchangeable via the category of elements, which associates to every database instance a graph and a graph homomorphism into the schema of the graph.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"using Catlab.GATs, Catlab.CategoricalAlgebra, Catlab.Graphs, Catlab.Graphics\nusing Colors","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"Let's tell Catlab how to draw categories of elements.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"function graph(el::Elements)\n  F = FinFunctor(Dict(:V => :El, :E => :Arr), Dict(:src => :src, :tgt => :tgt),\n                 SchGraph, SchElements)\n  ΔF = DataMigrationFunctor(F, Elements{Symbol}, Graph)\n  return ΔF(el)\nend\n\nsafecolors(start, stop, len) = if len > 1\n  return hex.(range(start, stop=stop, length=len))\nelse\n  return [hex.(start)]\nend\n\nfunction draw(f::Elements; kw...)\n  pg = to_graphviz_property_graph(graph(f);\n    node_labels=true, edge_labels=true, prog=\"neato\", kw...)\n  vcolors = safecolors(colorant\"#0021A5\", colorant\"#FA4616\", nparts(f, :Ob))\n  ecolors = safecolors(colorant\"#6C9AC3\", colorant\"#E28F41\", nparts(f, :Hom))\n  for v in parts(f, :El)\n    fv = f[v, :πₑ]\n    set_vprops!(pg, v, Dict(:color => \"#$(vcolors[fv])\", :label=>\"$v:$(f[v,[:πₑ, :nameo]])\"))\n  end\n  for e in parts(f, :Arr)\n    fe = f[e, :πₐ]\n    set_eprops!(pg, e, Dict(:color => \"#$(ecolors[fe])\"))\n  end\n  to_graphviz(pg)\nend\n\ndraw(g) = to_graphviz(g, node_labels=true, edge_labels=true, prog=\"neato\")","category":"page"},{"location":"generated/sketches/cat_elements/#The-simplest-schema","page":"The Category of Elements","title":"The simplest schema","text":"","category":"section"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"First we will look at discrete dynamical systems. The set S is our state space and the funct nxt associates to every state, the next state in the system. This is a deterministic dynamical system with finitely many states and discrete time.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"@present SchDDS(FreeSchema) begin\n  S::Ob\n  nxt::Hom(S, S)\nend\n\n@acset_type DDS(SchDDS, index=[:nxt])\n\nfₓ = @acset DDS begin\n  S = 3\n  nxt = [2,3,1]\nend","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"Now if you want to draw a DDS, you might think to draw each state as a vertex and the next relationship as an arrow from one state to the next state. If your intuition selected that representation, you have already discovered a special case of the category of elements","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"elᶠ = elements(fₓ)\ndraw(graph(elᶠ))","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"As you are quite far in your category theoretic training, you are surely suspicious of the idea that you would construct the category of elements of a DDS and get a graph. We have a categorical construction, so your intuition should be saying \"there should be some kind of morphism that goes with this object\". And there is, the Elements of a C-Set X is a graph whose vertices are rows in the tables of X and whose edges are the foreign key relationships in X, along with a graph homomorphism into the schema C. We can draw this using the same color coding convention we used to draw graph homomorphisms.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"draw(elᶠ)","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"We can scale up our DDS drawing too.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"Fₓ = @acset DDS begin\n  S = 7\n  nxt = [2,3,1, 1,7,7,4]\nend\ndraw(elements(Fₓ))","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"A category of elements derived from a C-Set is stored as a C-Set of on a different schema. You can see that it is the data of a graph homomorphism where the codomain graph has vertex and edge labels. The two projections πₑ and πₐ are the components of a natural transformation between graphs viewed as functors into Set. The names are attributes usually of type Symbol.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"to_graphviz(SchElements)","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"In the case of a DDS, we have only one object and one morphism in the schema. Since the graph with one edge and one vertices is terminal in Graph, there is only one vertex and edge color being used.","category":"page"},{"location":"generated/sketches/cat_elements/#The-Elements-of-a-Graph-are-its-Vertices-and-Edges","page":"The Category of Elements","title":"The Elements of a Graph are its Vertices and Edges","text":"","category":"section"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"In what might appear as primordial ooze, we can examine the category of elements of a graph. We will look at the commuting triangle graph. Notice how there are 3 vertices and three edges with each edge incident to 2 vertices.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"g = @acset Graph begin\n  V = 3\n  E = 3\n  src = [1,2,1]\n  tgt = [2,3,3]\nend\ndraw(g)","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"The category of elements has 6 vertices and 6 edges. The 6 vertices come from 3 vertices of type V and 3 vertices of type E. The 6 edges in this graph are 3 src relationships and 3 target relationships.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"elᵍ = elements(g)\ndraw(elᵍ)\n\ng = @acset Graph begin\n  V = 6\n  E = 7\n  src = [1,2,1,3,5,6,4]\n  tgt = [2,3,3,5,6,3,4]\nend\ndraw(g)\ndraw(elements(g))","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"Notice that the 3 vertices of type E are interspersed between the 3 vertices of type V and vice versa. You can see that the normal visual syntax for a graph is more compact for the special case of graphs. However the category of elements works for any schema C.","category":"page"},{"location":"generated/sketches/cat_elements/#Generality-of-the-construction","page":"The Category of Elements","title":"Generality of the construction","text":"","category":"section"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"Discrete Dynamical Systems and Graphs are clearly data structures from mathematics and so it would make sense that they have a clean representation in the categorical language. But how about a database schema that comes not from mathematics, but from software engineering. We turn to everyone's favorite database example, the HR database at a fictitious company.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"@present SchCompany(FreeSchema) begin\n  (P, D, S)::Ob # Person, Department, Salary\n  worksin::Hom(P, D)    # Every Person works in a Department\n  makes::Hom(P, S)      # Every Person makes a Salary\n  reportsto::Hom(P, P)  # Every Person reports to a Person\n  managedby::Hom(D, P)  # Every Department is managed by a Person\n  leq::Hom(S,S)         # Salaries are a finite total order\nend\n\n@acset_type Company(SchCompany, index=[])","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"We can draw a company that has 4 people, 2 departments, and 3 distinct salaries.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"cmpy = @acset Company begin\n  P = 4\n  D = 2\n  S = 3\n  worksin = [1,1,2,2]\n  makes = [3,1,2,1]\n  reportsto = [1, 1,1,3]\n  managedby = [1,3]\n  leq = [2,3,3]\nend","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"A visualization of the elements of this functor is commonly described as a knowledge graph.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"elᶜ = elements(cmpy)\ndraw(elᶜ)","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"The visualization of the category of elements isn't the most compact representation of data, but it is always an option. Once you know how to draw a graph homomorphism as a color-coded graph, you know how to draw any C-Set. The vertices and edges of the domain graph are the rows and fields of the C-Set, and the colors are from the vertices and edges of the schema C, viewed as a graph presenting the category. One thing you lose is the ability to represent path equations in C.","category":"page"},{"location":"generated/sketches/cat_elements/#Reconstructing-the-C-Set-from-its-category-of-elemnts","page":"The Category of Elements","title":"Reconstructing the C-Set from its category of elemnts","text":"","category":"section"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"When looking at the graphical representation of the category of elements, you can see that the vertices are numbered sequentially within their vertex type. This order can be computed with the incident function in Catlab. There are inclusions of all the tables in the database instance into the global vertex set of the knowledge graph representation.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"incident(elᶜ, :, :πₑ)","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"The same goes for the edges (arrows) in the category of elements.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"incident(elᶜ, :, :πₐ)","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"From this information, you can reassemble the knowledge graph into a database. You use the codomain graph as the schema and then these two projections πₑ and πₐ to recover the instance data.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"cset(T::Type, el::Elements) = begin\n  X = T()\n  ℓ = Dict{Int, Int}() # this map reverses the inclusions converting global element numbers into per-table numbers\n  for ob in parts(el, :Ob)\n    obname = el[ob, :nameo]\n    eltsob = incident(el, ob, :πₑ)\n    pts = add_parts!(X, obname, length(eltsob))\n    map(zip(pts, eltsob)) do (i,x)\n      ℓ[x] = i\n    end\n  end\n  for h in parts(el, :Hom)\n    nameh = el[h, :nameh]\n    arrₕ = incident(el, h, :πₐ)\n    doms = map(arrₕ) do e\n      ℓ[el[e, :src]]\n    end\n    codoms = map(arrₕ) do e\n      ℓ[el[e, :tgt]]\n    end\n    set_subpart!(X, doms, nameh, codoms)\n  end\n  return X\nend","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"We can apply this algorithm to our company knowledge graph to recover our original DB.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"cset(Company, elᶜ)\ncmpy == cset(Company, elᶜ)","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"Hopefully you see one reason why graphs are ubiquitous in computer science. Every relational database is isomorphic to a typed graph. You can generate this graph from the database and recover the database from the typed graph. So while knowledge graphs are great for ingesting data when you aren't sure about the structure and useful for some types of computation that involve long paths. You can always build your software on relational databases knowing that you can easily get access to all the graph algorithms by applying the Grothendieck construction.","category":"page"},{"location":"generated/sketches/cat_elements/#The-Slice-Elements-Transform","page":"The Category of Elements","title":"The Slice-Elements Transform","text":"","category":"section"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"An amazing fact about presheaf toposes is that they are closed under taking slices. In the graphs section of this documentation, you can find a description of bipartite and k-partite graphs as a morphisms into a clique. That definition is very mathematically pleasing because it gives you a category of partitioned graphs that are derived from commuting triangles in Graph. However, for application oriented practitioners, the definition of a bipartite graph as \"a graph with two sets of vertices, where all the edges go between the groups with no edges within either group\" is probably more explicit. For example a classic way to get a bipartite graph would be to look at the graph of authors and papers that those authors wrote. People write papers, people do not write people and papers do not write papers so the authorship graph is bipartite. These two equivalent definitions of a bipartite graph are related via an isomorphism you can find on the nlab. It shows that a slice category of [C,Set]/X is isomorphic to [El(X), Set] which is a cateogory of presheaves on a different schema. Catlab knows how to use this idea to turn a category of elements into a schema for a new category of presheaves. The two directions of the isomorphism are not yet implemented.","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"e = @acset Graph begin\n  V = 2\n  E = 1\n  src = 1\n  tgt = 2\nend\n\ndraw(elements(e))\n\nSchBipartite = CatElements.presentation(elements(e))[1]\nto_graphviz(SchBipartite)\n\n@acset_type BipartiteGraph(SchBipartite)\nb = @acset BipartiteGraph begin\n  V_1 = 3\n  V_2 = 2\n  E_1 = 5\n  src_E_1 = [1,2,3,3,2]\n  tgt_E_1 = [1,2,2,1,1]\nend\ndraw(elements(b))","category":"page"},{"location":"generated/sketches/cat_elements/","page":"The Category of Elements","title":"The Category of Elements","text":"As a very advanced exercise, you could try to implement one or both directions of the isomorphism above.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"EditURL = \"../../../literate/graphs/graphs_label.jl\"","category":"page"},{"location":"generated/graphs/graphs_label/#Labeled-Graphs","page":"Labeled Graphs","title":"Labeled Graphs","text":"","category":"section"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"This example demonstrates how to define new C-Sets from existing C-Sets via the example of adding labels to a graph. We treat labels as members of an arbitrary FinSet of labels rather than a data attribute for pedagogical reasons. When you think of graphs where the labels are numbers, colors, or values of some kind, you would want to make them attributes. The motivation for this example is to be the simplest extension to the theory of graphs that you could possibly make.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"using Catlab.GATs, Catlab.Theories\nusing Catlab.CategoricalAlgebra\nusing Catlab.Graphs\nusing Catlab.Graphics\nusing Colors\ndraw(g) = to_graphviz(g, node_labels=true, edge_labels=true)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"We start with the theory of graphs, which is copied from Catlab.Graphs.BasicGraphs. The two objects are the edges and vertices and we have two functions src,tgt that assign to every edge the source vertex and target vertex respectively. Functors from this category to Set (diagrams in Set of this shape) are category theoretic graphs (directed multigraphs).","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"@present SchGraph(FreeSchema) begin\n  V::Ob\n  E::Ob\n  src::Hom(E,V)\n  tgt::Hom(E,V)\nend\n\nto_graphviz(SchGraph)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"To the theory of graphs we want to add a set of labels L and map that assigns to every vertex to its label in L.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"@present SchLGraph <: SchGraph begin\n  L::Ob\n  label::Hom(V,L)\nend\n\nto_graphviz(SchLGraph)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"Catlab will automatically generate all the data structure and algorithms (storing, mutating, serializing, etc.) our LGraphs for us. This snippet declares that the Julia type LGraph should be composed of objects of the functor category SchLGraph → Skel(FinSet), where Skel(FinSet) is the subcategory of Set containing finite sets of form 1:n. We want our Julia type LGraph to inherit from the type AbstractGraph so that we can run graph algorithms on it. And we want the generated data structures to make an index of the maps src, tgt, and label so that looking up the in and outneighbors of vertex is fast and accessing all vertices by label is also fast.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"Note: This schema differs from that of LabeledGraph in Catlab.Graphs by making the label type an object (Ob) rather than attribute type (AttrType). In this case, the set of labels can vary from instance to instance and homomorphisms can rename labels; in the other case, the set of labels is fixed by a Julia type, such as Int or Symbol, and label values must be strictly preserved homomorphisms. The graph theory literature does not always distinguish very carefully between these two cases.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"@acset_type LGraph(SchLGraph, index=[:src,:tgt,:label]) <: AbstractGraph","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"We need to tell Catlab how to convert our LGraph type into the normal Graph type by taking just the edges and vertices. This could be computed with Functorial Data Migration, but that is left for another sketch.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"to_graph(g::LGraph) = begin\n  h = Graph(nparts(g,:V))\n  for e in edges(g)\n    add_edge!(h, g[e, :src], g[e,:tgt])\n  end\n  return h\nend","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"Graphviz doesn't automatically know how we want to draw the labels, so we have to explicitly provide code that converts them to colors on the vertices. Note that we aren't calling these colored graphs, because that would imply some connectivity constraints on which vertices are allowed to be colored with the same colors. These labels are arbitrary, but we use color to visually encode them.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"GraphvizGraphs.to_graphviz(g::LGraph; kw...) =\n  to_graphviz(to_graphviz_property_graph(g; kw...))\n\nfunction GraphvizGraphs.to_graphviz_property_graph(g::LGraph; kw...)\n  h = to_graph(g)\n  pg = to_graphviz_property_graph(h; kw...)\n  vcolors = hex.(range(colorant\"#0021A5\", stop=colorant\"#FA4616\", length=nparts(g, :L)))\n  for v in vertices(g)\n    l = g[v, :label]\n    set_vprops!(pg, v, Dict(:color => \"#$(vcolors[l])\"))\n  end\n  pg\nend\n\ndraw(G::LGraph) = to_graphviz(G, node_labels=true, edge_labels=true)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"Now we can start making some LGraph instances.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"G = @acset LGraph begin\n  V = 4\n  E = 4\n  L = 4\n  src = [1,1,2,3]\n  tgt = [2,3,4,4]\n  label = [1,2,3,4]\nend\n\ndraw(G)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"The graph G has a 1-1 map between vertices and labels. That isn't necessary.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"H = @acset LGraph begin\n  V = 4\n  E = 4\n  L = 3\n  src = [1,1,2,3]\n  tgt = [2,3,4,4]\n  label = [1,2,2,3]\nend\n\ndraw(H)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"We can look at some homomorphisms from G to H by their action on the labels or on the vertices.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"homsᵥ(G,H) = map(α -> α[:V], homomorphisms(G, H))\nhomsₗ(G,H) = map(α -> α[:L], homomorphisms(G, H))","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"αₗ: G→ H","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"homsₗ(G,H)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"αᵥ: G→ H","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"homsᵥ(G,H)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"Note that if we reverse the direction of our homomorphism search, we get fewer matches even though the two LGraphs are isomorphic as graphs. The fact that in H vertex two and three are the same label means we have to send them to the same vertex in G.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"homsᵥ(H,G)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"We can build some bigger examples like A.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"A = @acset LGraph begin\n  V = 6\n  E = 7\n  L = 3\n  src = [1,1,2,3,2,5,4]\n  tgt = [2,3,4,4,5,6,6]\n  label = [1,2,2,3,2,3]\nend\ndraw(A)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"and B.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"B = @acset LGraph begin\n  V = 6\n  E = 7\n  L = 4\n  src = [1,1,2,3,2,5,4]\n  tgt = [2,3,4,4,5,6,6]\n  label = [1,2,4,3,2,3]\nend\ndraw(B)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"The morphisms from A to B and B to A are also different, showing how the labels affect the structure in this category.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"homsᵥ(A,B)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"There are more morphisms from B to A than A to B.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"homsᵥ(B,A)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"There are two automorphisms on A","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"homsᵥ(A,A)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"And two automorphisms on B","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"homsᵥ(B,B)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"But if we forget about the labels and look at the automorphisms of the underlying graph, we get more automorphisms!","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"A₀ = to_graph(A)\nhomsᵥ(A₀, A₀)","category":"page"},{"location":"generated/graphs/graphs_label/#Limits-and-Composition-by-Multiplication","page":"Labeled Graphs","title":"Limits and Composition by Multiplication","text":"","category":"section"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"Catlab has an implementation of limits for any C-Sets over any schema. So, we can just ask about labeled graphs. Notice that we get more distinct colors in the product than in either initial graph. This is because the labels of the product are pairs of labels from the factors. If G has n colors and H has m colors G×H will have n×m colors.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"draw(apex(product(G,G)))","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"The graph above looks weirdly disconnected and probably wasn't what you expected to see as the product. When we compose with products, we often want to add the reflexive edges in order to get the expected notion of product.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"add_loops!(G::LGraph) = begin\n  for v in parts(G,:V)\n    add_edge!(G, v,v)\n  end\n  return G\nend\nadd_loops(G::LGraph) = add_loops!(copy(G))\n\nGᵣ = add_loops(G)\nP = apex(product(Gᵣ, G))\ndraw(apex(product(Gᵣ, G)))","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"We can look at the shape of commuting triangle, which is our favorite 3-vertex graph.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"T = @acset LGraph begin\n  V = 3\n  E = 3\n  L = 3\n  src = [1,1,2]\n  tgt = [2,3,3]\n  label = [1,2,3]\nend\nTᵣ = add_loops(T)\ndraw(Tᵣ)\n\nE = @acset LGraph begin\n  V = 2\n  E = 1\n  L = 2\n  src = [1]\n  tgt = [2]\n  label = [1,2]\nend\nEᵣ = add_loops(E)\ndraw(Eᵣ)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"We can draw the product of the edge graph and the triangle graph to get the shape of a triangular prism. You can view this product as extruding Tᵣ along Eᵣ. Catlab provides a ReflexiveGraph as a type that handles these self-loops more intelligently than we are here. Graphviz struggles with the layout here because the product graph will include edges that are a step in both directions. This blog post does a good job explaining products in differnt kinds of graph categories.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"draw(apex(product(Tᵣ,Eᵣ)))\nlegs(product(Tᵣ, Eᵣ))[1][:V] |> collect","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"Another limit is the pullback. If you have a cospan, which is a diagram of the shape X ⟶ A ⟵ Y, you can pull back one arrow along the other by solving a system of equations.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"PB₂₂ = pullback(homomorphisms(Tᵣ,Eᵣ)[2],homomorphisms(Tᵣ,Eᵣ)[2]);\ndraw(apex(PB₂₂))","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"Note that the pullback depends not only on X,A,Y but also on the two arrows. You can play around with the choice of morphisms to gain an intuition of how the pullback depends on the morphisms.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"PB₂₃ = pullback(homomorphisms(Tᵣ,Eᵣ)[2],homomorphisms(Tᵣ,Eᵣ)[3]);\ndraw(apex(PB₂₃))","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"By constructions, the pullback is always a subobject (monic homomorphism) into the product. Catlab can enumerate all such monoic homs.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"homomorphisms(apex(PB₂₂), apex(product(Tᵣ,Tᵣ)), monic=true) |> length","category":"page"},{"location":"generated/graphs/graphs_label/#Colimits-and-Composition-by-Glueing","page":"Labeled Graphs","title":"Colimits and Composition by Glueing","text":"","category":"section"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"The dual concept to limits is colimits and if limits have vibes of taking all pairs that satisfy certain constraints, colimits have the vibes of designers just gluing stuff together to make it work.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"In order to illustrate this we will be gluing triangles together to make a mesh. We start by defining the point X, which is the shape of the boundary along which we will glue and the morphism ℓ₁, which is the place in T that we consider as the boundary.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"X = @acset LGraph begin\n  E = 0\n  V = 1\n  L = 3\n  label=[2]\nend\nℓ₁ = ACSetTransformation(X,T, V=[2],L=1:3)\ndraw(X)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"We have to check that the morphism is valid before we go and compute out pushout.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"is_natural(ℓ₁)\nP = pushout(ℓ₁, ℓ₁)\ndraw(apex(P))","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"Now we want to repeat the gluing process to get a bigger mesh. So we are going to need a bigger interface.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"I = @acset LGraph begin\n  V = 2\n  L = 3\n  label = [1,1]\nend\ndraw(I)","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"We have to specify how this interface embeds into both of the things we want to glue. In this case we are gluing a copy of P onto itself.","category":"page"},{"location":"generated/graphs/graphs_label/","page":"Labeled Graphs","title":"Labeled Graphs","text":"ll = ACSetTransformation(I, apex(P), V=[3,5], L =[3,1,2])\nis_natural(ll)\nlr = ACSetTransformation(I, apex(P), V=[1,4], L =[1,3,2])\nis_natural(lr)\nP₂ = pushout(ll, lr);\ndraw(apex(P₂))","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"EditURL = \"../../../literate/wiring_diagrams/wd_cset.jl\"","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/#Wiring-Diagrams-as-Attributed-C-Sets","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"","category":"section"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"Catlab supports many different flavors of diagrammatic syntax. These support the different combinatorial data structures that we use for representing categorical constructions. We will discuss DirectedWiringDiagrams, UndirectedWiringDiagrams, and CPortGraphs in this document.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"using Catlab.GATs, Catlab.Theories\nusing Catlab.CategoricalAlgebra\nusing Catlab.WiringDiagrams\nusing Catlab.Programs\nusing Catlab.Graphics\nusing Catlab.Graphics: Graphviz\n\ndraw(d::WiringDiagram) = to_graphviz(d,\n  orientation=LeftToRight,\n  labels=true, label_attr=:xlabel,\n  node_attrs=Graphviz.Attributes(\n    :fontname => \"Courier\",\n  ),\n  edge_attrs=Graphviz.Attributes(\n    :fontname => \"Courier\",\n  )\n)\n\ndraw(uwd::AbstractUWD) = to_graphviz(uwd, junction_labels=:variable, box_labels=:name)","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/#Directed-Wiring-Diagrams","page":"Wiring Diagrams as Attributed C-Sets","title":"Directed Wiring Diagrams","text":"","category":"section"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"DWDs are used to represent the morphisms in a symmetric monoidal category. You can get started by presenting a FreeSymmetricMonoidalCategory with the @present macro.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"@present P(FreeSymmetricMonoidalCategory) begin\n  (A,B,C,D)::Ob\n  f::Hom(A,B)\n  g::Hom(B,A)\n  h::Hom(A⊗B, C)\n  k::Hom(C,D⊗A)\nend\ngenerators(P)","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"These presentations are very syntactic objects and expose an API for manipulating expressions.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"for g in generators(P)\n  \"$g is a $(gat_typeof(g)) with arguments $(gat_type_args(g))\"\nend","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"The gat_typeof function computes the algebraic type of a term by analogy to Base.typeof which computes the Julia type of a value.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"homs_P = filter(generators(P)) do g\n  gat_typeof(g) == :Hom\nend","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"When the term is a Hom, you can get the domain and codomain of the morphism with the dom and codom functions.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"map(homs_P) do f\n  \"$f: $(dom(f)) → $(codom(f))\"\nend","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"With the presentation you can build up morphism expressions using a formula syntax.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"P[:h]⋅P[:k]","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"This syntactic API is useful for manipulating terms in an arbitrary GAT and is the formal language of Catlab for representing and manipulating algebraic structures. However, when we want to work with big expressions in an SMC, the tree structure inherent to formulas is too verbose, and we want to move to a port-graph structure called DirectedWiringDiagrams. This gives us the benefits of combinatorial data structures like graphs with the right expressional power for representing the morphisms in an SMC.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"wd = @program P (a::A, b::B) begin\n  c = h(a,b)\n  return k(c)\nend\n\ndraw(wd)","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"Catlab gives you the tools for drawing wiring diagrams. Visualization of wiring diagrams is the oldest part of Catlab and the original motivation for its development. The @program macro allows you to define wiring diagrams using a syntax that feels like Julia code.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"wd = @program P (a::A, b::B) begin\n  c = h(a,b)\n  d,a₁ = k(c)\n  return d, f(a₁)\nend\ndraw(wd)","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"The input wires are declared as arguments to the program, and the output wires are declared as returns from the function. Variables that are not consumed or by another function or returned by the program are automatically dropped.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"wd = @program P (a::A, b::B) begin\n  c = h(a,b)\n  d,a₁ = k(c)\n  return f(a₁)\nend\ndraw(wd)","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"You can copy a value by using it more than once. This is visualized as a wire being split into two wires.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"wd = @program P (b::B) begin\n  h(g(b),b)\nend\ndraw(wd)","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"You can visualize the copy and delete morphisms explicitly with the add_junctions function. The dots with one wire input and multiple outputs are copying values and dots with no wires out are deletions (discarding values). Not all instances of a SymmetricMonoidalCategory support copy and delete, for example, in manufacturing you can't duplicate a resource, and in chemistry you can't discard species. Catlab would enforce that when you tried to interpret the wiring diagram in a specific SMC.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"wd = @program P (b::B) begin\n  c = h(g(b),b)\n  d, a₁ = k(c)\n  return f(a₁)\nend\ndraw(add_junctions(wd))","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"For more details about working with wiring diagrams in Catlab, you should look at the other vignettes in this section which explain how wiring diagrams interact with SMC expressions and the basics of constructing and manipulation wiring diagrams.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/#Diagrams-as-C-Sets","page":"Wiring Diagrams as Attributed C-Sets","title":"Diagrams as C-Sets","text":"","category":"section"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"The underlying data of a wiring diagram is combinatorial. That means we can represent it as a C-Set","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"wd.diagram","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"Ok, there is a lot in there. The columns with integer entries are the combinatorial data encoding the connectivity of the wiring diagram. The columns with Symbols in them are encoding the labels for the diagram, the value of a box is the content of the box. Ports have types and wires have values. When we define the wiring diagram with the @program macro, we get a diagram that has labels and types, but no values. These values are initialized to nothing, but could be filled with values to be carried down the wires in an application.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"The schema of for wiring diagrams is called SchAttributedWiringDiagrams and is a little overwhelming, so we can explore how to build it up with C-Set schema inheritance.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"to_graphviz(SchAttributedWiringDiagram)","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"From the file Catlab/src/WiringDiagrams/Directed.jl","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"@present SchWiringDiagram(FreeSchema) begin\n  Box::Ob\n  (InPort, OutPort, OuterInPort, OuterOutPort)::Ob\n  (Wire, InWire, OutWire, PassWire)::Ob\n\n  src::Hom(Wire, OutPort)\n  tgt::Hom(Wire, InPort)\n  in_src::Hom(InWire, OuterInPort)\n  in_tgt::Hom(InWire, InPort)\n  out_src::Hom(OutWire, OutPort)\n  out_tgt::Hom(OutWire, OuterOutPort)\n  pass_src::Hom(PassWire, OuterInPort)\n  pass_tgt::Hom(PassWire, OuterOutPort)\n\n  in_port_box::Hom(InPort, Box)\n  out_port_box::Hom(OutPort, Box)\nend\n\n@abstract_acset_type AbstractWiringDiagram <: AbstractGraph\n\n@present SchTypedWiringDiagram <: SchWiringDiagram begin\n  PortValue::AttrType\n  in_port_type::Attr(InPort, PortValue)\n  out_port_type::Attr(OutPort, PortValue)\n  outer_in_port_type::Attr(OuterInPort, PortValue)\n  outer_out_port_type::Attr(OuterOutPort, PortValue)\nend\n\n@present SchAttributedWiringDiagram <: SchTypedWiringDiagram begin\n  WireValue::AttrType\n  BoxValue::AttrType\n  BoxType::AttrType\n\n  value::Attr(Box, BoxValue)\n  box_type::Attr(Box, BoxType)\n  wire_value::Attr(Wire, WireValue)\n  in_wire_value::Attr(InWire, WireValue)\n  out_wire_value::Attr(OutWire, WireValue)\n  pass_wire_value::Attr(PassWire, WireValue)\nend","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"The bare minimum diagram language is:","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"to_graphviz(SchWiringDiagram)","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"And then you can add back in the types.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"to_graphviz(SchTypedWiringDiagram)","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"Layout is hard, so if you want to understand the SchAttributedWiringDiagrams, you should do the layout by hand as an exercise.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"We can create our own version of the theory of DWDs to see how it works:","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"@present MySchWiringDiagram(FreeSchema) begin\n  Box::Ob\n  (InPort, OutPort, OuterInPort, OuterOutPort)::Ob\n  (Wire, InWire, OutWire, PassWire)::Ob\n\n  src::Hom(Wire, OutPort)\n  tgt::Hom(Wire, InPort)\n  in_src::Hom(InWire, OuterInPort)\n  in_tgt::Hom(InWire, InPort)\n  out_src::Hom(OutWire, OutPort)\n  out_tgt::Hom(OutWire, OuterOutPort)\n  pass_src::Hom(PassWire, OuterInPort)\n  pass_tgt::Hom(PassWire, OuterOutPort)\n\n  in_port_box::Hom(InPort, Box)\n  out_port_box::Hom(OutPort, Box)\nend","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"If your application of wiring diagrams needs to attach numeric or textual information to the boxes of a wiring diagram, you would extend the SchWiringDiagram with the attributes that you need. That will give you a custom data structure that has those fields. One of the goals of Catlab is to make it so much easier to generate custom data structures that interoperate, that you don't need to create generic structures that can be used for many purposes. Just snap your fingers and create a new structure perfectly tailored to your needs, when your needs change, snap again to get a new version of that structure.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"The @acset_type macro does the hard work of generating the data structure and accessors and mutators for you. The form of this call is @acset_type NewStructName(Schema, index=[morphisms in Schema]) <: Supertype. You should index any morphism where you need to use incident frequently. For wiring diagrams you will often want to know what all the wires that are incident to a port.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"@acset_type MyWiringDiagramACSet(MySchWiringDiagram,\n  index=[:src, :tgt, :in_src, :in_tgt, :out_src, :out_tgt, :pass_src, :pass_tgt]) <: WiringDiagrams.DirectedWiringDiagrams.AbstractWiringDiagram","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"We get the @acset macro from Catlab and can create DWDs by hand. It is very tedious, which is why the @program macro exists!","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"md = @acset MyWiringDiagramACSet begin\n  Box = 3\n  InPort = 6\n  OutPort = 3\n  Wire = 3\n  src = [1,2,3]\n  tgt = [3,4,5]\n  in_port_box = [1,1,2,2,3,3]\n  out_port_box = [1,2,3]\nend","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/#Undirected-Wiring-Diagrams","page":"Wiring Diagrams as Attributed C-Sets","title":"Undirected Wiring Diagrams","text":"","category":"section"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"A much simpler structure than DWDs are known as undirected wiring diagrams. They are called undirected because ports boxes have one set of ports that aren't divided into inputs and outputs, and the wires are undirected. Wires connect junctions to ports (which live on boxes).","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"to_graphviz(SchUWD)","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"These UWDs are combinatorial syntax for relations. The junctions are variables and the boxes are the relations. A relation R ⊆ X × Y has two ports one for the value of X and one for the value of Y. The expression R(x:X, y:Y) says to connect the X port of R to the junction for the variable x, and the Y port of R to the y variable junction. If two ports are attached to the same junction, then you have a constraint that those values must be equal. The outer ports are the components of the final relation. For example the following UWD encodes the relation {(x,y,z) | R(x,y) and S(y,z) for all x∈X, y∈Y, z∈Z}.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"uwd = @relation (x, y, z) begin\n  R(x,y)\n  S(y,z)\nend","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"These UWDs are drawn with circular boxes and undirected wires. Note that since all wires go from junction to port, they are not symmetric wires.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"draw(uwd)","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"By adding more relations we can get bigger relations.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"uwd₂ = @relation (x, z) begin\n  R(x,y)\n  S(y,z)\n  T(x,z,y)\nend","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"Not all of the junctions have to be exposed to the outside world. Note that there is no distinction between arguments and return values in the relation macro. This is because relations are inherently undirected, unlike functions.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"draw(uwd₂)","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/#Circular-Port-Graphs","page":"Wiring Diagrams as Attributed C-Sets","title":"Circular Port Graphs","text":"","category":"section"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"CPGs are the natural data structure for representing process of interconnected systems that share information along wires, but send different information to their different neighbors.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"to_graphviz(SchCPortGraph)","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"They are also a kind of CSet, so we can use the @acset macro to construct them.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"cpg = @acset CPortGraph begin\n  Box = 3\n  Port = 6\n  Wire = 5\n\n  box = [1,1,2,2,3,3]\n  src = [1,2,5,2,6]\n  tgt = [3,4,2,4,1]\nend","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"the layout for CPGs is not great with graphviz.","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"to_graphviz(cpg, port_labels=true, graph_attrs=Dict(\"nodesep\"=>\"2\", \"ranksep\"=>\"2\"))","category":"page"},{"location":"generated/wiring_diagrams/wd_cset/","page":"Wiring Diagrams as Attributed C-Sets","title":"Wiring Diagrams as Attributed C-Sets","text":"Almost every application of graphs in computer science could be better served by using one of these extensions to the basic graph data structure.","category":"page"},{"location":"apis/categorical_algebra/#categorical_algebra","page":"Categorical algebra","title":"Categorical algebra","text":"","category":"section"},{"location":"apis/categorical_algebra/#Sets-and-Relations","page":"Categorical algebra","title":"Sets and Relations","text":"","category":"section"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"The following APIs implement FinSet, the category of Finite Sets (actually the skeleton of FinSet). The objects of this category are natural numbers where n represents a set with n elements. The morphisms are functions between such sets. We use the skeleton of FinSet in order to ensure that all sets are finite and morphisms can be stored using lists of integers. Finite relations are built out of FinSet and can be used to do some relational algebra.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"Modules = [\n  CategoricalAlgebra.Sets,\n  CategoricalAlgebra.FinSets,\n  CategoricalAlgebra.FinRelations,\n  ]\nPrivate = false","category":"page"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Sets","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Sets","text":"Category of (possibly infinite) sets and functions.\n\nThis module defines generic types for the category of sets (SetOb, SetFunction), as well as a few basic concrete types, such as a wrapper type to view Julia types as sets (TypeSet). Extensive support for finite sets is provided by another module, FinSets.\n\n\n\n\n\n","category":"module"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Sets.ConstantFunction","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Sets.ConstantFunction","text":"Function in Set taking a constant value.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Sets.PredicatedSet","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Sets.PredicatedSet","text":"Set defined by a predicate (boolean-valued function) on a Julia data type.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Sets.SetFunction","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Sets.SetFunction","text":"Abstract type for morphism in the category Set.\n\nEvery instance of SetFunction{<:SetOb{T},<:SetOb{T′}} is callable with elements of type T, returning an element of type T′.\n\nNote: This type would be better called simply Function but that name is already taken by the base Julia type.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Sets.SetOb","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Sets.SetOb","text":"Abstract type for object in the category Set.\n\nThe type parameter T is the element type of the set.\n\nNote: This type is more abstract than the built-in Julia types AbstractSet and Set, which are intended for data structures for finite sets. Those are encompassed by the subtype FinSet.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Sets.TypeSet","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Sets.TypeSet","text":"A Julia data type regarded as a set.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.Theories.Ob-Union{Tuple{TypeCat{T}}, Tuple{T}} where T","page":"Categorical algebra","title":"Catlab.Theories.Ob","text":"Forgetful functor Ob: Cat → Set.\n\nSends a category to its set of objects and a functor to its object map.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets","text":"The category of finite sets and functions, and its skeleton.\n\n\n\n\n\n","category":"module"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.FinDomFunction","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.FinDomFunction","text":"Function out of a finite set.\n\nThis class of functions is convenient because it is exactly the class that can be represented explicitly by a vector of values from the codomain.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.FinFunction","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.FinFunction","text":"Function between finite sets.\n\nThe function can be defined implicitly by an arbitrary Julia function, in which case it is evaluated lazily, or explictly by a vector of integers. In the vector representation, the function (1↦1, 2↦3, 3↦2, 4↦3), for example, is represented by the vector [1,3,2,3].\n\nFinFunctions can be constructed with or without an explicitly provided codomain. If a codomain is provided, by default the constructor checks it is valid.\n\nThis type is mildly generalized by FinDomFunction.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.FinSet","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.FinSet","text":"Finite set.\n\nA finite set has abstract type FinSet{S,T}. The second type parameter T is the element type of the set and the first parameter S is the collection type, which can be a subtype of AbstractSet or another Julia collection type. In addition, the skeleton of the category FinSet is the important special case S = Int. The set 1n is represented by the object FinSet(n) of type FinSet{Int,Int}.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.HashJoin","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.HashJoin","text":"Hash join algorithm.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm","text":"Algorithm for limit of cospan or multicospan with feet being finite sets.\n\nIn the context of relational databases, such limits are called joins. The trivial join algorithm is NestedLoopJoin, which is algorithmically equivalent to the generic algorithm ComposeProductEqualizer. The algorithms HashJoin and SortMergeJoin are usually much faster. If you are unsure what algorithm to pick, use SmartJoin.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin","text":"Nested-loop join algorithm.\n\nThis is the naive algorithm for computing joins.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.SmartJoin","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.SmartJoin","text":"Meta-algorithm for joins that attempts to pick an appropriate algorithm.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.SortMergeJoin","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.SortMergeJoin","text":"Sort-merge join algorithm.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.SubFinSet","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.SubFinSet","text":"Subset of a finite set.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.SubOpBoolean","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.SubOpBoolean","text":"Algorithm to compute subobject operations using elementwise boolean logic.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.TabularLimit","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.TabularLimit","text":"Limit of finite sets viewed as a table.\n\nAny limit of finite sets can be canonically viewed as a table (TabularSet) whose columns are the legs of the limit cone and whose rows correspond to elements of the limit object. To construct this table from an already computed limit, call TabularLimit(::AbstractLimit; ...). The column names of the table are given by the optional argument names.\n\nIn this tabular form, applying the universal property of the limit is trivial since it is just tupling. Thus, this representation can be useful when the original limit algorithm does not support efficient application of the universal property. On the other hand, this representation has the disadvantage of generally making the element type of the limit set more complicated.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.TabularSet","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.TabularSet","text":"Finite set whose elements are rows of a table.\n\nThe underlying table should be compliant with Tables.jl. For the sake of uniformity, the rows are provided as named tuples, which assumes that the table is not \"extremely wide\". This should not be a major limitation in practice but see the Tables.jl documentation for further discussion.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.VarFunction","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.VarFunction","text":"Data type of a map out of a set of attribute variables\n\nCurrently, domains are FinSet{Int} and codomains are expected to be FinSet{Int}. This could be generalized to being FinSet{Symbol} to allow for symbolic attributes. (Likewise, AttrVars will have to wrap Any rather than Int)\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.is_indexed-Tuple{SetFunction}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.is_indexed","text":"Whether the given function is indexed, i.e., supports efficient preimages.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinSets.preimage-Tuple{Catlab.CategoricalAlgebra.Sets.IdentityFunction, Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinSets.preimage","text":"The preimage (inverse image) of the value y in the codomain.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinRelations","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinRelations","text":"The category of finite sets and relations, and its skeleton.\n\n\n\n\n\n","category":"module"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinRelations.BoolRig","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinRelations.BoolRig","text":"The rig of booleans.\n\nThis struct is needed because in base Julia, the product of booleans is another boolean, but the sum of booleans is coerced to an integer: true + true == 2.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinRelations.FinRel","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinRelations.FinRel","text":"Object in the category of finite sets and relations.\n\nSee also: FinSet.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinRelations.FinRelation","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinRelations.FinRelation","text":"Binary relation between finite sets.\n\nA morphism in the category of finite sets and relations. The relation can be represented implicitly by an arbitrary Julia function mapping pairs of elements to booleans or explicitly by a matrix (dense or sparse) taking values in the rig of booleans (BoolRig).\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable","text":"Relation in FinRel defined by a callable Julia object.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix","text":"Relation in FinRel represented by a boolean matrix.\n\nBoolean matrices are also known as logical matrices or relation matrices.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Free-Diagrams,-Limits,-and-Colimits","page":"Categorical algebra","title":"Free Diagrams, Limits, and Colimits","text":"","category":"section"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"The following modules define free diagrams in an arbitrary category and specify limit and colimit cones over said diagrams. Thes constructions enjoy the fullest support for FinSet and are used below to define presheaf categories as C-Sets. The general idea of these functions is that you set up a limit computation by specifying a diagram and asking for a limit or colimit cone, which is returned as a struct containing the apex object and the leg morphisms. This cone structure can be queried using the functions apex and legs. Julia's multiple dispatch feature is heavily used to specialize limit and colimit computations for various diagram shapes like product/coproduct and equalizer/coequalizer. As a consumer of this API, it is highly recommended that you use multiple dispatch to specialize your code on the diagram shape whenever possible.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"Modules = [\n  CategoricalAlgebra.FreeDiagrams,\n  CategoricalAlgebra.Limits,\n  ]\nPrivate = false","category":"page"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams","text":"Free diagrams in a category.\n\nA free diagram in a category is a diagram whose shape is a free category. Examples include the empty diagram, pairs of objects, discrete diagrams, parallel pairs, composable pairs, and spans and cospans. Limits and colimits are most commonly taken over free diagrams.\n\n\n\n\n\n","category":"module"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram","text":"A free diagram with a bipartite structure.\n\nSuch diagrams include most of the fixed shapes, such as spans, cospans, and parallel morphisms. They are also the generic shape of diagrams for limits and colimits arising from undirected wiring diagrams. For limits, the boxes correspond to vertices in V₁ and the junctions to vertices in V₂. Colimits are dual.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram-Union{Tuple{Functor{<:Category{Int64, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where Hom}}, Tuple{Hom}, Tuple{Ob}} where {Ob, Hom}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram","text":"Convert a free diagram to a bipartite free diagram.\n\nReduce a free diagram to a free bipartite diagram with the same limit (the default, colimit=false) or the same colimit (colimit=true). The reduction is essentially the same in both cases, except for the choice of where to put isolated vertices, where we follow the conventions described at cone_objects and cocone_objects. The resulting object is a bipartite free diagram equipped with maps from the vertices of the bipartite diagram to the vertices of the original diagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms","text":"Composable morphisms in a category.\n\nComposable morphisms are a sequence of morphisms in a category that form a path in the underlying graph of the category.\n\nFor the common special case of two morphisms, see ComposablePair.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair","text":"Pair of composable morphisms in a category.\n\nComposable pairs are a common special case of ComposableMorphisms.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.Cospan","text":"Cospan of morphisms in a category.\n\nA common special case of Multicospan. See also Span.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram","text":"Discrete diagram: a diagram with no non-identity morphisms.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram","text":"Abstract type for free diagram of fixed shape.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan","text":"Multicospan of morphisms in a category.\n\nA multicospan is like a Cospan except that it may have a number of legs different than two. A limit of this shape is a pullback.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.Multispan","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.Multispan","text":"Multispan of morphisms in a category.\n\nA multispan is like a Span except that it may have a number of legs different than two. A colimit of this shape is a pushout.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms","text":"Parallel morphims in a category.\n\nParallel morphisms are just morphisms with the same domain and codomain. A (co)limit of this shape is a (co)equalizer.\n\nFor the common special case of two morphisms, see ParallelPair.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair","text":"Pair of parallel morphisms in a category.\n\nA common special case of ParallelMorphisms.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.Span","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.Span","text":"Span of morphims in a category.\n\nA common special case of Multispan. See also Cospan.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.apex","text":"Apex of multispan or multicospan.\n\nThe apex of a multi(co)span is the object that is the (co)domain of all the legs.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs-Tuple{Multispan, Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs","text":"Bundle together legs of a multi(co)span.\n\nFor example, calling bundle_legs(span, SVector((1,2),(3,4))) on a multispan with four legs gives a span whose left leg bundles legs 1 and 2 and whose right leg bundles legs 3 and 4. Note that in addition to bundling, this function can also permute legs and discard them.\n\nThe bundling is performed using the universal property of (co)products, which assumes that these (co)limits exist.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects","text":"Objects in diagram that will have explicit legs in colimit cocone.\n\nSee also: cone_objects.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects","text":"Objects in diagram that will have explicit legs in limit cone.\n\nIn category theory, it is common practice to elide legs of limit cones that can be computed from other legs, especially for diagrams of certain fixed shapes. For example, when it taking a pullback (the limit of a cospan), the limit object is often treated as having two projections, rather than three. This function encodes such conventions by listing the objects in the diagram that will have corresponding legs in the limit object created by Catlab.\n\nSee also: cocone_objects.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type","text":"Given a diagram in a category C, return Julia type of objects and morphisms in C as a tuple type of form TupleObHom.\n\n\n\n\n\n","category":"function"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.feet-Tuple{Multispan}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.feet","text":"Feet of multispan or multicospan.\n\nThe feet of a multispan are the codomains of the legs.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.left-Tuple{Multispan{Ob, Hom, <:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.left","text":"Left leg of span or cospan.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.legs","text":"Legs of multispan or multicospan.\n\nThe legs are the morphisms comprising the multi(co)span.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FreeDiagrams.right-Tuple{Multispan{Ob, Hom, <:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FreeDiagrams.right","text":"Right leg of span or cospan.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits","text":"Limits and colimits in a category.\n\n\n\n\n\n","category":"module"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.AbstractColimit","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.AbstractColimit","text":"Abstract type for colimit in a category.\n\nThe standard concrete subtype is Colimit, although for computational reasons certain categories may use different subtypes to include extra data.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.AbstractLimit","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.AbstractLimit","text":"Abstract type for limit in a category.\n\nThe standard concrete subtype is Limit, although for computational reasons certain categories may use different subtypes to include extra data.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.Colimit","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.Colimit","text":"Colimit in a category.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm","text":"Algorithm for computing colimits.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer","text":"Compute pushout by composing a coproduct with a coequalizer.\n\nSee also: ComposeProductEqualizer.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer","text":"Compute pullback by composing a product with an equalizer.\n\nSee also: ComposeCoproductCoequalizer.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.Limit","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.Limit","text":"Limit in a category.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.LimitAlgorithm","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.LimitAlgorithm","text":"Algorithm for computing limits.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.SpecializeColimit","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.SpecializeColimit","text":"Meta-algorithm that reduces general colimits to common special cases.\n\nDual to SpecializeLimit.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.SpecializeLimit","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.SpecializeLimit","text":"Meta-algorithm that reduces general limits to common special cases.\n\nReduces limits of free diagrams that happen to be discrete to products. If this fails, fall back to the given algorithm (if any).\n\nTODO: Reduce free diagrams that are (multi)cospans to (wide) pullbacks.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit","text":"Compute a colimit by reducing the diagram to a free bipartite diagram.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit","text":"Compute a limit by reducing the diagram to a free bipartite diagram.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.coimage-Tuple{Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.coimage","text":"https://en.wikipedia.org/wiki/Coimage\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.colimit","text":"Colimit of a diagram.\n\nTo define colimits in a category with objects Ob, override the method colimit(::FreeDiagram{Ob}) for general colimits or colimit(::D) with suitable type D <: FixedShapeFreeDiagram{Ob} for colimits of specific shape, such as coproducts or coequalizers.\n\nSee also: limit\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.epi_mono-Tuple{Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.epi_mono","text":"The image and coimage are isomorphic. We get this isomorphism using univeral properties.\n\n  CoIm′ ╌╌> I ↠ CoIm\n    ┆ ⌟     |\n    v       v\n    I   ⟶  R ↩ Im\n    |       ┆\n    v    ⌜  v\n    R ╌╌> Im′\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.image-Tuple{Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.image","text":"https://en.wikipedia.org/wiki/Image(categorytheory)#Second_definition\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.limit","text":"Limit of a diagram.\n\nTo define limits in a category with objects Ob, override the method limit(::FreeDiagram{Ob}) for general limits or limit(::D) with suitable type D <: FixedShapeFreeDiagram{Ob} for limits of specific shape, such as products or equalizers.\n\nSee also: colimit\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.pullback-Tuple{Any, Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.pullback","text":"Pullback of a pair of morphisms with common codomain.\n\nTo implement for a type T, define the method limit(::Cospan{T}) and/or limit(::Multicospan{T}) or, if you have already implemented products and equalizers, rely on the default implementation.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.pushout-Tuple{Any, Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.pushout","text":"Pushout of a pair of morphisms with common domain.\n\nTo implement for a type T, define the method colimit(::Span{T}) and/or colimit(::Multispan{T}) or, if you have already implemented coproducts and coequalizers, rely on the default implementation.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.coequalizer-Tuple{Any, Any}","page":"Categorical algebra","title":"Catlab.Theories.coequalizer","text":"Coequalizer of morphisms with common domain and codomain.\n\nTo implement for a type T, define the method colimit(::ParallelPair{T}) or colimit(::ParallelMorphisms{T}).\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.copair-Tuple{Any, Any}","page":"Categorical algebra","title":"Catlab.Theories.copair","text":"Copairing of morphisms: universal property of coproducts/pushouts.\n\nTo implement for coproducts of type T, define the method universal(::BinaryCoproduct{T}, ::Cospan{T}) and/or universal(::Coproduct{T}, ::Multicospan{T}) and similarly for pushouts.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.coproduct-Tuple{Any, Any}","page":"Categorical algebra","title":"Catlab.Theories.coproduct","text":"Coproduct of objects.\n\nTo implement for a type T, define the method colimit(::ObjectPair{T}) and/or colimit(::DiscreteDiagram{T}).\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.create-Tuple{T} where T","page":"Categorical algebra","title":"Catlab.Theories.create","text":"Unique morphism out of an initial object.\n\nTo implement for a type T, define the method universal(::Initial{T}, ::SMulticospan{0,T}).\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.delete-Tuple{T} where T","page":"Categorical algebra","title":"Catlab.Theories.delete","text":"Unique morphism into a terminal object.\n\nTo implement for a type T, define the method universal(::Terminal{T}, ::SMultispan{0,T}).\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.equalizer-Tuple{Any, Any}","page":"Categorical algebra","title":"Catlab.Theories.equalizer","text":"Equalizer of morphisms with common domain and codomain.\n\nTo implement for a type T, define the method limit(::ParallelPair{T}) and/or limit(::ParallelMorphisms{T}).\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.factorize-Tuple{Equalizer, Any}","page":"Categorical algebra","title":"Catlab.Theories.factorize","text":"Factor morphism through (co)equalizer, via the universal property.\n\nTo implement for equalizers of type T, define the method universal(::Equalizer{T}, ::SMultispan{1,T}). For coequalizers of type T, define the method universal(::Coequalizer{T}, ::SMulticospan{1,T}).\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.initial-Tuple{Type}","page":"Categorical algebra","title":"Catlab.Theories.initial","text":"Initial object.\n\nTo implement for a type T, define the method colimit(::EmptyDiagram{T}).\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.pair-Tuple{Any, Any}","page":"Categorical algebra","title":"Catlab.Theories.pair","text":"Pairing of morphisms: universal property of products/pullbacks.\n\nTo implement for products of type T, define the method universal(::BinaryProduct{T}, ::Span{T}) and/or universal(::Product{T}, ::Multispan{T}) and similarly for pullbacks.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.product-Tuple{Any, Any}","page":"Categorical algebra","title":"Catlab.Theories.product","text":"Product of objects.\n\nTo implement for a type T, define the method limit(::ObjectPair{T}) and/or limit(::DiscreteDiagram{T}).\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.terminal-Tuple{Type}","page":"Categorical algebra","title":"Catlab.Theories.terminal","text":"Terminal object.\n\nTo implement for a type T, define the method limit(::EmptyDiagram{T}).\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.universal","page":"Categorical algebra","title":"Catlab.Theories.universal","text":"Universal property of (co)limits.\n\nCompute the morphism whose existence and uniqueness is guaranteed by the universal property of (co)limits.\n\nSee also: limit, colimit.\n\n\n\n\n\n","category":"function"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance-Tuple{Any, Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance","text":"Define cartesian monoidal structure using limits.\n\nImplements an instance of ThCartesianCategory assuming that finite products have been implemented following the limits interface.\n\n\n\n\n\n","category":"macro"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance-Tuple{Any, Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance","text":"Define cocartesian monoidal structure using colimits.\n\nImplements an instance of ThCocartesianCategory assuming that finite coproducts have been implemented following the colimits interface.\n\n\n\n\n\n","category":"macro"},{"location":"apis/categorical_algebra/#Categories","page":"Categorical algebra","title":"Categories","text":"","category":"section"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"Modules = [\n   CategoricalAlgebra.Categories,\n   CategoricalAlgebra.FinCats,\n]","category":"page"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories","text":"2-category of categories, functors, and natural transformations.\n\nCategories in mathematics appear in the large, often as categories of sets with extra structure, and in the small, as algebraic structures that generalize groups, monoids, preorders, and graphs. This division manifests in Catlab as well. Large categories (in spirit, if not in the technical sense) occur throughout Catlab as @instances of the theory of categories. For computational reasons, small categories are usually presented by generators and relations.\n\nThis module provides a minimal interface to accomodate both situations. Category instances are supported through the wrapper type TypeCat. Finitely presented categories are provided by another module, FinCats.\n\n\n\n\n\n","category":"module"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.Cat","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.Cat","text":"Alias for Category.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.CatSize","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.CatSize","text":"Size of a category, used for dispatch and subtyping purposes.\n\nA Category type having a particular CatSize means that categories of that type are at most that large.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.Category","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.Category","text":"Abstract base type for a category.\n\nThe objects and morphisms in the category have Julia types Ob and Hom, respectively. Note that these types do not necessarily form an @instance of the theory of categories, as they may not meaningfully form a category outside the context of this object. For example, a finite category regarded as a reflexive graph with a composition operation might have type Cat{Int,Int}, where the objects and morphisms are numerical identifiers for vertices and edges in the graph.\n\nThe basic operations available in any category are: dom, codom, id, compose.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.CompositeFunctor","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.CompositeFunctor","text":"Composite of functors.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.Functor","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.Functor","text":"Abstract base type for a functor between categories.\n\nA functor has a domain and a codomain (dom and codom), which are categories, and object and morphism maps, which can be evaluated using ob_map and hom_map. The functor object can also be called directly when the objects and morphisms have distinct Julia types. This is sometimes but not always the case (see Category), so when writing generic code one should prefer the ob_map and hom_map functions.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.FunctorCallable","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.FunctorCallable","text":"Functor defined by two Julia callables, an object map and a morphism map.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.IdentityFunctor","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.IdentityFunctor","text":"Identity functor on a category.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.LargeCatSize","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.LargeCatSize","text":"Size of a large category, such as Set.\n\nTo the extent that they form a category, we regard Julia types and functions (TypeCat) as forming a large category.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.OppositeCat","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.OppositeCat","text":"Opposite category, where morphism are reversed.\n\nCall op(::Cat) instead of directly instantiating this type.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.OppositeFunctor","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.OppositeFunctor","text":"Opposite functor, given by the same mapping between opposite categories.\n\nCall op(::Functor) instead of directly instantiating this type.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.Transformation","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.Transformation","text":"Abstract base type for a natural transformation between functors.\n\nA natural transformation α F  G has a domain F and codomain G (dom and codom), which are functors FG C  D having the same domain C and codomain D. The transformation consists of a component αₓ Fx  Gx in D for each object x  C, accessible using component or indexing notation (Base.getindex).\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.TypeCat","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.TypeCat","text":"Pair of Julia types regarded as a category.\n\nThe Julia types should form an @instance of the theory of categories (Theories.Category).\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#ACSets.Schemas.codom-Tuple{Category, Any}","page":"Categorical algebra","title":"ACSets.Schemas.codom","text":"Codomain of morphism in category.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#ACSets.Schemas.dom-Tuple{Category, Any}","page":"Categorical algebra","title":"ACSets.Schemas.dom","text":"Domain of morphism in category.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#ACSets.Schemas.hom","page":"Categorical algebra","title":"ACSets.Schemas.hom","text":"Coerce or look up morphism in category.\n\nSee also: ob.\n\n\n\n\n\n","category":"function"},{"location":"apis/categorical_algebra/#ACSets.Schemas.ob","page":"Categorical algebra","title":"ACSets.Schemas.ob","text":"Coerce or look up object in category.\n\nConverts the input to an object in the category, which should be of type Ob in a category of type Cat{Ob,Hom}. How this works depends on the category, but a common case is to look up objects, which might be integers or GAT expressions, by their human-readable name, usually a symbol.\n\nSee also: hom.\n\n\n\n\n\n","category":"function"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.co","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.co","text":"2-cell dual of a 2-category.\n\n\n\n\n\n","category":"function"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.codom_ob-Tuple{Transformation}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.codom_ob","text":"Codomain object of natural transformation.\n\nGiven α F  G C  D, this function returns D.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.component","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.component","text":"Component of natural transformation.\n\n\n\n\n\n","category":"function"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.dom_ob-Tuple{Transformation}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.dom_ob","text":"Domain object of natural transformation.\n\nGiven α F  G C  D, this function returns C.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.hom_map-Tuple{Functor, Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.hom_map","text":"Evaluate functor on morphism.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.is_hom_equal-Tuple{Category, Any, Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.is_hom_equal","text":"Are two morphisms in a category equal?\n\nBy default, just checks for equality of Julia objects using ==. In some categories, checking equality of morphisms may involve nontrivial reasoning.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.ob_map-Tuple{Functor, Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.ob_map","text":"Evaluate functor on object.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Categories.op-Tuple{Category}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Categories.op","text":"Oppositization 2-functor.\n\nThe oppositization endo-2-functor on Cat, sending a category to its opposite, is covariant on objects and morphisms and contravariant on 2-morphisms, i.e., is a 2-functor op Catᶜᵒ  Cat. For more explanation, see the nLab.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.compose-Tuple{Category, Vararg{Any}}","page":"Categorical algebra","title":"Catlab.Theories.compose","text":"Compose morphisms in a category.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.Theories.id-Tuple{Category, Any}","page":"Categorical algebra","title":"Catlab.Theories.id","text":"Identity morphism on object in category.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats","text":"2-category of finitely presented categories.\n\nThis module is for the 2-category Cat what the module FinSets is for the category Set: a finitary, combinatorial setting where explicit calculations can be carried out. We emphasize that the prefix Fin means \"finitely presented,\" not \"finite,\" as finite categories are too restrictive a notion for many purposes. For example, the free category on a graph is finite if and only if the graph is DAG, which is a fairly special condition. This usage of Fin is also consistent with FinSet because for sets, being finite and being finitely presented are equivalent.\n\n\n\n\n\n","category":"module"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.FinCat","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.FinCat","text":"A finitely presented (but not necessarily finite!) category.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.FinCatGraph","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.FinCatGraph","text":"Abstract type for category backed by finite generating graph.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq","text":"Category presented by a finite graph together with path equations.\n\nThe objects of the category are vertices in the graph and the morphisms are paths, quotiented by the congruence relation generated by the path equations. See (Spivak, 2014, Category theory for the sciences, §4.5).\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph","text":"Abstract type for category whose morphisms are paths in a graph.\n\n(Or equivalence classes of paths in a graph, but we compute with\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.FinCatPresentation","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.FinCatPresentation","text":"Category defined by a Presentation object.\n\nThe presentation type can, of course, be a category (Theories.Category). It can also be a schema (Theories.Schema). In this case, the schema's objects and attribute types are regarded as the category's objects and the schema's morphisms, attributes, and attribute types as the category's morphisms (where the attribute types are identity morphisms). When the schema is formalized as a profunctor whose codomain category is discrete, this amounts to taking the collage of the profunctor.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.FinCatSize","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.FinCatSize","text":"Size of a finitely presented category.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.FinDomFunctor","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.FinDomFunctor","text":"A functor out of a finitely presented category.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap","text":"Functor out of a finitely presented category given by explicit mappings.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.FinFunctor","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.FinFunctor","text":"A functor between finitely presented categories.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.FinTransformation","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.FinTransformation","text":"A natural transformation whose domain category is finitely generated.\n\nThis type is for natural transformations α F  G C  D such that the domain category C is finitely generated. Such a natural transformation is given by a finite amount of data (one morphism in D for each generating object of C) and its naturality is verified by finitely many equations (one equation for each generating morphism of C).\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.FinTransformationMap","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.FinTransformationMap","text":"Natural transformation with components given by explicit mapping.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.FreeCatGraph","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.FreeCatGraph","text":"Free category generated by a finite graph.\n\nThe objects of the free category are vertices in the graph and the morphisms are (possibly empty) paths.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.Path","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.Path","text":"Path in a graph.\n\nThe path is allowed to be empty but always has definite start and end points (source and target vertices).\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.collect_hom-Tuple{Functor{Dom} where Dom<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.collect_hom","text":"Collect assignments of functor's morphism map as a vector.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.collect_ob-Tuple{Functor{Dom} where Dom<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.collect_ob","text":"Collect assignments of functor's object map as a vector.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.components-Tuple{Transformation{C, D, Dom, Codom} where {C<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D<:Category, Dom<:(Functor{Dom} where Dom<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom<:(Functor{Dom} where Dom<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.components","text":"Components of a natural transformation.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.force","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.force","text":"Force evaluation of lazily defined function or functor.\n\n\n\n\n\n","category":"function"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.functoriality_failures-Tuple{Functor{Dom} where Dom<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.functoriality_failures","text":"Failures of the purported functor on a presented category to be functorial.\n\nSimilar to is_functorial (and with the same caveats) but returns iterators of functoriality failures: one for domain incompatibilities, one for codomain incompatibilities, and one for equations that are not satisfied.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.graph-Tuple{FinCatGraph}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.graph","text":"Generating graph for a finitely presented category.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.hom_generator","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.hom_generator","text":"Coerce or look up morphism generator in a finitely presented category.\n\nSince morphism generators often have a different data type than morphisms (e.g., in a free category on a graph, the morphism generators are edges and the morphisms are paths), the return type of this function is generally different than that of hom.\n\n\n\n\n\n","category":"function"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.hom_generator_name","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.hom_generator_name","text":"Name of morphism generator, if any.\n\nWhen morphism generators have names, this function is a one-sided inverse to hom_generator. See also: ob_generator_name.\n\n\n\n\n\n","category":"function"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.hom_generators","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.hom_generators","text":"Morphism generators of finitely presented category.\n\n\n\n\n\n","category":"function"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.is_discrete-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.is_discrete","text":"Is the category discrete?\n\nA category is discrete if it is has no non-identity morphisms.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.is_free-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.is_free","text":"Is the category freely generated?\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.is_functorial-Tuple{Functor{Dom} where Dom<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.is_functorial","text":"Is the purported functor on a presented category functorial?\n\nThis function checks that functor preserves domains and codomains. When check_equations is true (the default is false), it also purports to check that the functor preserves all equations in the domain category. No nontrivial  checks are currently implemented, so this only functions for identity functors.\n\nSee also: `functoriality_failures' and is_natural.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.is_initial-Tuple{Functor{Dom, Codom} where {Dom<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.is_initial","text":"Dual to a final functor, an initial functor is one for which pulling back diagrams along it does not change the limits of these diagrams.\n\nThis amounts to checking, for a functor C->D, that, for every object d in Ob(D), the comma category (F/d) is connected.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D<:Category, Dom<:(Functor{Dom} where Dom<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom<:(Functor{Dom} where Dom<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.is_natural","text":"Is the transformation between FinDomFunctors a natural transformation?\n\nThis function uses the fact that to check whether a transformation is natural, it suffices to check the naturality equations on a generating set of morphisms of the domain category. In some cases, checking the equations may be expensive or impossible. When the keyword argument check_equations is false, only the domains and codomains of the components are checked.\n\nSee also: is_functorial.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.ob_generator","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.ob_generator","text":"Coerce or look up object generator in a finitely presented category.\n\nBecause object generators usually coincide with objects, the default method for ob in finitely presented categories simply calls this function.\n\n\n\n\n\n","category":"function"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.ob_generator_name","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.ob_generator_name","text":"Name of object generator, if any.\n\nWhen object generators have names, this function is a one-sided inverse to ob_generator in that ob_generator(C, ob_generator_name(C, x)) == x.\n\n\n\n\n\n","category":"function"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.ob_generators","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.ob_generators","text":"Object generators of finitely presented category.\n\nThe object generators of finite presented category are almost always the same as the objects. In principle, however, it is possible to have equations between objects, so that there are fewer objects than object generators.\n\n\n\n\n\n","category":"function"},{"location":"apis/categorical_algebra/#Acsets","page":"Categorical algebra","title":"Acsets","text":"","category":"section"},{"location":"apis/categorical_algebra/#Overview-and-Theory","page":"Categorical algebra","title":"Overview and Theory","text":"","category":"section"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"For an in depth look into the theory behind acsets, we refer the reader to our paper on the subject, which also gives some sense as to how the implementation works. Here, we give a brief tutorial before the the API documentation.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"The most essential part of the acset machinery is the schema. The schema parameterizes the acset: each schema corresponds to a different type of acset. Schemas consist of four parts.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"Objects XY ((X,Y,Z)::Ob)\nHomomorphisms f colon X to Y (f :: Hom(X,Y)), which go from objects to objects\nAttribute types mathttT (T :: AttrType)\nAttributes a colon X to mathttT (a :: Attr(X,T)), which go from objects to data types","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"For those with a categorical background, a schema is a presentation of a category S along with a functor S from S to the arrow category 0 to 1, such that S^-1(1) is discrete.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"An acset F on a schema consists of...","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"a set F(X) of \"primary keys\" for each object\na function F(f) colon F(X) to F(Y) for each morphism\na Julia data type F(mathttT) for each data type mathttT\na function F(a) colon F(X) to F(mathttT) for each attribute a.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"For those with a categorical background, an acset on a schema S consists of a functor from S to mathsfSet, such that objects in S^-1(0) map to finite sets, and objects in S^-1(1) map to sets that represent types. For any particular functor K colon S^-1(1) to mathsfSet, we can also take the category of acsets that restrict to this map on S^-1.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"We can also add equations to this presentation, but we currently do nothing with those equations in the implementation; they mostly serve as documentation.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"We will now give an example of how this all works in practice.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"using Catlab.GATs, Catlab.CategoricalAlgebra\n\n# Write down the schema for a weighted graph\n@present SchWeightedGraph(FreeSchema) begin\n  V::Ob\n  E::Ob\n  src::Hom(E,V)\n  tgt::Hom(E,V)\n  T::AttrType\n  weight::Attr(E,T)\nend\n\n# Construct the type used to store acsets on the previous schema\n# We *index* src and tgt, which means that we store not only\n# the forwards map, but also the backwards map.\n@acset_type WeightedGraph(SchWeightedGraph, index=[:src,:tgt])\n\n# Construct a weighted graph, with floats as edge weights\ng = @acset WeightedGraph{Float64} begin\n  V = 4\n  E = 5\n  src = [1,1,1,2,3]\n  tgt = [2,3,4,4,4]\n  weight = [7.2, 9.3, 9.4, 0.1, 42.0]\nend","category":"page"},{"location":"apis/categorical_algebra/#API","page":"Categorical algebra","title":"API","text":"","category":"section"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"The mathematical abstraction of an acset can of course be implemented in many different ways. Currently, there are three implementations of acsets in Catlab, which share a great deal of code.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"These implementations can be split into two categories.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"The first category is static acset types. In this implementation, different schemas correspond to different Julia types. Methods on these Julia types are then custom-generated for the schema, using CompTime.jl.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"Under this category, there are two classes of static acset types. The first class is acset types that are generated using the @acset_type macro. These acset types are custom-derived structs. The advantage of this is that the structs have names like Graph or WiringDiagram that are printed out in error messages. The disadvantage is that if you are taking in schemas at runtime, you have to eval code in order to use them.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"Here is an example of using @acset_type","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"@acset_type WeightedGraph(SchWeightedGraph, index=[:src,:tgt])\ng = WeightedGraph()","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"The second class is AnonACSets. Like acset types derived from @acset_type, these contain the schema in their type. However, they also contain the type of their fields in their types, so the types printed out in error messages are long and ugly. The advantage of these is that they can be used in situations where the schema is passed in at runtime, and they don't require using eval to create a new acset type.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"Here is an example of using AnonACSet","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"const WeightedGraph = AnonACSetType(SchWeightedGraph, index=[:src,:tgt])\ng = WeightedGraph()","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"The second category is dynamic acset types. Currently, there is just one type that falls under this category: DynamicACSet. This type has a field for the schema, and no code-generation is done for operations on acsets of this type. This means that if the schema is large compared to the data, this type will often be faster than the static acsets.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"However, dynamics acsets are a new addition to Catlab, and much of the machinery of limits, colimits, and other high-level acset constructions assumes that the schema of an acset can be derived from the type. Thus, more work will have to be done before dynamic acsets become a drop-in replacement for static acsets.","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"Here is an example of using a dynamic acset","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"g = DynamicACSet(\"WeightedGraph\", SchWeightedGraph; index=[:src,:tgt])","category":"page"},{"location":"apis/categorical_algebra/","page":"Categorical algebra","title":"Categorical algebra","text":"Modules = [\n  CategoricalAlgebra.CSets,\n  CategoricalAlgebra.DataMigrations,\n  CategoricalAlgebra.Chase,\n  CategoricalAlgebra.StructuredCospans,\n]\nPrivate = false","category":"page"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets","text":"Categories of C-sets and attributed C-sets.\n\n\n\n\n\n","category":"module"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.ACSetHomomorphismAlgorithm","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.ACSetHomomorphismAlgorithm","text":"Algorithm for finding homomorphisms between attributed C-sets.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.ACSetTransformation","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.ACSetTransformation","text":"Transformation between attributed C-sets.\n\nHomomorphisms of attributed C-sets generalize homomorphisms of C-sets (CSetTransformation), which you should understand before reading this.\n\nA homomorphism of attributed C-sets with schema S: C ↛ A (a profunctor) is a natural transformation between the corresponding functors col(S) → Set, where col(S) is the collage of S. When the components on attribute types, indexed by objects of A, are all identity functions, the morphism is called tight; in general, it is called loose. With this terminology, acsets on a fixed schema are the objects of an ℳ-category (see Catlab.Theories.MCategory). Calling ACSetTransformation will construct a tight or loose morphism as appropriate, depending on which components are specified.\n\nSince every tight morphism can be considered a loose one, the distinction between tight and loose may seem a minor technicality, but it has important consequences because limits and colimits in a category depend as much on the morphisms as on the objects. In particular, limits and colimits of acsets differ greatly depending on whether they are taken in the category of acsets with tight morphisms or with loose morphisms. Tight morphisms suffice for many purposes, including most applications of colimits. However, when computing limits of acsets, loose morphisms are usually preferable. For more information about limits and colimits in these categories, see TightACSetTransformation and LooseACSetTransformation.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{ACSet, ACSet}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.ACSetTransformation","text":"Move components as first argument\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{StructACSet}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.ACSetTransformation","text":"A map f (from A to B) as a map from A to a subobject of B\n\ni.e. get the image of f as a subobject of B\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{Subobject{<:StructACSet{S}} where S}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.ACSetTransformation","text":"A map f (from A to B) as a map of subobjects of A to subjects of B\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.BacktrackingSearch","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.BacktrackingSearch","text":"Find attributed C-set homomorphisms using backtracking search.\n\nThis procedure uses the classic backtracking search algorithm for a combinatorial constraint satisfaction problem (CSP). As is well known, the homomorphism problem for relational databases is reducible to CSP. Since the C-set homomorphism problem is \"the same\" as the database homomorphism problem (insofar as attributed C-sets are \"the same\" as relational databases), it is also reducible to CSP. Backtracking search for CSP is described in many computer science textbooks, such as (Russell & Norvig 2010, Artificial Intelligence, Third Ed., Chapter 6: Constraint satisfaction problems, esp. Algorithm 6.5). In our implementation, the search tree is ordered using the popular heuristic of \"minimum remaining values\" (MRV), also known as \"most constrained variable.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.CSetTransformation","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.CSetTransformation","text":"Transformation between C-sets.\n\nRecall that a C-set homomorphism is a natural transformation: a transformation between functors C → Set satisfying the naturality axiom for every morphism, or equivalently every generating morphism, in C.\n\nThis data type records the data of a C-set transformation. Naturality is not strictly enforced but is expected to be satisfied. It can be checked using the function is_natural.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.HomomorphismQuery","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.HomomorphismQuery","text":"Find attributed C-set homomorphisms using a conjunctive query.\n\nThis algorithm evaluates a conjunctive query (limit in FinSet) to find all homomorphisms between two C-sets. In fact, conjunctive queries are exactly the representable functors from C-sets to sets, so every conjunctive query arises in this way, with the caveat that conjunctive queries may correspond to to infinite C-sets when C is infinite (but possibly finitely presented).\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.LooseACSetTransformation","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.LooseACSetTransformation","text":"Loose transformation between attributed C-sets.\n\nLimits and colimits in the category of attributed C-sets and loose homomorphisms are computed pointwise on both objects and attribute types. This implies that (co)limits of Julia types must be computed. Due to limitations in the expressivity of Julia's type system, only certain simple kinds of (co)limits, such as products, are supported.\n\nAlternatively, colimits involving loose acset transformations can be constructed with respect to explicitly given attribute type components for the legs of the cocone, via the keyword argument type_components to colimit and related functions. This uses the universal property of the colimit. To see how this works, notice that a diagram of acsets and loose acset transformations can be expressed as a diagram D: J → C-Set (for the C-sets) along with another diagram A: J → C-Set (for the attribute sets) and a natural transformation α: D ⇒ A (assigning attributes). Given a natural transformation τ: A ⇒ ΔB to a constant functor ΔB, with components given by type_components, the composite transformation α⋅τ: D ⇒ ΔB is a cocone under D, hence factors through the colimit cocone of D. This factoring yields an assigment of attributes to the colimit in C-Set.\n\nFor the distinction between tight and loose, see ACSetTranformation.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.SubCSet","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.SubCSet","text":"Sub-C-set of a C-set.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.TightACSetTransformation","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.TightACSetTransformation","text":"Tight transformation between attributed C-sets.\n\nThe category of attributed C-sets and tight homomorphisms is isomorphic to a slice category of C-Set, as explained in our paper \"Categorical Data Structures for Technical Computing\". Colimits in this category thus reduce to colimits of C-sets, by a standard result about slice categories. Limits are more complicated and are currently not supported.\n\nFor the distinction between tight and loose, see ACSetTranformation.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#ACSets.ACSetInterface.copy_parts!-Tuple{ACSet, Functor{Dom} where Dom<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}","page":"Categorical algebra","title":"ACSets.ACSetInterface.copy_parts!","text":"Copy parts from a set-valued FinDomFunctor to an ACSet.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.abstract_attributes-Tuple{ACSet}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.abstract_attributes","text":"For any ACSet, X, a canonical map A→X where A has distinct variables for all subparts.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{ACSet, ACSet}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.homomorphism","text":"Find a homomorphism between two attributed C-sets.\n\nReturns nothing if no homomorphism exists. For many categories C, the C-set homomorphism problem is NP-complete and thus this procedure generally runs in exponential time. It works best when the domain object is small.\n\nTo restrict to monomorphisms, or homomorphisms whose components are all injective functions, set the keyword argument monic=true. To restrict only certain components to be injective or bijective, use monic=[...] or iso=[...]. For example, setting monic=[:V] for a graph homomorphism ensures that the vertex map is injective but imposes no constraints on the edge map.\n\nTo restrict the homomorphism to a given partial assignment, set the keyword argument initial. For example, to fix the first source vertex to the third target vertex in a graph homomorphism, set initial=(V=Dict(1 => 3),). Use  the keyword argument type_components to specify nontrivial components on  attribute types for a loose homomorphism. These components must be callable: either Julia functions on the appropriate types or FinFunction(Dict(...)).\n\nUse the keyword argument alg to set the homomorphism-finding algorithm. By default, a backtracking search algorithm is used (BacktrackingSearch). Use the keyword argument error_failures = true to get errors explaining  any immediate inconsistencies in specified initial data.\n\nSee also: homomorphisms, isomorphism.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.homomorphisms-Tuple{ACSet, ACSet}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.homomorphisms","text":"Find all homomorphisms between two attributed C-sets.\n\nThis function is at least as expensive as homomorphism and when no homomorphisms exist, it is exactly as expensive.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.is_homomorphic-Tuple{ACSet, ACSet}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.is_homomorphic","text":"Is the first attributed C-set homomorphic to the second?\n\nThis function generally reduces to homomorphism but certain algorithms may have minor optimizations.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.is_isomorphic-Tuple{ACSet, ACSet}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.is_isomorphic","text":"Are the two attributed C-sets isomorphic?\n\nThis function generally reduces to isomorphism but certain algorithms may have minor optimizations.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{ACSet, ACSet}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.isomorphism","text":"Find an isomorphism between two attributed C-sets, if one exists.\n\nSee homomorphism for more information about the algorithms involved.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.isomorphisms-Tuple{ACSet, ACSet}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.isomorphisms","text":"Find all isomorphisms between two attributed C-sets.\n\nThis function is at least as expensive as isomorphism and when no homomorphisms exist, it is exactly as expensive.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.maximum_common_subobject-Union{Tuple{Vector{T}}, Tuple{T}} where T<:ACSet","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.maximum_common_subobject","text":"Compute the Maximimum Common C-Sets from a vector of C-Sets.\n\nFind an ACSet `a with maximum possible size (a) such that there is a   monic span of ACSets a₁  a  a₂. There may be many maps from this overlap  into each of the inputs, so a Vector{Vector{ACSetTransformations}} per overlap  is returned (a cartesian product can be taken of these to obtain all possible  multispans for that overlap). If there are multiple overlaps of equal size,  these are all returned.\n\nIf there are attributes, we ignore these and use variables in the apex of the  overlap.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.naturality_failures-Tuple{Any, Any, Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.naturality_failures","text":"Returns a dictionary whose keys are contained in the names in arrows(S) and whose value at :f, for an arrow (f,c,d), is a lazy iterator over the elements of X(c) on which α's naturality square for f does not commute. Components should be a NamedTuple or Dictionary with keys contained in the names of S's morphisms and values vectors or dicts defining partial functions from X(c) to Y(c).\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.show_naturality_failures-Tuple{IO, AbstractDict}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.show_naturality_failures","text":"Pretty-print failures of transformation to be natural.\n\nSee also: naturality_failures.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.subobject_graph-Tuple{ACSet}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.subobject_graph","text":"Preorder of subobjects via inclusion.  Returns a graph + list of subobjects corresponding to its vertices.  The subobjects are ordered by decreasing size (so it's topologically sorted)\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{LooseACSetTransformation}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.FinCats.is_natural","text":"Check naturality condition for a purported ACSetTransformation, α: X→Y.  For each hom in the schema, e.g. h: m → n, the following square commute must:\n\n     αₘ\n  Xₘ --> Yₘ\nXₕ ↓  ✓  ↓ Yₕ\n  Xₙ --> Yₙ\n     αₙ\n\nYou're allowed to run this on a named tuple partly specifying an ACSetTransformation, though at this time the domain and codomain must be fully specified ACSets.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.CSets.@acset_transformation-Tuple{Any, Any, Vararg{Any}}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.CSets.@acset_transformation","text":"Provides a shorthand for constructing a tight acset transformation by giving its components. Homomorphism search allows partial specification, with the return value being the unique extension if it exists.\n\nKeyword arguments can be passed on to the search function after the body of the transformation.\n\nExample usage for transformation between WeightedGraph{String}:\n\n@acset_transformation A B begin\n  V = [3,5,2] #complete specification can be a vector\n  E = Dict(1 => 3, 4 => 3) #otherwise use a dict\nend monic=true iso=[:V] or [:V,:E], etc\n\n\n\n\n\n","category":"macro"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.DataMigrations","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.DataMigrations","text":"Functorial data migration for attributed C-sets.\n\n\n\n\n\n","category":"module"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.DataMigrations.DataMigrationFunctor","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.DataMigrations.DataMigrationFunctor","text":"Data migration functor given contravariantly. Stores a contravariant migration.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.DataMigrations.colimit_representables-Tuple{Catlab.CategoricalAlgebra.DataMigrations.ContravariantMigration{<:Functor{D, C}} where {D<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), C<:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}, Any}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.DataMigrations.colimit_representables","text":"Interpret conjunctive data migration as a colimit of representables.\n\nGiven a conjunctive data migration (a functor J → Diag{op}(C)) and the Yoneda embedding for C (a functor op(C) → C-Set computed via yoneda), take colimits of representables to construct a op(J)-shaped diagram of C-sets.\n\nSince every C-set is a colimit of representables, this is a generic way of constructing diagrams of C-sets.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.DataMigrations.internal_hom-Union{Tuple{T}, Tuple{T, T, Presentation{ThSchema}}} where T<:ACSet","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.DataMigrations.internal_hom","text":"Objects: Fᴳ(c) = C-Set(C × G, F)    where C is the representable c\n\nGiven a map f: a->b, we compute that f(Aᵢ) = Bⱼ by constructing the following:           Aᵢ     A × G → F   f*↑ ↑ ↑ ↗ Bⱼ       find the hom Bⱼ that makes this commute     B × G \n\nwhere f* is given by yoneda.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.DataMigrations.migrate!-Tuple{ACSet, ACSet, Catlab.CategoricalAlgebra.DataMigrations.AbstractDataMigration}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.DataMigrations.migrate!","text":"Contravariantly migrate data from the acset Y to the acset X.\n\nThis is the mutating variant of migrate!. When the functor on schemas is the identity, this operation is equivalent to copy_parts!.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.DataMigrations.migrate-Union{Tuple{T}, Tuple{Type{T}, ACSet, Catlab.CategoricalAlgebra.DataMigrations.AbstractDataMigration}} where T<:ACSet","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.DataMigrations.migrate","text":"Contravariantly migrate data from the acset Y to a new acset of type T.\n\nThe mutating variant of this function is migrate!.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.DataMigrations.representable-Tuple{Any, Presentation{ThSchema}, Symbol}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.DataMigrations.representable","text":"Construct a representable C-set.\n\nRecall that a representable C-set is one of form C(c-) C  Set for some object c  C.\n\nThis function computes the c representable as the left pushforward data migration of the singleton c-set along the inclusion functor c  C, which works because left Kan extensions take representables to representables (Mac Lane 1978, Exercise X.3.2). Besides the intrinsic difficulties with representables (they can be infinite), this function thus inherits any limitations of our implementation of left pushforward data migrations.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.DataMigrations.representable-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T<:StructACSet","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.DataMigrations.representable","text":"ACSet types do not store info about equations, so this info is lost when we try to recover the presentation from the datatype. Thus, this method for  representable should only be used for free schemas\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.DataMigrations.subobject_classifier-Tuple{Type, Presentation{ThSchema}}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.DataMigrations.subobject_classifier","text":"The subobject classifier Ω in a presheaf topos is the presheaf that sends each  object A to the set of sieves on it (equivalently, the set of subobjects of the  representable presheaf for A). Counting subobjects gives us the number of A  parts; the hom data for f:A->B for subobject Aᵢ is determined via:\n\nAᵢ ↪ A  ↑    ↑ f*   PB⌝↪ B          (PB picks out a subobject of B, up to isomorphism.)\n\n(where A and B are the representables for objects A and B and f* is the unique  map from B into the A which sends the point of B to f applied to the point of A)\n\nReturns the classifier as well as a dictionary of subobjects corresponding to  the parts of the classifier.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.DataMigrations.yoneda-Tuple{Any, Presentation{ThSchema}}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.DataMigrations.yoneda","text":"Compute the Yoneda embedding of a category C in the category of C-sets.\n\nBecause Catlab privileges copresheaves (C-sets) over presheaves, this is the contravariant Yoneda embedding, i.e., the embedding functor C^op → C-Set.\n\nThe first argument cons is a constructor for the ACSet, such as a struct acset type. If representables have already been computed (which can be expensive), they can be supplied via the cache keyword argument.\n\nReturns a FinDomFunctor with domain op(C).\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Chase","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Chase","text":"The chase is an algorithm which subjects a C-Set instance to constraints  expressed in the language of regular logic, called embedded dependencies  (EDs, or 'triggers'). \n\nA morphism S->T, encodes an embedded dependency. If the pattern  S is matched (via a homomorphism S->I), we demand there exist a morphism T->I  (for some database instance I) that makes the triangle commute in order to  satisfy the dependency (if this is not the case, then the trigger is 'active').\n\nHomomorphisms can merge elements and introduce new ones. The former kind are called \"equality generating dependencies\" (EGDs) and the latter \"tuple generating dependencies\" (TGDs). Any homomorphism can be factored into EGD and TGD components by, respectively, restricting the codomain to the image or restricting the domain to the coimage.\n\n\n\n\n\n","category":"module"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.Chase.chase-Tuple{ACSet, AbstractDict, Int64}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.Chase.chase","text":"chase(I::ACSet, Σ::AbstractDict, n::Int)\n\nChase a C-Set or C-Rel instance given a list of embedded dependencies. This may not terminate, so a bound n on the number of iterations is required.\n\n[,]\n\nΣS  ⟶ Iₙ ⊕↓      ⋮  (resulting morphism)  ΣT ... Iₙ₊₁\n\nThere is a copy of S and T for each active trigger. A trigger is a map from S into the current instance. What makes it 'active' is that there is no morphism from T to I that makes the triangle commute.\n\nEach iteration constructs the above pushout square. The result is a morphism, so that one can keep track of the provenance of elements in the original CSet instance within the chased result.\n\nWhether or not the result is due to success or timeout is returned as a boolean flag.\n\nTODO: this algorithm could be made more efficient by homomorphism caching.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.StructuredCospans","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.StructuredCospans","text":"Structured cospans.\n\nThis module provides a generic interface for structured cospans with a concrete implementation for attributed C-sets.\n\n\n\n\n\n","category":"module"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetLeg","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetLeg","text":"Leg of a structured (multi)cospan of acsets in R-form.\n\nA convenience type that contains the data of an acset transformation, except for the codomain, since that data is already given by the decoration of the R-form structured cospan.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan","text":"Structured cospan.\n\nThe first type parameter L encodes a functor L: A → X from the base category A, often FinSet, to a category X with \"extra structure.\" An L-structured cospan is then a cospan in X whose feet are images under L of objects in A. The category X is assumed to have pushouts.\n\nStructured cospans form a double category with no further assumptions on the functor L. To obtain a symmetric monoidal double category, L must preserve finite coproducts. In practice, L usually has a right adjoint R: X → A, which implies that L preserves all finite colimits. It also allows structured cospans to be constructed more conveniently from an object x in X plus a cospan in A with apex R(x).\n\nSee also: StructuredMulticospan.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Any, Multicospan{Ob, Hom, <:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}} where L","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan","text":"Construct structured cospan in R-form.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Multicospan{Ob, Hom, <:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}, StaticArraysCore.StaticArray{Tuple{2}, T, 1} where T}} where L","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan","text":"Construct structured cospan in L-form.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb","text":"Object in the category of L-structured cospans.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan","text":"Structured multicospan.\n\nA structured multicospan is like a structured cospan except that it may have a number of legs different than two.\n\nSee also: StructuredCospan.\n\n\n\n\n\n","category":"type"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan-Union{Tuple{L}, Tuple{Any, Multicospan}} where L","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan","text":"Construct structured multicospan in R-form.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S, X<:(StructACSet{S})}","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes","text":"Create types for open attributed C-sets from an attributed C-set type.\n\nThe type parameters of the given acset type should not be instantiated with specific Julia types. This function returns a pair of types, one for objects, a subtype of StructuredCospanOb, and one for morphisms, a subtype of StructuredMulticospan. Both types will have the same type parameters for attribute types as the given acset type.\n\nMathematically speaking, this function sets up structured (multi)cospans with a functor L A  X between categories of acsets that creates \"discrete acsets.\" Such a \"discrete acset functor\" is a functor that is left adjoint to a certain kind of forgetful functor between categories of acsets, namely one that is a pullback along an inclusion of schemas such that the image of inclusion has no outgoing arrows. For example, the schema inclusion V  E  V has this property but E  E  V does not.\n\nSee also: OpenCSetTypes.\n\n\n\n\n\n","category":"method"},{"location":"apis/categorical_algebra/#Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{Type{X}, Vararg{Any}}} where X<:(StructCSet)","page":"Categorical algebra","title":"Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes","text":"Create types for open C-sets from a C-set type.\n\nA special case of OpenACSetTypes. See there for details.\n\n\n\n\n\n","category":"method"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"EditURL = \"../../../literate/sketches/preorders.jl\"","category":"page"},{"location":"generated/sketches/preorders/#Preorders","page":"Preorders","title":"Preorders","text":"","category":"section"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"(Image: )","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"Many of the ideas in category theory can be viewed as generalizations of preorders or monoids. This sketch shows some features of Catlab through the lens of preorders. You will see examples of defining GATs, Presentations, Syntax, and Functors. These are illustrated with preorders or thin categories, which are particularly simple cases of categories.","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"using Core: GeneratedFunctionStub\nusing Test\n\nusing Catlab.GATs, Catlab.Theories, Catlab.CategoricalAlgebra\nimport Catlab.Theories: compose","category":"page"},{"location":"generated/sketches/preorders/#Definition-of-a-Preorder-formalized-as-a-GAT","page":"Preorders","title":"Definition of a Preorder formalized as a GAT","text":"","category":"section"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"The following definitions can be found in the Catlab.Theories module.","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"\"\"\" Theory of *preorders*\n\nPreorders encode the axioms of reflexivity and transitivity as term constructors.\n\"\"\"\n@theory Preorder{El,Leq} begin\n  El::TYPE\n  Leq(lhs::El, rhs::El)::TYPE\n  @op (≤) := Leq\n\n  # Preorder axioms are lifted to term constructors in the GAT.\n  reflexive(A::El)::(A≤A) # ∀ A there is a term reflexive(A) which implies A≤A\n  transitive(f::(A≤B), g::(B≤C))::(A≤C) ⊣ (A::El, B::El, C::El)\n\n  # Axioms of the GAT are equivalences on terms or simplification rules in the logic\n  f == g ⊣ (A::El, B::El, f::(A≤B), g::(A≤B))\n  # Read as (f⟹ A≤B ∧ g⟹ A≤B) ⟹ f ≡ g\nend","category":"page"},{"location":"generated/sketches/preorders/#Preorders-are-Thin-Categories","page":"Preorders","title":"Preorders are Thin Categories","text":"","category":"section"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"Definition of a thin category","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"@theory ThinCategory{Ob,Hom} <: Category{Ob,Hom} begin\n  f == g ⊣ (A::Ob, B::Ob, f::Hom(A,B), g::Hom(A,B))\nend","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"of course this definition extends the GAT of categories","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"@theory Category{Ob,Hom} begin\n  # Unicode aliases.\n  @op begin\n  (→) := Hom\n  (⋅) := compose\n  end\n\n  \"\"\" Object in a category \"\"\"\n  Ob::TYPE\n\n  \"\"\" Morphism in a category \"\"\"\n  Hom(dom::Ob,codom::Ob)::TYPE\n\n  id(A::Ob)::(A → A)\n  compose(f::(A → B), g::(B → C))::(A → C) ⊣ (A::Ob, B::Ob, C::Ob)\n\n  # Category axioms.\n  ((f ⋅ g) ⋅ h == f ⋅ (g ⋅ h)\n  ⊣ (A::Ob, B::Ob, C::Ob, D::Ob, f::(A → B), g::(B → C), h::(C → D)))\n  f ⋅ id(B) == f ⊣ (A::Ob, B::Ob, f::(A → B))\n  id(A) ⋅ f == f ⊣ (A::Ob, B::Ob, f::(A → B))\nend","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"Exercise: construct an isomorphism between the theory of thin categories and the theory of preorders. Show that they have the same models.","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"Once you have a GAT defined using the @theory macro, you can define presentations, which are logical syntax for giving examples of the theory. The GAT contains type and term constructors that you can use to write expressions. A presentation uses those expressions to create a specific example of the theory. We define P to be a preorder with 3 elements and 2 ≤ relationships.","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"@present P(FreeThinCategory) begin\n  (X,Y,Z)::Ob\n  f::Hom(X,Y)\n  g::Hom(Y,Z)\nend","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"another example","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"@present Q(FreeThinCategory) begin\n  (X,Y,Z)::Ob\n  f::Hom(X,Y)\n  g::Hom(Y,Z)\n  Y′::Ob\n  f′::Hom(X,Y′)\n  g′::Hom(Y′,Z)\nend","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"Exercise: draw the Hasse diagrams for these preorders by hand.","category":"page"},{"location":"generated/sketches/preorders/#Composition-is-transitivity","page":"Preorders","title":"Composition is transitivity","text":"","category":"section"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"expressions in the presentation are paths in the Hasse Diagram","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"function compose(P::Presentation, vs::Vector{Symbol})\n  compose(collect(generator(P, v) for v in vs))\nend","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"expressions are represented at expression trees","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"ex = compose(P, [:f, :g])","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"the head of an expression is the root of the expression tree","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"GATs.head(ex)","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"the julia type of the expression","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"typeof(ex)","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"the GAT type of the expression","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"gat_typeof(ex)","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"the parameters of the GAT Type","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"gat_type_args(ex)","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"in any thin category there is at most one morphism between any pair of objects. In symbols: ex₁::Hom(X,Y) ∧ ex₂::Hom(X,Y) ⟹ ex₁ == ex₂","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"function thinequal(ex₁::FreeThinCategory.Hom, ex₂::FreeThinCategory.Hom)\n  dom(ex₁) == dom(ex₂) && codom(ex₁) == codom(ex₂)\nend\n\n@test thinequal(ex, compose(P, [:f,:g])⋅id(generator(P,:Z)))","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"Thinking in terms of preorders, the composite f⋅g::Hom(X,Z) is a proof that X ≤ Z in logical notation you would say f::Hom(X,Y) and g::Hom(Y,Z) ⊢ f⋅g::Hom(X,Z) given a proof that X≤Y and a proof of Y≤Z then ⋅ will create a proof of X≤Z by composing the proofs sequentially like chaining inequalities in math a key aspect of category theory is that you want to work constructively you don't want to know that there exists a composite, you want to hold onto that composite. in programming, the way that you hold onto things is putting data into data structures. While computers can access things by offset or addresses, programmers want to use names so when we prove in P that X≤Z, we name that proof by adding it as a generator","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"@present P₂(FreeThinCategory) begin\n  (X,Y,Z)::Ob\n  f::Hom(X,Y)\n  g::Hom(Y,Z)\n  h::Hom(X,Z)\nend\n\nex = compose(P₂, [:f, :g])","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"Now that we have a name for h, we can see that thinequal knows that f⋅g == h because according to the definition of a thin category, any two morphisms with the same domain and codomain are equal.","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"@test thinequal(ex, generator(P₂, :h))","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"There is an imperative interface to manipulating presentations by mutating them for this purpose","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"P₂′ = copy(P)\nadd_generator!(P₂′, Hom(:h, P[:X], P[:Z]))\ngenerators(P₂′)","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"We could avoid this naming the homs situation by giving all the homs the same name however, then when you tried to write down a morphism, you wouldn't be able to refer to a specific one by name, because they are all named ≤.","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"@present R(FreeThinCategory) begin\n  (x,y,z)::Ob\n  (≤)::Hom(x,y)\nend\ngenerators(R)","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"Catlab won't let you make a presentation where the homs have the same exact name. So, this will error:","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"@present Q(FreeThinCategory) begin\n  (x,y,z)::Ob\n  (≤)::Hom(x,y)\n  (≤)::Hom(y,z)\n  (≤)::Hom(x,z)\nend","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"However, you can omit the names for homs with the following syntax, which is useful for thin categories.","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"@present Q(FreeThinCategory) begin\n  (x,y,z)::Ob\n  ::Hom(x,y)\n  ::Hom(y,z)\n  ::Hom(x,z)\nend","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"In a thin category, all the homs with the same domain and codomain are the same, so why don't we name them by their the domain and codomain and then use the property that any two homs with the same name are the same to encode the thinness. This is what the Hasse diagram representation does for us. The edges in the diagram are encoding the presentation data into a combinatorial object that we can visualize. There are many reasons to encode a logical structure into a combinatorial strucuture, one is that we generally have ways of drawing combinatorial objects that convey their saliant structure and enable visual reasoning. Another is algorithms, isomorphism between the combinatorial representations provide some of the isomorphisms between the logical structures. in this case, a graph homomorphism between Hasse Diagrams construct isomorphisms between the preorders they present. The converse is not true since there can be many Graphs that present the same preorder.","category":"page"},{"location":"generated/sketches/preorders/#Monotone-Maps","page":"Preorders","title":"Monotone Maps","text":"","category":"section"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"a generator is in the set of homs if it is in the list of generators","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"in_homs(f::FreeThinCategory.Hom{:generator}, C::FinCat) =\n  f in hom_generators(C)","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"a composite hom is in the list set of homs if all of its components are.","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"in_homs(f::FreeThinCategory.Hom{:compose}, C::FinCat) =\n  all(fᵢ->in_homs(fᵢ, C), args(f))","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"we can check if a map is functorial, which is called monotone for preorders.","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"make sure all the objects in the domain are sent to objects in the codomain\nmake sure all the homs are sent to homs in the codomain\ncheck that the domains and codomainss of the homs match","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"function is_functorial(F::FinFunctor)\n  pₒ = map(ob_generators(dom(F))) do X\n    F(X) in ob_generators(codom(F))\n  end |> all\n\n  pₕ = map(hom_generators(dom(F))) do f\n    in_homs(F(f), codom(F))\n  end |> all\n\n  pᵩ = map(hom_generators(dom(F))) do f\n    FX = F(dom(f))\n    FY = F(codom(f))\n    Ff = F(f)\n    dom(Ff) == FX && codom(Ff) == FY\n  end |> all\n  return pₒ && pₕ && pᵩ\nend\n\n@present Q(FreeThinCategory) begin\n  (a,b,c,d)::Ob\n  ab::Hom(a,b)\n  bc::Hom(b,c)\n  cd::Hom(c,d)\nend\ngenerators(Q)\n\nFₒ = Dict(:X=>:a, :Y=>:b, :Z=>:c)\nFₕ = Dict(:f=>:ab, :g=>:bc)\nF = FinFunctor(Fₒ, Fₕ, P, Q)\n@test is_functorial(F)\n\nFₒ = Dict(:X=>:a, :Y=>:b, :Z=>:d)\nFₕ = Dict(:f=>:ab, :g=>[:bc, :cd])\nF = FinFunctor(Fₒ, Fₕ, P, Q)\n@test is_functorial(F)\n\n\nFₒ = Dict(:X=>:a, :Y=>:b, :Z=>:c)\nFₕ = Dict(:f=>:ab, :g=>[:bc, :cd])\nF = FinFunctor(Fₒ, Fₕ, P, Q)\n@test !is_functorial(F)","category":"page"},{"location":"generated/sketches/preorders/","page":"Preorders","title":"Preorders","text":"Monotone maps are functors for thin categories. One of the benefits of category theory is that we find abstractions that work in multiple domains. The abstraction of preserving the domains and codomains of morphisms is a key abstraction that we can use to define many notions in mathematics.","category":"page"},{"location":"apis/wiring_diagrams/#wiring_diagrams","page":"Wiring diagrams","title":"Wiring diagrams","text":"","category":"section"},{"location":"apis/wiring_diagrams/","page":"Wiring diagrams","title":"Wiring diagrams","text":"Modules = [\n  WiringDiagrams.DirectedWiringDiagrams,\n  WiringDiagrams.UndirectedWiringDiagrams,\n  WiringDiagrams.MonoidalDirectedWiringDiagrams,\n  WiringDiagrams.WiringDiagramAlgorithms,\n  WiringDiagrams.WiringDiagramSerialization,\n  WiringDiagrams.GraphMLWiringDiagrams,\n  WiringDiagrams.JSONWiringDiagrams,\n]\nPrivate = false","category":"page"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams","text":"Data structure for (directed) wiring diagrams, aka string diagrams.\n\nA (directed) wiring diagram consists of a collection of boxes with input and output ports connected by wires. A box can be atomic (possessing no internal structure) or can itself be a wiring diagram. Thus, wiring diagrams can be nested recursively. Wiring diagrams are closely related to what the CS literature calls \"directed graphs with ports\" or more simply \"port graphs\". The main difference is that a wiring diagram has an \"outer box\": a wiring diagram has its own ports that can be connected to the ports of its boxes.\n\nThis module provides a generic data structure for wiring diagrams. Arbitrary data can be attached to the boxes, ports, and wires of a wiring diagram. The diagrams are \"abstract\" in the sense that they cannot be directly rendered as raster or vector graphics. However, they form a useful intermediate representation that can be serialized to and from GraphML or translated into Graphviz or other declarative diagram languages.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.AbstractBox","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.AbstractBox","text":"Base type for any box (node) in a wiring diagram.\n\nThis type represents an arbitrary black box with inputs and outputs.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.Box","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.Box","text":"An atomic box in a wiring diagram.\n\nThese boxes have no internal structure.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.Port","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.Port","text":"A port on a box to which wires can be connected.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.PortKind","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.PortKind","text":"Kind of port: input or output.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.Wire","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.Wire","text":"A wire connecting one port to another.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.CategoricalAlgebra.FinCats.graph-Tuple{WiringDiagram}","page":"Wiring diagrams","title":"Catlab.CategoricalAlgebra.FinCats.graph","text":"Grapn underlying wiring diagram, including parts for noin-internal wires.\n\nThe graph has two special vertices representing the input and output boundaries of the outer box.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.encapsulate-Tuple{WiringDiagram, Vector{Int64}}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.encapsulate","text":"Encapsulate multiple boxes within a single sub-diagram.\n\nThis operation is a (one-sided) inverse to subsitution, see substitute.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.encapsulated_subdiagram-Union{Tuple{WD}, Tuple{WD, Vector{Int64}}} where WD<:WiringDiagram","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.encapsulated_subdiagram","text":"Create an encapsulating box for a set of boxes in a wiring diagram.\n\nTo a first approximation, the union of input ports of the given boxes will become the inputs ports of the encapsulating box and likewise for the output ports. However, when copies or merges occur, as in a cartesian or cocartesian category, a simplification procedure may reduce the number of ports on the encapsulating box.\n\nSpecifically:\n\nEach input port of an encapsulated box will have at most one incoming wire\n\nfrom the encapsulating outer box, and each output port of an encapsulated box will have at most one outgoing wire to the encapsulating outer box.\n\nA set of ports connected to the same outside (non-encapsulated) ports will be\n\nsimplified into a single port of the encapsulating box.\n\nSee also induced_subdiagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.in_wires-Tuple{WiringDiagram, Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.in_wires","text":"Get all wires coming into the box.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.in_wires-Tuple{WiringDiagram, Port}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.in_wires","text":"Get all wires coming into the port.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.induced_subdiagram-Union{Tuple{T}, Tuple{WiringDiagram{T}, Vector{Int64}}} where T","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.induced_subdiagram","text":"The wiring diagram induced by a subset of its boxes.\n\nSee also encapsulated_subdiagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.internal_graph-Tuple{WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.internal_graph","text":"Graph underlying wiring diagram, with edges for internal wires only.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.ocompose-Tuple{WiringDiagram, Vector{<:WiringDiagram}}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.ocompose","text":"Operadic composition of wiring diagrams.\n\nThis generic function has two different signatures, corresponding to the \"full\" and \"partial\" notions of operadic composition (Yau, 2018, Operads of Wiring Diagrams, Definitions 2.3 and 2.10).\n\nThis operation is a simple wrapper around substitute.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.out_wires-Tuple{WiringDiagram, Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.out_wires","text":"Get all wires coming out of the box.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.out_wires-Tuple{WiringDiagram, Port}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.out_wires","text":"Get all wires coming out of the port.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.singleton_diagram-Tuple{Type, AbstractBox}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.singleton_diagram","text":"Wiring diagram with a single box connected to the outer ports.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.substitute-Tuple{WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.substitute","text":"Substitute wiring diagrams for boxes.\n\nPerforms one or more substitutions. When performing multiple substitutions, the substitutions are simultaneous.\n\nThis operation implements the operadic composition of wiring diagrams, see also ocompose.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.validate_ports-Tuple{Any, Any}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.validate_ports","text":"Check compatibility of source and target ports.\n\nThe default implementation is a no-op.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.wires-Tuple{WiringDiagram, Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.wires","text":"Get all wires coming into or out of the box.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.UndirectedWiringDiagrams","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.UndirectedWiringDiagrams","text":"Data structure for undirected wiring diagrams.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.UndirectedWiringDiagrams.AbstractUWD","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.UndirectedWiringDiagrams.AbstractUWD","text":"Abstract type for UWDs, typed or untyped, possibly with extra attributes.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.UndirectedWiringDiagrams.HasUWD","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.UndirectedWiringDiagrams.HasUWD","text":"Abstract type for C-sets that contain a UWD.\n\nThis type includes UWDs, scheduled UWDs, and nested UWDs.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.UndirectedWiringDiagrams.TypedUWD","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.UndirectedWiringDiagrams.TypedUWD","text":"A typed undirected wiring diagram.\n\nA UWD whose ports and junctions must be compatibly typed.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.UndirectedWiringDiagrams.UntypedUWD","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.UndirectedWiringDiagrams.UntypedUWD","text":"An undirected wiring diagram.\n\nThe most basic kind of UWD, without types or other extra attributes.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.DirectedWiringDiagrams.add_wire!-Tuple{AbstractUWD, Tuple{Int64, Int64}, Tuple{Int64, Int64}}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.DirectedWiringDiagrams.add_wire!","text":"Wire together two ports in an undirected wiring diagram.\n\nA convenience method that creates and sets junctions as needed. Ports are only allowed to have one junction, so if both ports already have junctions, then the second port is assigned the junction of the first. The handling of the two arguments is otherwise symmetric.\n\nFIXME: When both ports already have junctions, the two junctions should be merged. To do this, we must implement merge_junctions! and thus also rem_part!.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.UndirectedWiringDiagrams.cospan_diagram-Union{Tuple{UWD}, Tuple{Type{UWD}, SetFunction{Dom, Codom} where {Dom<:(FinSet{Int64}), Codom<:(FinSet{Int64})}, SetFunction{Dom, Codom} where {Dom<:(FinSet{Int64}), Codom<:(FinSet{Int64})}}, Tuple{Type{UWD}, SetFunction{Dom, Codom} where {Dom<:(FinSet{Int64}), Codom<:(FinSet{Int64})}, SetFunction{Dom, Codom} where {Dom<:(FinSet{Int64}), Codom<:(FinSet{Int64})}, Any}} where UWD<:AbstractUWD","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.UndirectedWiringDiagrams.cospan_diagram","text":"Undirected wiring diagram defined by a cospan.\n\nThe wiring diagram has a single box. The ports of this box, the outer ports, the junctions, and the connections between them are defined by the cospan. Thus, this function generalizes singleton_diagram.\n\nSee also: junction_diagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.UndirectedWiringDiagrams.junction_diagram-Union{Tuple{UWD}, Tuple{Type{UWD}, SetFunction{Dom, Codom} where {Dom<:(FinSet{Int64}), Codom<:(FinSet{Int64})}}, Tuple{Type{UWD}, SetFunction{Dom, Codom} where {Dom<:(FinSet{Int64}), Codom<:(FinSet{Int64})}, Any}} where UWD<:AbstractUWD","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.UndirectedWiringDiagrams.junction_diagram","text":"Undirected wiring diagram with no boxes, only junctions.\n\nSee also: singleton_diagram, cospan_diagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams","text":"Wiring diagrams as a symmetric monoidal category.\n\nThis module provides a high-level categorical interface to wiring diagrams, building on the low-level imperative interface and the operadic interface. It also defines data types and functions to represent diagonals, codiagonals, duals, caps, cups, daggers, and other gadgets in wiring diagrams.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.BoxOp","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.BoxOp","text":"Box wrapping another box.\n\nRepresents unary operations on boxes in wiring diagrams.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.Junction","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.Junction","text":"Junction node in a wiring diagram.\n\nJunction nodes are used to explicitly represent copies, merges, deletions, creations, caps, and cups.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.PortOp","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.PortOp","text":"Port value wrapping another value.\n\nRepresents unary operations on ports in wiring diagrams.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.Ports","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.Ports","text":"A list of ports.\n\nThe objects in categories of wiring diagrams.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.GATs.SyntaxSystems.functor-Tuple{WiringDiagram, Any, Any}","page":"Wiring diagrams","title":"Catlab.GATs.SyntaxSystems.functor","text":"Apply functor in a category of wiring diagrams.\n\nDefined by compatible mappings of ports and boxes.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.add_junctions-Tuple{WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.add_junctions","text":"Add junction nodes to wiring diagram.\n\nTransforms from the implicit to the explicit representation of diagonals and codiagonals. This operation is inverse to rem_junctions.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.implicit_mcopy-Tuple{Ports, Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.implicit_mcopy","text":"Implicit copy in wiring diagram.\n\nCopies are represented by multiple outgoing wires from a single port and deletions by no outgoing wires.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.implicit_mmerge-Tuple{Ports, Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.implicit_mmerge","text":"Implicit merge in wiring diagram.\n\nMerges are represented by multiple incoming wires into a single port and creations by no incoming wires.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.junction_caps-Tuple{Ports}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.junction_caps","text":"Wiring diagram of nested caps made out of junction nodes.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.junction_cups-Tuple{Ports}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.junction_cups","text":"Wiring diagram of nested cups made out of junction nodes.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.junctioned_mcopy-Tuple{Ports, Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.junctioned_mcopy","text":"Explicit copy in wiring diagram.\n\nCopies and deletions are represented by junctions (boxes of type Junction).\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.junctioned_mmerge-Tuple{Ports, Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.junctioned_mmerge","text":"Explicit merge in wiring diagram.\n\nMerges and creations are represented by junctions (boxes of type Junction).\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.merge_junctions-Tuple{WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.merge_junctions","text":"Merge adjacent junction nodes into single junctions.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.rem_junctions-Tuple{WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.MonoidalDirectedWiringDiagrams.rem_junctions","text":"Remove junction nodes from wiring diagram.\n\nTransforms from the explicit to the implicit representation of diagonals and codiagonals. This operation is inverse to add_junctions.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.UndirectedWiringDiagrams.junction_diagram-Tuple{Ports, Int64, Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.UndirectedWiringDiagrams.junction_diagram","text":"Wiring diagram with a junction node for each of the given ports.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms","text":"Algorithms on wiring diagrams.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.Graphs.GraphAlgorithms.topological_sort-Tuple{WiringDiagram}","page":"Wiring diagrams","title":"Catlab.Graphs.GraphAlgorithms.topological_sort","text":"Topological sort of boxes in wiring diagram.\n\nReturns a list of box IDs, excluding the outer box's input and output IDs.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.crossing_minimization_by_sort-Tuple{WiringDiagram, AbstractVector}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.crossing_minimization_by_sort","text":"Crossing minimization by sorting a univariate statistic.\n\nThe boxes in sources and/or targets are fixed and the boxes in vs are permuted. A permutation σ of the latter is returned, such that vs[σ] are the sorted box IDs. Both one-sided and two-sided crossing minimization are supported, depending on whether just one, or both, of sources and targets are given.\n\nIn this simple but popular heuristic algorithm, the boxes are permuted by sorting a univariate statistic of the positions of incoming and/or outgoing wires. Typical choices are:\n\nmean: the sample mean, yielding the \"barycenter method\"\nmedian: the sample median\n\nIn both cases, this algorithm has the property that if there is a permutation with no crossings, it will find it.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_cartesian!-Tuple{WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_cartesian!","text":"Put a wiring diagram for a cartesian category into normal form.\n\nThis function puts a wiring diagram representing a morphism in a free cartesian category into normal form. Copies and deletions are simplified as much as possible.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_copy!-Tuple{WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_copy!","text":"Normalize copies in a wiring diagram.\n\nThis function maximizes sharing of intermediate computations in a wiring diagram where copies are natural.\n\nThis algorithm is basically the same as the congruence closure algorithm on term graphs, in the special case of the empty relation R = ∅ (Baader & Nipkow, 1998, Term Rewriting and All That, Sec. 4.4). The main difference is the possibility of zero or many function outputs.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_delete!-Tuple{WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_delete!","text":"Normalize deletions in a wiring diagram.\n\nThis function removes all unused intermediate computations in a wiring diagram where deletion is natural.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramSerialization","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramSerialization","text":"Conventions for serialization of wiring diagrams.\n\nDefines a consistent set of names for boxes, ports, and wires to be used when serializing wiring diagrams, as well as conventions for serializing box, port, and wire attributes.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams","text":"Serialize abstract wiring diagrams as GraphML.\n\nSerialization of box, port, and wire values can be overloaded by data type (see convert_to_graphml_data and convert_from_graphml_data).\n\nGraphML is the closest thing to a de jure and de facto standard in the space of graph data formats, supported by a variety of graph applications and libraries. We depart mildly from the GraphML spec by allowing JSON data attributes for GraphML nodes, ports, and edges.\n\nReferences:\n\nGraphML Primer: http://graphml.graphdrawing.org/primer/graphml-primer.html\nGraphML DTD: http://graphml.graphdrawing.org/specification/dtd.html\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.generate_graphml-Tuple{WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.generate_graphml","text":"Generate GraphML representing a wiring diagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.parse_graphml-Tuple{Type, Type, Type, AbstractString}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.parse_graphml","text":"Parse a wiring diagram from a GraphML string or XML document.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.read_graphml-Tuple{Type, Type, Type, String}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.read_graphml","text":"Read a wiring diagram from a GraphML file.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.write_graphml-Tuple{WiringDiagram, String}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.write_graphml","text":"Write a wiring diagram to a file as GraphML.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.JSONWiringDiagrams","text":"Serialize abstract wiring diagrams as JSON.\n\nJSON data formats are convenient when programming for the web. Unfortunately, no standard for JSON graph formats has gained any kind of widespread adoption. We adopt a format compatible with that used by the KEILER project and its successor ELK (Eclipse Layout Kernel). This format is roughly feature compatible with GraphML, supporting nested graphs and ports. It also supports layout information like node position and size.\n\nReferences:\n\nKEILER's JSON graph format: https://rtsys.informatik.uni-kiel.de/confluence/display/KIELER/JSON+Graph+Format\nELK's JSON graph format: https://www.eclipse.org/elk/documentation/tooldevelopers/graphdatastructure/jsonformat.html\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams.generate_json_graph-Tuple{WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.JSONWiringDiagrams.generate_json_graph","text":"Generate a JSON dict representing a wiring diagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams.parse_json_graph-Tuple{Type, Type, Type, Union{AbstractString, IO}}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.JSONWiringDiagrams.parse_json_graph","text":"Parse a wiring diagram from a JSON string or dict.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams.read_json_graph-Tuple{Type, Type, Type, String}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.JSONWiringDiagrams.read_json_graph","text":"Read a wiring diagram from a JSON file.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams.write_json_graph-Tuple{WiringDiagram, String}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.JSONWiringDiagrams.write_json_graph","text":"Write a wiring diagram to a file as JSON.\n\n\n\n\n\n","category":"method"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"EditURL = \"../../../literate/graphics/graphviz_graphs.jl\"","category":"page"},{"location":"generated/graphics/graphviz_graphs/#Drawing-graphs-in-Graphviz","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"","category":"section"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"(Image: )","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"All of the basic graph types provided by the Catlab Graphs module can be drawn using Graphviz. By default, \"directed\" graph types (Graph, ReflexiveGraph) are drawn using the dot program and \"undirected\" graph types (SymmetricGraph, HalfEdgeGraph) are drawn using the neato program.","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"using Catlab.Graphs, Catlab.Graphics","category":"page"},{"location":"generated/graphics/graphviz_graphs/#Drawing-basic-graphs","page":"Drawing graphs in Graphviz","title":"Drawing basic graphs","text":"","category":"section"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"g = cycle_graph(Graph, 3)\nto_graphviz(g)","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"sg = cycle_graph(SymmetricGraph, 3)\nto_graphviz(sg)","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"Node and edge IDs can be shown by setting node_labels=true and edge_labels=true, or a data attribute can be used as a label by setting node_labels=:my_vertex_attr and edge_lables=:my_edge_attr.","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"to_graphviz(g, node_labels=true, edge_labels=true)","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"Graph-level, node-level, and edge-level Graphviz attributes can be supplied using the graph_attrs, node_attrs, and edge_attrs keyword arguments.","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"to_graphviz(g, node_attrs=Dict(:color => \"cornflowerblue\"),\n            edge_attrs=Dict(:style => \"dotted\"))","category":"page"},{"location":"generated/graphics/graphviz_graphs/#Drawing-graph-homomorphisms","page":"Drawing graphs in Graphviz","title":"Drawing graph homomorphisms","text":"","category":"section"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"Graph homomorphsims (ACSetTransformations between graphs) can also be drawn using Graphviz, in several different styles.","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"using Catlab.CategoricalAlgebra\n\nf = homomorphism(cycle_graph(Graph, 4), complete_graph(Graph, 2))","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"By default, the domain and codomain graph are both drawn, as well the vertex mapping between them.","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"to_graphviz(f)","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"To see the edge mapping, which is not necessarily unique in the presence of the multiple edges, colors can be used.","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"to_graphviz(f, edge_colors=true)","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"Alternatively, the graph homomorphism can be depicted by drawing only the domain graph and coloring its nodes and edges. By default, setting draw_codom=false sets both node_colors=true and edge_colors=true.","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"to_graphviz(f, draw_codom=false)","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"to_graphviz(f, draw_codom=false, edge_colors=false)","category":"page"},{"location":"generated/graphics/graphviz_graphs/#Drawing-maps-between-finite-sets","page":"Drawing graphs in Graphviz","title":"Drawing maps between finite sets","text":"","category":"section"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"It is also possible to visualize maps between finite sets (FinFunctions between FinSets) using Graphviz.","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"using Catlab.CategoricalAlgebra.FinSets\n\nA = FinSet(4)\nB = FinSet(3)\nf = FinFunction([1,3,2,2], A, B)\n\nto_graphviz(f, graph_attrs=Dict(:splines=>\"false\"))","category":"page"},{"location":"generated/graphics/graphviz_graphs/","page":"Drawing graphs in Graphviz","title":"Drawing graphs in Graphviz","text":"to_graphviz(f, node_labels=true,\n            graph_attrs=Dict(:splines=>\"false\", :rankdir => \"TB\"))","category":"page"},{"location":"#Catlab.jl","page":"Catlab.jl","title":"Catlab.jl","text":"","category":"section"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Catlab.jl is a framework for applied and computational category theory, written in the Julia language. Catlab provides a programming library and interactive interface for applications of category theory to scientific and engineering fields. It emphasizes monoidal categories due to their wide applicability but can support any categorical structure that is formalizable as a generalized algebraic theory.","category":"page"},{"location":"#What-is-Catlab?","page":"Catlab.jl","title":"What is Catlab?","text":"","category":"section"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Catlab is, or will eventually be, the following things.","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Programming library: First and foremost, Catlab provides data structures, algorithms, and serialization for applied category theory. Macros offer a convenient syntax for specifying categorical doctrines and type-safe symbolic manipulation systems. Wiring diagrams (aka string diagrams) are supported through specialized data structures and can be serialized to and from GraphML (an XML-based format) and JSON.","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Interactive computing environment: Catlab can also be used interactively in Jupyter notebooks. Symbolic expressions are displayed using LaTeX and wiring diagrams are visualized using Compose.jl, Graphviz, or TikZ.","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Computer algebra system: Catlab will serve as a computer algebra system for categorical algebra. Unlike most computer algebra systems, all expressions are typed using fragment of dependent type theory called generalized algebraic theories. We will implement core algorithms for solving word problems and reducing expressions to normal form with respect to several important doctrines, such as those of categories and of symmetric monoidal categories. For the computer algebra of classical abstract algebra, see AbstractAlgebra.jl and Nemo.jl.","category":"page"},{"location":"#What-is-Catlab-not?","page":"Catlab.jl","title":"What is Catlab not?","text":"","category":"section"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Catlab is not currently any of the following things, although we do not rule out that it could eventually evolve in these directions.","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Automated theorem prover: Although there is some overlap between computer algebra and automated theorem proving, Catlab cannot be considered a theorem prover because it does not produce formal certificates of correctness (aka proofs).","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Proof assistant: Likewise, Catlab is not a proof assistant because it does not produce formally verifiable proofs. Formal verification is not within scope of the project.","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Graphical user interface: Catlab does not provide a wiring diagram editor or other graphical user interface. It is primarily a programming library, not a user-facing application. However, there is another project in the AlgebraicJulia ecosystem, Semagrams.jl which does provide graphical user interfaces for interacting with wiring diagrams, Petri nets, and the like.","category":"page"},{"location":"#What-is-a-GAT?","page":"Catlab.jl","title":"What is a GAT?","text":"","category":"section"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Generalized Algebraic Theories (GATs) are the backbone of Catlab so let's expand a bit on GATs and how they fit into the bigger picture of algebra.","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"An algebraic structure, like a group or category, is a mathematical object whose axioms all take the form of equations that are universally quantified (the equations have no exceptions). That’s not a formal definition but it’s a good heuristic. There are different ways to make this precise. The oldest, going back to universal algebra in the early 20th centrury, are algebraic theories.","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Universal algebra (sometimes called general algebra) is the field of mathematics that studies algebraic structures themselves, not examples (\"models\") of algebraic structures. For instance, rather than take particular groups as the object of study, in universal algebra one takes the class of groups as an object of study. In an algebraic theory, you have a collection of (total) operations and they obey a set of equational axioms. Classically, there is only a single generating type, but there are also typed or multi-sorted versions of algebraic theories. Most of the classical structures of abstract algebra, such as groups, rings, and modules, can be defined as algebraic theories.","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Importantly, the theory of categories is not algebraic. In other words, a category cannot be defined as a (multi-sorted) algebraic theory. The reason is that the operation of composition is partial, since you can only compose morphisms with compatible (co)domains. Now, categories sure feel like algebraic structures, so people have come up with generalizations of algebraic theories that accomodate categories and related structures.","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"The first of these was Freyd’s essentially algebraic theories. In an essentially algebraic theory, you can have partially defined operations; however, to maintain the equational character of the system, the domains of operations must themselves be defined equationally. For example, the theory of categories would be defined as having two types, Ob and Hom, and the composition operation compose(f::Hom,g::Hom)::Hom would have domain given by the equation codom(f) == dom(g). As your theories get more elaborate, the sets of equations defining the domains get more complicated and reasoning about the structure is overwhelming.","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Later, Cartmell proposed generalized algebraic theories, which solves the same problem but in a different way. Rather than having partial operations, you have total operations but on dependent types (types that are parameterized by values). So now the composition operation has signature compose(f::Hom(A,B), g::Hom(B,C))::Hom(A,C) where (A::Ob, B::Ob, C::Ob)  exactly as appears in Catlab. This is closer to the way that mathematicians actually think and write about categories. For example, if you look at the definitions of category, functor, and natural transformation in Emily Riehl’s textbook, you will see that they are already essentially in the form of a GAT, whereas they require translation into an essentially algebraic theory. Nevertheless, GATs and essentially algebraic theories have the same expressive power, at least in their standard set-based semantics. GATs provide a version of the computer scientist's type theory that plays well with the mathematician's algebra, thus, providing a perfect opportunity for computer algebra systems.","category":"page"},{"location":"#Overview-of-Key-Components","page":"Catlab.jl","title":"Overview of Key Components","text":"","category":"section"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"There are several core parts to the Catlab design, we start with a brief overview of each one","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Catlab.GAT provides @theory - defines a new Generalized Algebraic Theory. These are algebraic versions of what a logician would call a logical theory. They support equational reasoning and a limited version of dependent types. Namely the dependent types must also form an algebraic theory and you are only allowed to have equations between terms of the same type. Catlab ships with many predefined theories for important concepts like Categories and \"doctrines\" of categories like Symmetric Monoidal Categories. These predefined theories are defined in Catlab.Theories, but you can make your own with the @theory macro.\nCatlab.Syntax provides initial algebras for a GAT, which are declared with @syntax. These are represented as a typed version of Expr that allows you to customize the normalization procedure for example in a FreeCategory, the composition operation which is a unital and associative binary operation is normalized into lists. This allows you to write algorithms on Syntax trees that use different styles of simplification. The only styles available now are support for normalizing unital and associate operations like comoposition and a monoidal product.\n@instance associates Julia data structures as semantics for a GAT. This is known as functorial semantics, where you associate every type in the GAT with a type in Julia and every term constructor in the GAT to a julia function (possibly a struct constructor). These functions and types must satisfy the axioms that are encoded in the GAT. \n@present enumerates a finite set of generators for a model of the GAT just like you would write out a group (model of the theory of groups) as list of generators and relations, the presentation lets you enumerate the objects and morphisms that generate a category.","category":"page"},{"location":"#Conventions","page":"Catlab.jl","title":"Conventions","text":"","category":"section"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"In several places in Catlab, we use what we call \"Abstract Field Convention\". Instead of doing the following:","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"struct Pair{A}\n  x1::A\n  x2::A\nend\n\nadd(xs::Pair) = xs.x1 + xs.x2\n\nconst IntPair = Pair{Int}","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"which leads to potentially longer and longer type names as the type parameters increase in size, we do","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"\"\"\"\nAbstract Fields\n- x1::A\n- x2::A\n\"\"\"\nabstract type Pair{A} end\n\nadd(xs::Pair) = xs.x1 + xs.x2\n\nstruct IntPair <: Pair{Int}\n  x1::Int\n  x2::Int\nend","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"That is, we assume that all subtypes of a certain abstract types have the same field names, and are organized in roughly the same way. There is no way of enforcing this within Julia, so instead we leave a comment on the abstract type to document that we are working this way.","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Note that this is contrary to the standard wisdom in Julia that one should as much as possible access structs through methods, not field accesses. The reason why we do not do this here is twofold. First of all, sometimes it can be annoying to write out the trivial field-access methods in addition to defining the struct.  For instance, we have 12 different structs in src/acsets/ColumnImplementations.jl that all are subtypes of an Abstract Field Convention abstract type. It would be 24 lines of boilerplate to write out the field accessors for these types with little appreciable benefit. The second reason is that the Abstract Field Convention is a stronger guarantee than an interface: we are claiming that any subtype has precisely these fields in this order, and no others! This is essential for defining methods like copy, which might be defined as follows.","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"function copy(p::T) where {T<:Pair}\n  T(p.x1, p.x2)\nend","category":"page"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"So the Abstract Field Convention is stronger than a normal interface. It's not really about encapsulating data, it's more about cutting down on long names in debug messages.","category":"page"},{"location":"#Table-of-Contents","page":"Catlab.jl","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Catlab.jl","title":"Catlab.jl","text":"Pages = [\n     \"apis/gats.md\",\n     \"apis/theories.md\",\n     \"apis/wiring_diagrams.md\",\n     \"apis/graphics.md\",\n     \"apis/programs.md\",\n     \"devdocs/style.md\",\n     ]\nDepth = 2","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"EditURL = \"../../../literate/sketches/smc.jl\"","category":"page"},{"location":"generated/sketches/smc/#Symmetric-Monoidal-Categories","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"","category":"section"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"(Image: )","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"This vignette supports section 4.4.3 of Seven Sketches in Compositionality, which introduces the definition of symmetric monoidal categories (SMCs). SMCs are a core concept in applied category theory and are a workhorse of Catlab's utility in computing applications. We will discuss the definition as a GAT, see examples of working with formulas, and conversions to wiring diagrams (sometimes called string diagrams). SMCs are useful for modeling mathematical structures like programs or processes where the objects represent data or things and the morphisms represent processes that happen to those things.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"using Catlab.GATs, Catlab.Theories\nusing Catlab.CategoricalAlgebra\nusing Catlab.WiringDiagrams\nusing Catlab.Programs\nusing Catlab.Graphics\nusing Catlab.Graphics: Graphviz\n\ndraw(d::WiringDiagram) = to_graphviz(d,\n  orientation=LeftToRight,\n  labels=true, label_attr=:xlabel,\n  node_attrs=Graphviz.Attributes(\n    :fontname => \"Courier\",\n  ),\n  edge_attrs=Graphviz.Attributes(\n    :fontname => \"Courier\",\n  )\n)","category":"page"},{"location":"generated/sketches/smc/#Definition","page":"Symmetric Monoidal Categories","title":"Definition","text":"","category":"section"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"Let 𝒞 be a category, then a strict symmetric monoidal structure on 𝒞 has as data:","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"An object I called the monoidal unit\nA functor ⊗: 𝒞×𝒞 → 𝒞 called the monoidal product.\nA natural isomorphism σᵃᵇ: A⊗B → B⊗A","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"It has as axioms:","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"Left identity) I⊗C = C for all objects C in 𝒞\nRight identity) C⊗I = C for all objects C in 𝒞\nAssociativity) (A⊗B)⊗C = A⊗(B⊗C) for all objects A,B,C in 𝒞\nInvolutivity) σ(σ(A,B)) = id(A⊗B)","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"In a category, you have a composition operation that captures the sequential kind of composition. For example in Set, you compose two functions f⋅g by first applying f and then applying g. In monoidal categories, you also have the parallel composition ⊗ which you can think of as representing the simultaneous exectution of two processes. We are familiar with the cartesian product in Set which takes two sets and forms the cartesian product. The cartesian product acts on functions in a similar way, f×g is the function that takes a tuple (x:dom(f),y:dom(g)) and applies them in parallel and returns (f(x), g(y)):(codom(f)×codom(g)). The axioms of an SMC require that these two operations work together. The Seven Sketches book suppresses an interesting axiom called the interchange law for brevity, but it is worth calling some attention to it. In order for the sequential and parallel composition operators to capture our intuition, we need to assert that for any functions with compatible domains we can interchange parallel and sequential operators. Formally, ((f ⊗ g) ⋅ (h ⊗ k) == (f ⋅ h) ⊗ (g ⋅ k) where (A::Ob, B::Ob, C::Ob, X::Ob, Y::Ob, Z::Ob, f::(A → B), h::(B → C), g::(X → Y), k::(Y → Z))). This axiom says that doing f and g in parallel and then h and k in parallel is the same as doing (f then h) and (g then k) in parallel. When using SMCs to model processes, this axiom is critical to making sure that scheduling those processes is coherent.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"If the SMC is not strict, then the equations are replaced by natural isomorphisms. The choice of natural isomorphisms then becomes part of the data of the SMC. With MacLane's coherence theorem for SMCs mathematicians can think about strict SMCs and not really worry too much about the natural isomorphisms. As programmers, those chickens come home to roost and implementing an SMC requires making some choices about about how to do that strictification.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"The Catlab definitions of SMC are repeated here for convenience. Catlab allows you to implement mathematical definitions in the language of Generalized Algebraic Theories (GATs), which are a good fit for the kind of natural language definitions that mathematicians will write. Because Catlab does relatively little type inference, the GAT version of a definition can be more verbose than you would get in natural language. For example, we have to be careful about spelling out the object for an identity morphism id(A):A → A. The notation  @theory MonoidalCategory{Ob,Hom} <: Category{Ob,Hom} says that a Monoidal Category is a type of Category with additional components and axioms. Catlab has only rudimentary support for Monoidal Categories that are not Symmetric Monoidal Categories. But we separate out the definitions for completeness.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"@theory MonoidalCategory{Ob,Hom} <: Category{Ob,Hom} begin\n  otimes(A::Ob, B::Ob)::Ob\n  otimes(f::(A → B), g::(C → D))::((A ⊗ C) → (B ⊗ D)) ⊣\n    (A::Ob, B::Ob, C::Ob, D::Ob)\n  @op (⊗) := otimes\n  munit()::Ob\n  # Monoid axioms.\n  #\n  # The last two axioms are the naturality equations associated with the left\n  # and right unitors, in the strict case where they are identities.\n  (A ⊗ B) ⊗ C == A ⊗ (B ⊗ C) ⊣ (A::Ob, B::Ob, C::Ob)\n  munit() ⊗ A == A ⊣ (A::Ob)\n  A ⊗ munit() == A ⊣ (A::Ob)\n  (f ⊗ g) ⊗ h == f ⊗ (g ⊗ h) ⊣ (A::Ob, B::Ob, C::Ob, X::Ob, Y::Ob, Z::Ob,\n                                f::(A → X), g::(B → Y), h::(C → Z))\n  id(munit()) ⊗ f == f ⊣ (A::Ob, B::Ob, f::(A → B))\n  f ⊗ id(munit()) == f ⊣ (A::Ob, B::Ob, f::(A → B))\n  # Functorality axioms.\n  ((f ⊗ g) ⋅ (h ⊗ k) == (f ⋅ h) ⊗ (g ⋅ k)\n    ⊣ (A::Ob, B::Ob, C::Ob, X::Ob, Y::Ob, Z::Ob,\n       f::(A → B), h::(B → C), g::(X → Y), k::(Y → Z)))\n  id(A ⊗ B) == id(A) ⊗ id(B) ⊣ (A::Ob, B::Ob)\nend","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"To the definition of a monoidal category, we need to add the symmetry component. Catlab calls the swap morphism a braid, because that is how you visualize it in wiring diagrams, but we stick with the conventional σ unicode name. The macro @op tells Catlab that you want to use a unicode operator as an alias for you term constructor. If you are familiar with type theory, you might be wondering why we write the context after the terms. This is because human brains are pretty good at type inference based on notational convention and we want to mimic the English idiom \"f⋅g, where f:A→B and g:B→C are functions\".","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"@theory SymmetricMonoidalCategory{Ob,Hom} <: MonoidalCategory{Ob,Hom} begin\n  braid(A::Ob, B::Ob)::((A ⊗ B) → (B ⊗ A))\n  @op (σ) := braid\n  # Involutivity axiom.\n  σ(A,B) ⋅ σ(B,A) == id(A ⊗ B) ⊣ (A::Ob, B::Ob)\n  # Coherence axioms.\n  #\n  # Note: The last two axioms are deducible from the first two axioms together\n  # with the naturality equations for the left/right unitors. We record them for\n  # the sake of clarity and uniformity.\n  σ(A,B⊗C) == (σ(A,B) ⊗ id(C)) ⋅ (id(B) ⊗ σ(A,C)) ⊣ (A::Ob, B::Ob, C::Ob)\n  σ(A⊗B,C) == (id(A) ⊗ σ(B,C)) ⋅ (σ(A,C) ⊗ id(B)) ⊣ (A::Ob, B::Ob, C::Ob)\n  σ(A,munit()) == id(A) ⊣ (A::Ob)\n  σ(munit(),A) == id(A) ⊣ (A::Ob)\n  # Naturality axiom.\n  (f ⊗ g) ⋅ σ(B,D) == σ(A,C) ⋅ (g ⊗ f) ⊣ (A::Ob, B::Ob, C::Ob, D::Ob,\n                                          f::(A → B), g::(C → D))\nend","category":"page"},{"location":"generated/sketches/smc/#Presentations","page":"Symmetric Monoidal Categories","title":"Presentations","text":"","category":"section"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"Just like how a preorder can be presented with Hasse Diagram or a free category can be presented by a Graph, SMCs can be presented syntactically or combinatorially. We first start with the syntactic presentation using @present.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"@present Cooking(FreeSymmetricMonoidalCategory) begin\n  (WholeEgg, RawEgg, Shell, Egg, Pan, Cheese, Scramble)::Ob\n  crack::Hom(WholeEgg, RawEgg⊗Shell)\n  fry::Hom(RawEgg⊗Pan, Egg⊗Pan)\n  scramble::Hom(RawEgg⊗Cheese⊗Pan, Scramble⊗Pan)\nend\ngenerators(Cooking)","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"One interpretation of an SMC is that the objects are resources and the Homs are processes the domain of the Hom is the list of resources that you need to perform the process and the codomain is the list of resources that the process produces. You can think of the SMC presentation as a namespace containing all the terms in the SMC.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"The objects and morphisms are accessible by name","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"Cooking[:Egg]\nCooking[:fry]","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"Then you can make complex terms using the unicode operators","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"((Cooking[:crack]⋅σ(Cooking[:RawEgg], Cooking[:Shell])) ⊗id(Cooking[:Pan])) ⋅ (id(Cooking[:Shell])⊗Cooking[:fry])","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"Notice that Catlab will display the expected domain and codomain.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"This is called point-free notation an it is very popular in the functional programming literature where it is used to mean implicit universal quantification over the function arguments. You can think of a morphism like a function that takes an element of each domain object as input and produces an element of each codomain object as output. Not all SMCs have interpretations as functions over sets, but just like groups can be viewed as a generalization of the symmetries of geometric shapes, SMCs can be viewed as a generalization of multivariate functions.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"These presentations are very syntactic objects and expose an API for manipulating expressions.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"for g in generators(Cooking)\n  \"$g is a $(gat_typeof(g)) with arguments $(gat_type_args(g))\"\nend","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"The gat_typeof function computes the algebraic type of a term by analogy to Base.typeof which computes the Julia type of a value.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"homs = filter(generators(Cooking)) do g\n  gat_typeof(g) == :Hom\nend","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"When the term is a Hom, you can get the domain and codomain of the morphism with the dom and codom functions.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"map(homs) do f\n  \"$f: $(dom(f)) → $(codom(f))\"\nend","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"The terms in a FreeSymmetricMonoidalCategory are trees that you can navigate with head and args. The head of an expression is the term constructor that created it. For SMCs, this can be :generator, :otimes, :compose, :id, or :braid. Then args will give you the list of arguments to the term constructor. For terms of type Object, this will just be the list of objects that went into constructing the object. For example A⊗B⊗C will have as its head :otimes and as the args [A,B,C]. Note that the head is a symbol, but the args are objects. For a term of type Hom, you have the same structure, but for Homs with the head :generator, you get the name of the morphism as a symbol as the first argument.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"We can look at the head and args of object expressions.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"headargs(x) = (head(x),args(x))\nσ(Cooking[:Egg], Cooking[:Pan]) |> headargs","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"And, morphsims","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"headargs(Cooking[:crack]⊗Cooking[:fry])","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"The base case is generators","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"headargs(Cooking[:Egg])","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"And, morphisms","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"headargs(Cooking[:crack])","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"For a more complete introspection of the expression trees, you can call dump(ex) which will print a very verbose representation of the entire expression tree.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"In order to compose morphisms sequentially, you have to make sure that the domains match up. In a typical SMC expression this can require padding with the identity morphism and braiding monoidal products into the right order.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"compose(Cooking[:crack]⊗id(Cooking[:Pan]),\n        (id(Cooking[:RawEgg])⊗ σ(Cooking[:Shell], Cooking[:Pan])),\n        (Cooking[:fry]⊗id(Cooking[:Shell])))","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"At some point, prefix notation is more scalable than infix notation, so you might write this as a LISP programmer would.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"compose(\n  otimes(Cooking[:crack],\n         id(Cooking[:Pan])),\n  otimes(id(Cooking[:RawEgg]),\n         σ(Cooking[:Shell], Cooking[:Pan])),\n  otimes(Cooking[:fry],\n         id(Cooking[:Shell])))","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"You can view this padding as requiring explicit instructions to do noting with all the objects you aren't using. In this example, we have to tell our chef","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"Crack the egg and do nothing with the pan.\nDo nothing with the egg and swap the shell with the pan.\nFry the egg and do nothing with the shell.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"Obviously, this is a very tedious way to write recipes. You need to have some syntactic sugar for all this padding and swapping.","category":"page"},{"location":"generated/sketches/smc/#The-Program-Macro","page":"Symmetric Monoidal Categories","title":"The Program Macro","text":"","category":"section"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"The syntactic API above is useful for manipulating terms in an arbitrary GAT and is the formal language of Catlab for representing and manipulating algebraic structures. However, when we want to work with big expressions in an SMC, the tree structure inherent to formulas is too verbose, and we want to move to a port-graph structure called DirectedWiringDiagrams. This gives us the benefits of combinatorial data structures like graphs with the right expressional power for representing the morphisms in an SMC.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"recipe = @program Cooking (e::WholeEgg, p::Pan) begin\n  e′, shell = crack(e)\n  return shell, fry(e′, p)\nend\ndraw(recipe)","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"Catlab gives you the tools for drawing wiring diagrams. Visualization of wiring diagrams is the oldest part of Catlab and the original motivation for its development. The @program macro allows you to define wiring diagrams using a syntax that feels like Julia code.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"The input wires are declared as arguments to the program, and the output wires are declared as returns from the function. Variables that are not consumed or by another function or returned by the program are automatically dropped.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"recipe = @program Cooking (e::WholeEgg, p::Pan) begin\n  e′, shell = crack(e)\n  return fry(e′, p)\nend\ndraw(recipe)","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"You can copy a value by using it more than once. This is visualized as a wire being split into two wires. Square brackets let you assert equality again. For material goods, you might not want to allow this merging and splitting.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"recipe = @program Cooking (e₁::WholeEgg, e₂::WholeEgg, p::Pan) begin\n  e, shell = crack(e₁)\n  r₁, p₁ = fry(e, p)\n  e, shell = crack(e₂)\n  r₂, p₂ = fry(e, p)\n  return r₁, r₂, [p₁,p₂]\nend\n\ndraw(recipe)","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"You can visualize the copy and delete morphisms explicitly with the add_junctions function. The dots with one wire input and multiple outputs are copying values and dots with no wires out are deletions (discarding values). Not all instances of a SymmetricMonoidalCategory support copy and delete, for example, in manufacturing you can't duplicate a resource, and in chemistry you can't discard species. Catlab would enforce that when you tried to interpret the wiring diagram in a specific SMC.","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"draw(add_junctions(recipe))","category":"page"},{"location":"generated/sketches/smc/","page":"Symmetric Monoidal Categories","title":"Symmetric Monoidal Categories","text":"For more details about working with wiring diagrams in Catlab, you should look at the vignettes under wiring_diagrams which explain how wiring diagrams interact with SMC expressions and the basics of constructing and manipulation wiring diagrams.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"EditURL = \"../../../literate/graphics/composejl_wiring_diagrams.jl\"","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Drawing-wiring-diagrams-in-Compose.jl","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"(Image: )","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"Catlab can draw wiring diagrams using the Julia package Compose.jl.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"For best results, it is recommended to load the packages Convex.j and SCS.jl. When available they are used to optimize the layout of the outer ports.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"using Catlab.WiringDiagrams, Catlab.Graphics\n\nimport Convex, SCS","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Examples","page":"Drawing wiring diagrams in Compose.jl","title":"Examples","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/#Symmetric-monoidal-category","page":"Drawing wiring diagrams in Compose.jl","title":"Symmetric monoidal category","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"using Catlab.Theories\n\nA, B, C, D = Ob(FreeSymmetricMonoidalCategory, :A, :B, :C, :D)\nf, g = Hom(:f, A, B), Hom(:g, B, A);\nnothing #hide","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"To start, here are a few very simple examples.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(f)","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(f⋅g)","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(f⊗g)","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"Here is a more complex example, involving generators with compound domains and codomains.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"h, k = Hom(:h, C, D),  Hom(:k, D, C)\nm, n = Hom(:m, B⊗A, A⊗B), Hom(:n, D⊗C, C⊗D)\nq = Hom(:l, A⊗B⊗C⊗D, D⊗C⊗B⊗A)\n\nto_composejl((f⊗g⊗h⊗k)⋅(m⊗n)⋅q⋅(n⊗m)⋅(h⊗k⊗f⊗g))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"Identities and braidings appear as wires.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(id(A))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(braid(A,B))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(braid(A,B) ⋅ (g⊗f) ⋅ braid(A,B))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"The isomorphism A otimes B otimes C to C otimes B otimes A induced by the permutation (3 2 1) is a composite of braidings and identities.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"σ = (braid(A,B) ⊗ id(C)) ⋅ (id(B) ⊗ braid(A,C) ⋅ (braid(B,C) ⊗ id(A)))\n\nto_composejl(σ)","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"By default, anchor points are added along identity and braiding wires to reproduce the expression structure in the layout. The anchors can be disabled to get a more \"unbiased\" layout.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(σ, anchor_wires=false)","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Biproduct-category","page":"Drawing wiring diagrams in Compose.jl","title":"Biproduct category","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"A, B, C = Ob(FreeBiproductCategory, :A, :B, :C)\nf = Hom(:f, A, B)\n\nto_composejl(mcopy(A))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(delete(A))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(mcopy(A)⋅(f⊗f)⋅mmerge(B))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(mcopy(A⊗B), orientation=TopToBottom)","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(mcopy(A⊗B⊗C), orientation=TopToBottom)","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Compact-closed-category","page":"Drawing wiring diagrams in Compose.jl","title":"Compact closed category","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"The unit and co-unit of a compact closed category appear as caps and cups.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"A, B = Ob(FreeCompactClosedCategory, :A, :B)\n\nto_composejl(dunit(A))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(dcounit(A))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"In a self-dual compact closed category, such as a bicategory of relations, every morphism f A to B has a transpose f^dagger B to A given by bending wires:","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"A, B = Ob(FreeBicategoryRelations, :A, :B)\nf = Hom(:f, A, B)\n\nto_composejl((dunit(A) ⊗ id(B)) ⋅ (id(A) ⊗ f ⊗ id(B)) ⋅ (id(A) ⊗ dcounit(B)))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Abelian-bicategory-of-relations","page":"Drawing wiring diagrams in Compose.jl","title":"Abelian bicategory of relations","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"In an abelian bicategory of relations, such as the category of linear relations, the duplication morphisms Delta_X X to X oplus X and addition morphisms blacktriangledown_X X oplus X to X belong to a bimonoid. Among other things, this means that the following two morphisms are equal.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"X = Ob(FreeAbelianBicategoryRelations, :X)\n\nto_composejl(plus(X) ⋅ mcopy(X))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl((mcopy(X)⊕mcopy(X)) ⋅ (id(X)⊕swap(X,X)⊕id(X)) ⋅ (plus(X)⊕plus(X)))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Custom-styles","page":"Drawing wiring diagrams in Compose.jl","title":"Custom styles","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"The visual appearance of wiring diagrams can be customized by passing Compose properties.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"using Compose: fill, stroke\n\nA, B, = Ob(FreeSymmetricMonoidalCategory, :A, :B)\nf, g = Hom(:f, A, B), Hom(:g, B, A)\n\nto_composejl(f⋅g, props=Dict(\n  :box => [fill(\"lavender\"), stroke(\"black\")],\n))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"X = Ob(FreeAbelianBicategoryRelations, :X)\n\nto_composejl(plus(X) ⋅ mcopy(X), props=Dict(\n  :junction => [fill(\"red\"), stroke(\"black\")],\n  :variant_junction => [fill(\"blue\"), stroke(\"black\")],\n))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"The background color can also be changed.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(f⋅g, background_color=\"lightgray\", props=Dict(\n  :box => [fill(\"white\"), stroke(\"black\")],\n))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"By default, the boxes are rectangular (:rectangle). Other available shapes include circles (:circle) and ellipses (:ellipse).","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"to_composejl(f⋅g, default_box_shape=:circle)","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Output-formats","page":"Drawing wiring diagrams in Compose.jl","title":"Output formats","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"The function to_composejl returns a ComposePicture object, which contains a Compose.jl context as well as a recommended width and height. When displayed interactively, this object is rendered using Compose's SVG backend.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"Any backend can be used by calling Compose's draw function. The SVG and PGF (LaTeX) backends are always available. To use the PNG or PDF backends, the extra packages Cairo.jl and Fontconfig.jl must be installed.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"For example, here is how to use the PGF backend.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/","page":"Drawing wiring diagrams in Compose.jl","title":"Drawing wiring diagrams in Compose.jl","text":"using Compose: draw, PGF\n\npic = to_composejl(f⋅g, rounded_boxes=false)\npgf = sprint() do io\n  pgf_backend = PGF(io, pic.width, pic.height,\n    false, # emit_on_finish\n    true,  # only_tikz\n    texfonts=true)\n  draw(pgf_backend, pic.context)\nend\nprintln(pgf)","category":"page"}]
}
