<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Programs · Catlab.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Catlab.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Sketches</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/sketches/partitions/">Partitions</a></li><li><a class="tocitem" href="../../generated/sketches/meets/">meets</a></li><li><a class="tocitem" href="../../generated/sketches/preorders/">Preorders</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphs/subgraphs/">Algebra of subgraphs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Wiring diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_schema_visualization/">Visualizing Acset Schemas with Graphviz</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../core/">Theories, instances, and expressions</a></li><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li><a class="tocitem" href="../categorical_algebra/">Categorical algebra</a></li><li><a class="tocitem" href="../graphs/">Graphs</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li class="is-active"><a class="tocitem" href>Programs</a><ul class="internal"><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Programs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Programs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/master/docs/src/apis/programs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="programs"><a class="docs-heading-anchor" href="#programs">Programs</a><a id="programs-1"></a><a class="docs-heading-anchor-permalink" href="#programs" title="Permalink"></a></h1><p>The module <code>Catlab.Programs</code> provides domain-specific languages (DSLs) for constructing diagrams of various kinds. The DSLs, implemented as Julia macros, are based on Julia syntax but often interpret that syntax very differently from standard Julia programs. Conversely, this module offers limited support for generating Julia code from wiring diagrams.</p><p>There are two major macros for constructing wiring diagrams:</p><ul><li><a href="#Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any, Vararg{Any, N} where N}"><code>@program</code></a>, for directed wiring diagrams</li><li><a href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>@relation</code></a>, for undirected wiring diagrams</li></ul><p>In addition, there is a family of macros for constructing category-theoretic <a href="https://ncatlab.org/nlab/show/diagram">diagrams</a>:</p><ul><li><a href="#Catlab.Programs.DiagrammaticPrograms.@graph-Tuple{Any, Any}"><code>@graph</code></a>, for defining a graph</li><li><a href="#Catlab.Programs.DiagrammaticPrograms.@category-Tuple{Any}"><code>@category</code></a>, for presenting a category as a graph plus path equations</li><li><a href="#Catlab.Programs.DiagrammaticPrograms.@diagram-Tuple{Any, Any}"><code>@diagram</code></a>, for defining a diagram in a given category</li></ul><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms" href="#Catlab.Programs.GenerateJuliaPrograms"><code>Catlab.Programs.GenerateJuliaPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Compile or evaluate morphisms as Julia programs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.Block" href="#Catlab.Programs.GenerateJuliaPrograms.Block"><code>Catlab.Programs.GenerateJuliaPrograms.Block</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A block of Julia code with input and output variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.CompileState" href="#Catlab.Programs.GenerateJuliaPrograms.CompileState"><code>Catlab.Programs.GenerateJuliaPrograms.CompileState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Internal state for compilation of morphism into Julia code.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.compile-Tuple{Module, HomExpr}" href="#Catlab.Programs.GenerateJuliaPrograms.compile-Tuple{Module, HomExpr}"><code>Catlab.Programs.GenerateJuliaPrograms.compile</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compile a morphism expression into a Julia function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.compile_block-Tuple{HomExpr, Vector{T} where T}" href="#Catlab.Programs.GenerateJuliaPrograms.compile_block-Tuple{HomExpr, Vector{T} where T}"><code>Catlab.Programs.GenerateJuliaPrograms.compile_block</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compile a morphism expression into a block of Julia code.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.compile_expr-Tuple{HomExpr}" href="#Catlab.Programs.GenerateJuliaPrograms.compile_expr-Tuple{HomExpr}"><code>Catlab.Programs.GenerateJuliaPrograms.compile_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compile a morphism expression into a Julia function expression.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.evaluate-Tuple{HomExpr, Vararg{Any, N} where N}" href="#Catlab.Programs.GenerateJuliaPrograms.evaluate-Tuple{HomExpr, Vararg{Any, N} where N}"><code>Catlab.Programs.GenerateJuliaPrograms.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate a morphism as a function.</p><p>If the morphism will be evaluated only once (possibly with vectorized inputs), then direct evaluation will be much faster than compiling (via <code>compile</code>) and evaluating a standard Julia function.</p><p>Compare with <a href="../core/#Catlab.Syntax.functor-Tuple{Tuple, GATExpr}"><code>functor</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.ParseJuliaPrograms" href="#Catlab.Programs.ParseJuliaPrograms"><code>Catlab.Programs.ParseJuliaPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Parse Julia programs into morphisms represented as wiring diagrams.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram-Tuple{Presentation, Expr}" href="#Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram-Tuple{Presentation, Expr}"><code>Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse a wiring diagram from a Julia function expression.</p><p>For more information, see the corresponding macro <a href="#Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any, Vararg{Any, N} where N}"><code>@program</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any, Vararg{Any, N} where N}" href="#Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any, Vararg{Any, N} where N}"><code>Catlab.Programs.ParseJuliaPrograms.@program</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Parse a wiring diagram from a Julia program.</p><p>For the most part, this is standard Julia code but a few liberties are taken with the syntax. Products are represented as tuples. So if <code>x</code> and <code>y</code> are variables of type <span>$X$</span> and <span>$Y$</span>, then <code>(x,y)</code> has type <span>$X ⊗ Y$</span>. Also, both <code>()</code> and <code>nothing</code> are interpreted as the monoidal unit <span>$I$</span>.</p><p>Unlike standard Julia, the function call expressions <code>f(x,y)</code> and <code>f((x,y))</code> are equivalent. Consequently, given morphisms <span>$f: W → X ⊗ Y$</span> and <span>$g: X ⊗ Y → Z$</span>, the code</p><pre><code class="language-julia">x, y = f(w)
g(x,y)</code></pre><p>is equivalent to <code>g(f(w))</code>. In standard Julia, at most one of these calls to <code>g</code> would be valid, unless <code>g</code> had multiple signatures.</p><p>The diagonals (copying and deleting) of a cartesian category are implicit in the Julia syntax: copying is variable reuse and deleting is variable non-use. For the codiagonals (merging and creating), a special syntax is provided, reinterpreting Julia&#39;s vector literals. The merging of <code>x1</code> and <code>x2</code> is represented by the vector <code>[x1,x2]</code> and creation by the empty vector <code>[]</code>. For example, <code>f([x1,x2])</code> translates to <code>compose(mmerge(X),f)</code>.</p><p>This macro is a wrapper around <a href="#Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram-Tuple{Presentation, Expr}"><code>parse_wiring_diagram</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms" href="#Catlab.Programs.RelationalPrograms"><code>Catlab.Programs.RelationalPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Parse relation expressions in Julia syntax into undirected wiring diagrams.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.RelationDiagram" href="#Catlab.Programs.RelationalPrograms.RelationDiagram"><code>Catlab.Programs.RelationalPrograms.RelationDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for UWDs created by <a href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>@relation</code></a> macro.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.TypedRelationDiagram" href="#Catlab.Programs.RelationalPrograms.TypedRelationDiagram"><code>Catlab.Programs.RelationalPrograms.TypedRelationDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Typed UWD created by <a href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>@relation</code></a> macro.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.UntypedRelationDiagram" href="#Catlab.Programs.RelationalPrograms.UntypedRelationDiagram"><code>Catlab.Programs.RelationalPrograms.UntypedRelationDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Untyped UWD created by <a href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>@relation</code></a> macro.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.parse_relation_diagram-Tuple{Expr}" href="#Catlab.Programs.RelationalPrograms.parse_relation_diagram-Tuple{Expr}"><code>Catlab.Programs.RelationalPrograms.parse_relation_diagram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse an undirected wiring diagram from a relation expression.</p><p>For more information, see the corresponding macro <a href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>@relation</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.@relation-Tuple" href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>Catlab.Programs.RelationalPrograms.@relation</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Construct an undirected wiring diagram using relation notation.</p><p>Unlike the <code>@program</code> macro for directed wiring diagrams, this macro departs significantly from the usual semantics of the Julia programming language. Function calls with <span>$n$</span> arguments are now interpreted as assertions that an <span>$n$</span>-ary relation holds at a particular point. For example, the composite of binary relations <span>$R ⊆ X × Y$</span> and <span>$S ⊆ Y × Z$</span> can be represented as an undirected wiring diagram by the macro call</p><pre><code class="language-julia">@relation (x,z) where (x::X, y::Y, z::Z) begin
  R(x,y)
  S(y,z)
end</code></pre><p>In general, the context in the <code>where</code> clause defines the set of junctions in the diagram and variable sharing defines the wiring of ports to junctions. If the <code>where</code> clause is omitted, the set of junctions is inferred from the variables used in the macro call.</p><p>The ports and junctions of the diagram may be typed or untyped, and the ports may be named or unnamed. Thus, four possible types of undirected wiring diagrams may be returned, with the type determined by the form of relation header:</p><ol><li>Untyped, unnamed: <code>@relation (x,z) where (x,y,z) ...</code></li><li>Typed, unnamed: <code>@relation (x,z) where (x::X, y::Y, z::Z) ...</code></li><li>Untyped, named: <code>@relation (out1=x, out2=z) where (x,y,z) ...</code></li><li>Typed, named: <code>@relation (out=1, out2=z) where (x::X, y::Y, z::Z) ...</code></li></ol><p>All four types of diagram are subtypes of <a href="#Catlab.Programs.RelationalPrograms.RelationDiagram"><code>RelationDiagram</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.DiagrammaticPrograms" href="#Catlab.Programs.DiagrammaticPrograms"><code>Catlab.Programs.DiagrammaticPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>DSLs for defining categories, diagrams, and related structures.</p><p>Here &quot;diagram&quot; means diagram in the ordinary sense of category theory, not wiring diagram.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.DiagrammaticPrograms.@category-Tuple{Any}" href="#Catlab.Programs.DiagrammaticPrograms.@category-Tuple{Any}"><code>Catlab.Programs.DiagrammaticPrograms.@category</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Present a category by generators and relations.</p><p>The result is a finitely presented category (<code>FinCat</code>) represented by a graph, possibly with path equations. For example, the simplex category truncated to one dimension is:</p><pre><code class="language-julia">@category begin
  V, E
  (δ₀, δ₁): V → E
  σ₀: E → V

  σ₀ ∘ δ₀ == id(V)
  σ₀ ∘ δ₁ == id(V)
end</code></pre><p>The objects and morphisms must be uniquely named.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.DiagrammaticPrograms.@diagram-Tuple{Any, Any}" href="#Catlab.Programs.DiagrammaticPrograms.@diagram-Tuple{Any, Any}"><code>Catlab.Programs.DiagrammaticPrograms.@diagram</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Present a diagram in a given category.</p><p>Recall that a <em>diagram</em> in a category <span>$C$</span> is a functor <span>$F: J → C$</span> from a small category <span>$J$</span> into <span>$C$</span>. Given the category <span>$C$</span>, this macro presents a diagram in <span>$C$</span>, i.e., constructs a finitely presented indexing category <span>$J$</span> together with a functor <span>$F: J → C$</span>. This method of simultaneous definition is often more convenient than defining <span>$J$</span> and <span>$F$</span> separately.</p><p>For example, the following diagram specifies the paths of length two in a graph:</p><pre><code class="language-julia">@diagram FinCat(TheoryGraph) begin
  v::V
  (e1, e2)::E
  t::tgt : e1 → v
  s::src : e2 → v
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.DiagrammaticPrograms.@graph-Tuple{Any, Any}" href="#Catlab.Programs.DiagrammaticPrograms.@graph-Tuple{Any, Any}"><code>Catlab.Programs.DiagrammaticPrograms.@graph</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Construct a graph in a simple, declarative style.</p><p>The syntax is reminiscent of Graphviz. Each line a declares a vertex or set of vertices, or an edge. For example, the following defines a directed triangle:</p><pre><code class="language-julia">@graph begin
  v0, v1, v2
  fst: v0 → v1
  snd: v1 → v2
  comp: v0 → v2
end</code></pre><p>Vertices in the graph must be uniquely named, whereas edges names are optional and need not be unique.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../graphics/">« Graphics</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 25 October 2021 18:09">Monday 25 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
