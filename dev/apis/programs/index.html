<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Programs · Catlab.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catlab.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Seven Sketches in Compositionality</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/sketches/partitions/">Partitions</a></li><li><a class="tocitem" href="../../generated/sketches/preorders/">Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/meets/">Meets in Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/smc/">Symmetric Monoidal Categories</a></li><li><a class="tocitem" href="../../generated/sketches/cat_elements/">The Category of Elements</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphs/graphs/">The Category of Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/graphs_label/">Labeled Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/subgraphs/">Algebra of subgraphs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Categorical Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/categorical_algebra/diagrams/">Diagrams</a></li><li><a class="tocitem" href="../../generated/categorical_algebra/acset_serialization/">Serializing acsets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Wiring Diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/wd_cset/">Wiring Diagrams as Attributed C-Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/graphviz_graphs/">Drawing graphs in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../core/">Theories, instances, and expressions</a></li><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li><a class="tocitem" href="../categorical_algebra/">Categorical algebra</a></li><li><a class="tocitem" href="../graphs/">Graphs</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li class="is-active"><a class="tocitem" href>Programs</a><ul class="internal"><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Programs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Programs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/master/docs/src/apis/programs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="programs"><a class="docs-heading-anchor" href="#programs">Programs</a><a id="programs-1"></a><a class="docs-heading-anchor-permalink" href="#programs" title="Permalink"></a></h1><p>The module <code>Catlab.Programs</code> provides domain-specific languages (DSLs) for constructing diagrams of various kinds. The DSLs, implemented as Julia macros, are based on the syntax of the Julia language but often interpret that syntax very differently from standard Julia programs. Conversely, this module offers preliminary support for generating Julia code from wiring diagrams.</p><p>There are two major macros for constructing wiring diagrams:</p><ul><li><a href="#Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any, Vararg{Any}}"><code>@program</code></a>, for directed wiring diagrams (DWDs)</li><li><a href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>@relation</code></a>, for undirected wiring diagrams (UWDs)</li></ul><p>In addition, there is a family of related macros for constructing category-theoretic <a href="https://ncatlab.org/nlab/show/diagram">diagrams</a>:</p><ul><li><a href="#Catlab.Programs.DiagrammaticPrograms.@graph-Tuple{Any, Any}"><code>@graph</code></a>, for constructing a graph</li><li><a href="#Catlab.Programs.DiagrammaticPrograms.@fincat-Tuple{Any}"><code>@fincat</code></a>, for presenting a category as a graph together with path equations</li><li><a href="#Catlab.Programs.DiagrammaticPrograms.@finfunctor-Tuple{Any, Any, Any}"><code>@finfunctor</code></a>, for defining a functor between two finitely presented categories</li><li><a href="#Catlab.Programs.DiagrammaticPrograms.@diagram-Tuple{Any, Any}"><code>@diagram</code></a> and <a href="#Catlab.Programs.DiagrammaticPrograms.@free_diagram-Tuple{Any, Any}"><code>@free_diagram</code></a>, for defining a diagram in a category</li></ul><p>Generalizing the last two macros, the modules provides DSLs for functorial data migration:</p><ul><li><a href="#Catlab.Programs.DiagrammaticPrograms.@migrate-Tuple{Any, Any, Any}"><code>@migrate</code></a>, for migrating data between acsets</li><li><a href="#Catlab.Programs.DiagrammaticPrograms.@migration-Tuple{Any, Any}"><code>@migration</code></a>, for defining data migrations between schemas</li></ul><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms" href="#Catlab.Programs.GenerateJuliaPrograms"><code>Catlab.Programs.GenerateJuliaPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Compile or evaluate morphisms as Julia programs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.Block" href="#Catlab.Programs.GenerateJuliaPrograms.Block"><code>Catlab.Programs.GenerateJuliaPrograms.Block</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A block of Julia code with input and output variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.CompileState" href="#Catlab.Programs.GenerateJuliaPrograms.CompileState"><code>Catlab.Programs.GenerateJuliaPrograms.CompileState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Internal state for compilation of morphism into Julia code.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.compile-Tuple{Module, HomExpr}" href="#Catlab.Programs.GenerateJuliaPrograms.compile-Tuple{Module, HomExpr}"><code>Catlab.Programs.GenerateJuliaPrograms.compile</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compile a morphism expression into a Julia function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.compile_block-Tuple{HomExpr, Vector}" href="#Catlab.Programs.GenerateJuliaPrograms.compile_block-Tuple{HomExpr, Vector}"><code>Catlab.Programs.GenerateJuliaPrograms.compile_block</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compile a morphism expression into a block of Julia code.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.compile_expr-Tuple{HomExpr}" href="#Catlab.Programs.GenerateJuliaPrograms.compile_expr-Tuple{HomExpr}"><code>Catlab.Programs.GenerateJuliaPrograms.compile_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compile a morphism expression into a Julia function expression.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.evaluate-Tuple{HomExpr, Vararg{Any}}" href="#Catlab.Programs.GenerateJuliaPrograms.evaluate-Tuple{HomExpr, Vararg{Any}}"><code>Catlab.Programs.GenerateJuliaPrograms.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate a morphism as a function.</p><p>If the morphism will be evaluated only once (possibly with vectorized inputs), then direct evaluation will be much faster than compiling (via <code>compile</code>) and evaluating a standard Julia function.</p><p>Compare with <a href="../core/#Catlab.Syntax.functor-Tuple{Tuple, GATExpr}"><code>functor</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.ParseJuliaPrograms" href="#Catlab.Programs.ParseJuliaPrograms"><code>Catlab.Programs.ParseJuliaPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Parse Julia programs into morphisms represented as wiring diagrams.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram-Tuple{Presentation, Expr}" href="#Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram-Tuple{Presentation, Expr}"><code>Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse a wiring diagram from a Julia function expression.</p><p>For more information, see the corresponding macro <a href="#Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any, Vararg{Any}}"><code>@program</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any, Vararg{Any}}" href="#Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any, Vararg{Any}}"><code>Catlab.Programs.ParseJuliaPrograms.@program</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Parse a wiring diagram from a Julia program.</p><p>For the most part, this is standard Julia code but a few liberties are taken with the syntax. Products are represented as tuples. So if <code>x</code> and <code>y</code> are variables of type <span>$X$</span> and <span>$Y$</span>, then <code>(x,y)</code> has type <span>$X ⊗ Y$</span>. Also, both <code>()</code> and <code>nothing</code> are interpreted as the monoidal unit <span>$I$</span>.</p><p>Unlike standard Julia, the function call expressions <code>f(x,y)</code> and <code>f((x,y))</code> are equivalent. Consequently, given morphisms <span>$f: W → X ⊗ Y$</span> and <span>$g: X ⊗ Y → Z$</span>, the code</p><pre><code class="language-julia hljs">x, y = f(w)
g(x,y)</code></pre><p>is equivalent to <code>g(f(w))</code>. In standard Julia, at most one of these calls to <code>g</code> would be valid, unless <code>g</code> had multiple signatures.</p><p>The diagonals (copying and deleting) of a cartesian category are implicit in the Julia syntax: copying is variable reuse and deleting is variable non-use. For the codiagonals (merging and creating), a special syntax is provided, reinterpreting Julia&#39;s vector literals. The merging of <code>x1</code> and <code>x2</code> is represented by the vector <code>[x1,x2]</code> and creation by the empty vector <code>[]</code>. For example, <code>f([x1,x2])</code> translates to <code>compose(mmerge(X),f)</code>.</p><p>This macro is a wrapper around <a href="#Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram-Tuple{Presentation, Expr}"><code>parse_wiring_diagram</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms" href="#Catlab.Programs.RelationalPrograms"><code>Catlab.Programs.RelationalPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Parse relation expressions in Julia syntax into undirected wiring diagrams.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.RelationDiagram" href="#Catlab.Programs.RelationalPrograms.RelationDiagram"><code>Catlab.Programs.RelationalPrograms.RelationDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for UWDs created by <a href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>@relation</code></a> macro.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.TypedRelationDiagram" href="#Catlab.Programs.RelationalPrograms.TypedRelationDiagram"><code>Catlab.Programs.RelationalPrograms.TypedRelationDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Typed UWD created by <a href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>@relation</code></a> macro.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.UntypedRelationDiagram" href="#Catlab.Programs.RelationalPrograms.UntypedRelationDiagram"><code>Catlab.Programs.RelationalPrograms.UntypedRelationDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Untyped UWD created by <a href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>@relation</code></a> macro.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.parse_relation_diagram-Tuple{Expr}" href="#Catlab.Programs.RelationalPrograms.parse_relation_diagram-Tuple{Expr}"><code>Catlab.Programs.RelationalPrograms.parse_relation_diagram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse an undirected wiring diagram from a relation expression.</p><p>For more information, see the corresponding macro <a href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>@relation</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.@relation-Tuple" href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>Catlab.Programs.RelationalPrograms.@relation</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Construct an undirected wiring diagram using relation notation.</p><p>Unlike the <code>@program</code> macro for directed wiring diagrams, this macro departs significantly from the usual semantics of the Julia programming language. Function calls with <span>$n$</span> arguments are now interpreted as assertions that an <span>$n$</span>-ary relation holds at a particular point. For example, the composite of binary relations <span>$R ⊆ X × Y$</span> and <span>$S ⊆ Y × Z$</span> can be represented as an undirected wiring diagram by the macro call</p><pre><code class="language-julia hljs">@relation (x,z) where (x::X, y::Y, z::Z) begin
  R(x,y)
  S(y,z)
end</code></pre><p>In general, the context in the <code>where</code> clause defines the set of junctions in the diagram and variable sharing defines the wiring of ports to junctions. If the <code>where</code> clause is omitted, the set of junctions is inferred from the variables used in the macro call.</p><p>The ports and junctions of the diagram may be typed or untyped, and the ports may be named or unnamed. Thus, four possible types of undirected wiring diagrams may be returned, with the type determined by the form of relation header:</p><ol><li>Untyped, unnamed: <code>@relation (x,z) where (x,y,z) ...</code></li><li>Typed, unnamed: <code>@relation (x,z) where (x::X, y::Y, z::Z) ...</code></li><li>Untyped, named: <code>@relation (out1=x, out2=z) where (x,y,z) ...</code></li><li>Typed, named: <code>@relation (out=1, out2=z) where (x::X, y::Y, z::Z) ...</code></li></ol><p>All four types of diagram are subtypes of <a href="#Catlab.Programs.RelationalPrograms.RelationDiagram"><code>RelationDiagram</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.DiagrammaticPrograms" href="#Catlab.Programs.DiagrammaticPrograms"><code>Catlab.Programs.DiagrammaticPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>DSLs for defining categories, diagrams, and related structures.</p><p>Here &quot;diagram&quot; means diagram in the standard category-theoretic sense, not string diagram or wiring diagram. DSLs for constructing wiring diagrams are provided by other submodules.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.DiagrammaticPrograms.@diagram-Tuple{Any, Any}" href="#Catlab.Programs.DiagrammaticPrograms.@diagram-Tuple{Any, Any}"><code>Catlab.Programs.DiagrammaticPrograms.@diagram</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Present a diagram in a given category.</p><p>Recall that a <em>diagram</em> in a category <span>$C$</span> is a functor <span>$F: J → C$</span> from a small category <span>$J$</span> into <span>$C$</span>. Given the category <span>$C$</span>, this macro presents a diagram in <span>$C$</span>, i.e., constructs a finitely presented indexing category <span>$J$</span> together with a functor <span>$F: J → C$</span>. This method of simultaneous definition is often more convenient than defining <span>$J$</span> and <span>$F$</span> separately, as could be accomplished by calling <a href="#Catlab.Programs.DiagrammaticPrograms.@fincat-Tuple{Any}"><code>@fincat</code></a> and then <a href="#Catlab.Programs.DiagrammaticPrograms.@finfunctor-Tuple{Any, Any, Any}"><code>@finfunctor</code></a>.</p><p>As an example, the limit of the following diagram consists of the paths of length two in a graph:</p><pre><code class="language-julia hljs">@diagram SchGraph begin
  v::V
  (e₁, e₂)::E
  (t: e₁ → v)::tgt
  (s: e₂ → v)::src
end</code></pre><p>Morphisms in the indexing category can be left unnamed, which is convenient for defining free diagrams (see also <a href="#Catlab.Programs.DiagrammaticPrograms.@free_diagram-Tuple{Any, Any}"><code>@free_diagram</code></a>). For example, the following diagram is isomorphic to the previous one:</p><pre><code class="language-julia hljs">@diagram SchGraph begin
  v::V
  (e₁, e₂)::E
  (e₁ → v)::tgt
  (e₂ → v)::src
end</code></pre><p>Of course, unnamed morphisms cannot be referenced by name within the <code>@diagram</code> call or in other settings, which can sometimes be problematic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.DiagrammaticPrograms.@fincat-Tuple{Any}" href="#Catlab.Programs.DiagrammaticPrograms.@fincat-Tuple{Any}"><code>Catlab.Programs.DiagrammaticPrograms.@fincat</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Present a category by generators and relations.</p><p>The result is a finitely presented category (<code>FinCat</code>) represented by a graph, possibly with path equations. For example, the simplex category truncated to one dimension is:</p><pre><code class="language-julia hljs">@fincat begin
  V, E
  (δ₀, δ₁): V → E
  σ₀: E → V

  σ₀ ∘ δ₀ == id(V)
  σ₀ ∘ δ₁ == id(V)
end</code></pre><p>The objects and morphisms must be uniquely named.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.DiagrammaticPrograms.@finfunctor-Tuple{Any, Any, Any}" href="#Catlab.Programs.DiagrammaticPrograms.@finfunctor-Tuple{Any, Any, Any}"><code>Catlab.Programs.DiagrammaticPrograms.@finfunctor</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define a functor between two finitely presented categories.</p><p>Such a functor is defined by sending the object and morphism generators of the domain category to generic object and morphism expressions in the codomain category. For example, the following functor embeds the schema for graphs into the schema for circular port graphs by ignoring the ports:</p><pre><code class="language-julia hljs">@finfunctor SchGraph SchCPortGraph begin
  V =&gt; Box
  E =&gt; Wire
  src =&gt; src ⨟ box
  tgt =&gt; tgt ⨟ box
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.DiagrammaticPrograms.@free_diagram-Tuple{Any, Any}" href="#Catlab.Programs.DiagrammaticPrograms.@free_diagram-Tuple{Any, Any}"><code>Catlab.Programs.DiagrammaticPrograms.@free_diagram</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Present a free diagram in a given category.</p><p>Recall that a <em>free diagram</em> in a category <span>$C$</span> is a functor <span>$F: J → C$</span> where <span>$J$</span> is a free category on a graph, here assumed finite. This macro is functionally a special case of <a href="#Catlab.Programs.DiagrammaticPrograms.@diagram-Tuple{Any, Any}"><code>@diagram</code></a> but, for convenience, changes the interpretation of equality expressions. Rather than interpreting them as equations between morphisms in <span>$J$</span>, equality expresions can be used to introduce anonymous morphisms in a &quot;pointful&quot; style. For example, the limit of the following diagram consists of the paths of length two in a graph:</p><pre><code class="language-julia hljs">@free_diagram SchGraph begin
  v::V
  (e₁, e₂)::E
  tgt(e₁) == v
  src(e₂) == v
end</code></pre><p>Anonymous objects can also be introduced. For example, the previous diagram is isomorphic to this one:</p><pre><code class="language-julia hljs">@free_diagram SchGraph begin
  (e₁, e₂)::E
  tgt(e₁) == src(e₂)
end</code></pre><p>Some care must exercised when defining morphisms between diagrams with anonymous objects, since they cannot be referred to by name.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.DiagrammaticPrograms.@graph-Tuple{Any, Any}" href="#Catlab.Programs.DiagrammaticPrograms.@graph-Tuple{Any, Any}"><code>Catlab.Programs.DiagrammaticPrograms.@graph</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Construct a graph in a simple, declarative style.</p><p>The syntax is reminiscent of Graphviz. Each line a declares a vertex or set of vertices, or an edge. For example, the following defines a directed triangle:</p><pre><code class="language-julia hljs">@graph begin
  v0, v1, v2
  fst: v0 → v1
  snd: v1 → v2
  comp: v0 → v2
end</code></pre><p>Vertices in the graph must be uniquely named, whereas edges names are optional.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.DiagrammaticPrograms.@migrate-Tuple{Any, Any, Any}" href="#Catlab.Programs.DiagrammaticPrograms.@migrate-Tuple{Any, Any, Any}"><code>Catlab.Programs.DiagrammaticPrograms.@migrate</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Contravariantly migrate data from one acset to another.</p><p>This macro is shorthand for defining a data migration using the <a href="#Catlab.Programs.DiagrammaticPrograms.@migration-Tuple{Any, Any}"><code>@migration</code></a> macro and then calling the <code>migrate</code> function. If the migration will be used multiple times, it is more efficient to perform these steps separately, reusing the functor defined by <code>@migration</code>.</p><p>For more about the syntax and supported features, see <a href="#Catlab.Programs.DiagrammaticPrograms.@migration-Tuple{Any, Any}"><code>@migration</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.DiagrammaticPrograms.@migration-Tuple{Any, Any}" href="#Catlab.Programs.DiagrammaticPrograms.@migration-Tuple{Any, Any}"><code>Catlab.Programs.DiagrammaticPrograms.@migration</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define a contravariant data migration.</p><p>This macro provides a DSL to specify a contravariant data migration from <span>$C$</span>-sets to <span>$D$</span>-sets for given schemas <span>$C$</span> and <span>$D$</span>. A data migration is defined by a functor from <span>$D$</span> to a category of queries on <span>$C$</span>. Thus, every object of <span>$D$</span> is assigned a query on <span>$C$</span> and every morphism of <span>$D$</span> is assigned a morphism of queries, in a compatible way. Example usages are in the unit tests. What follows is a technical reference.</p><p>Several categories of queries are supported by this macro:</p><ol><li>Trivial queries, specified by a single object of <span>$C$</span>. In this case, the macro simply defines a functor <span>$D → C$</span> and is equivalent to <a href="#Catlab.Programs.DiagrammaticPrograms.@finfunctor-Tuple{Any, Any, Any}"><code>@finfunctor</code></a> or <a href="#Catlab.Programs.DiagrammaticPrograms.@diagram-Tuple{Any, Any}"><code>@diagram</code></a>.</li><li><em>Conjunctive queries</em>, specified by a diagram in <span>$C$</span> and evaluated as a finite limit.</li><li><em>Gluing queries</em>, specified by a diagram in <span>$C$</span> and evaluated as a finite colimit. An important special case is <em>linear queries</em>, evaluated as a finite coproduct.</li><li><em>Gluc queries</em> (gluings of conjunctive queries), specified by a diagram of diagrams in <span>$C$</span> and evaluated as a colimit of limits. An important special case is <em>duc queries</em> (disjoint unions of conjunctive queries), evaluated as a coproduct of limits.</li></ol><p>The query category of the data migration is not specified explicitly but is inferred from the queries used in the macro call. Implicit conversion is performed: trivial queries can be coerced to conjunctive queries or gluing queries, and conjunctive queries and gluing queries can both be coerced to gluc queries. Due to the implicit conversion, the resulting functor out of <span>$D$</span> has a single query type and thus a well-defined codomain.</p><p>Syntax for the right-hand sides of object assignments is:</p><ul><li>a symbol, giving object of <span>$C$</span> (query type: trivial)</li><li><code>@product ...</code> (query type: conjunctive)</li><li><code>@unit</code> (alias: <code>@terminal</code>, query type: conjunctive)</li><li><code>@join ...</code> (alias: <code>@limit</code>, query type: conjunctive)</li><li><code>@cases ...</code> (alias: <code>@coproduct</code>, query type: gluing)</li><li><code>@empty</code> (alias: <code>@initial</code>, query type: gluing)</li><li><code>@glue ...</code> (alias: <code>@colimit</code>, query type: gluing)</li></ul><p>Thes query types supported by this macro generalize the kind of queries familiar from relational databases. Less familiar is the concept of a morphism between queries, derived from the concept of a morphism between diagrams in a category. A query morphism is given by a functor between the diagrams&#39; indexing categories together with a natural transformation filling a triangle of the appropriate shape. From a practical standpoint, the most important thing to remember is that a morphism between conjunctive queries is contravariant with respect to the diagram shapes, whereas a morphism between gluing queries is covariant. TODO: Reference for more on this.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../graphics/">« Graphics</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 31 August 2022 02:25">Wednesday 31 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
