<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Programs · Catlab.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Catlab.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Sketches</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/sketches/preorders/">Preorders</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphs/subgraphs/">Algebra of subgraphs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Wiring diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_schema_visualization/">Visualizing Acset Schemas with Graphviz</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../core/">Theories, instances, and expressions</a></li><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li><a class="tocitem" href="../categorical_algebra/">Categorical algebra</a></li><li><a class="tocitem" href="../graphs/">Graphs</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li class="is-active"><a class="tocitem" href>Programs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Programs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Programs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/master/docs/src/apis/programs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="programs"><a class="docs-heading-anchor" href="#programs">Programs</a><a id="programs-1"></a><a class="docs-heading-anchor-permalink" href="#programs" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms" href="#Catlab.Programs.GenerateJuliaPrograms"><code>Catlab.Programs.GenerateJuliaPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Compile or evaluate morphisms as Julia programs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.Block" href="#Catlab.Programs.GenerateJuliaPrograms.Block"><code>Catlab.Programs.GenerateJuliaPrograms.Block</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A block of Julia code with input and output variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.CompileState" href="#Catlab.Programs.GenerateJuliaPrograms.CompileState"><code>Catlab.Programs.GenerateJuliaPrograms.CompileState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Internal state for compilation of morphism into Julia code.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.compile-Tuple{Module, HomExpr}" href="#Catlab.Programs.GenerateJuliaPrograms.compile-Tuple{Module, HomExpr}"><code>Catlab.Programs.GenerateJuliaPrograms.compile</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compile a morphism expression into a Julia function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.compile_block-Tuple{HomExpr, Vector{T} where T}" href="#Catlab.Programs.GenerateJuliaPrograms.compile_block-Tuple{HomExpr, Vector{T} where T}"><code>Catlab.Programs.GenerateJuliaPrograms.compile_block</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compile a morphism expression into a block of Julia code.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.compile_expr-Tuple{HomExpr}" href="#Catlab.Programs.GenerateJuliaPrograms.compile_expr-Tuple{HomExpr}"><code>Catlab.Programs.GenerateJuliaPrograms.compile_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compile a morphism expression into a Julia function expression.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.evaluate-Tuple{HomExpr, Vararg{Any, N} where N}" href="#Catlab.Programs.GenerateJuliaPrograms.evaluate-Tuple{HomExpr, Vararg{Any, N} where N}"><code>Catlab.Programs.GenerateJuliaPrograms.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate a morphism as a function.</p><p>If the morphism will be evaluated only once (possibly with vectorized inputs), then direct evaluation will be much faster than compiling (via <code>compile</code>) and evaluating a standard Julia function.</p><p>Compare with <a href="../core/#Catlab.Syntax.functor-Tuple{Tuple, GATExpr}"><code>functor</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.ParseJuliaPrograms" href="#Catlab.Programs.ParseJuliaPrograms"><code>Catlab.Programs.ParseJuliaPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Parse Julia programs into morphisms represented as wiring diagrams.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram-Tuple{Presentation, Expr}" href="#Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram-Tuple{Presentation, Expr}"><code>Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse a wiring diagram from a Julia function expression.</p><p>For more information, see the corresponding macro <a href="#Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any, Vararg{Any, N} where N}"><code>@program</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any, Vararg{Any, N} where N}" href="#Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any, Vararg{Any, N} where N}"><code>Catlab.Programs.ParseJuliaPrograms.@program</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Parse a wiring diagram from a Julia program.</p><p>For the most part, this is standard Julia code but we take a few liberties with the syntax. Products are represented as tuples. So if <code>x</code> and <code>y</code> are variables of type <span>$X$</span> and <span>$Y$</span>, then <code>(x,y)</code> has type <span>$X \otimes Y$</span>. Also, both <code>()</code> and <code>nothing</code> are interpreted as the monoidal unit <span>$I$</span>.</p><p>Unlike in standard Julia, the call expressions <code>f(x,y)</code> and <code>f((x,y))</code> are equivalent. Consequently, given morphisms <span>$f: W \to X \otimes Y$</span> and <span>$g: X \otimes Y \to Z$</span>, the code</p><pre><code class="language-julia">x, y = f(w)
g(x,y)</code></pre><p>is equivalent to <code>g(f(w))</code>. In standard Julia, at most one of these calls to <code>g</code> would be valid, unless <code>g</code> had multiple signatures.</p><p>The diagonals (copying and deleting) are implicit in the Julia syntax: copying is variable reuse and deleting is variable non-use. For the codiagonals (merging and creating), a special syntax is provided, reinterpreting Julia&#39;s vector literals. The merge of <code>x1</code> and <code>x2</code> is represented by the vector <code>[x1,x2]</code> and creation by the empty vector <code>[]</code>. For example, <code>f([x1,x2])</code> translates to <code>compose(mmerge(X),f)</code>.</p><p>This macro is a wrapper around <a href="#Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram-Tuple{Presentation, Expr}"><code>parse_wiring_diagram</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms" href="#Catlab.Programs.RelationalPrograms"><code>Catlab.Programs.RelationalPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Parse relation expressions in Julia syntax into undirected wiring diagrams.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.parse_relation_diagram-Tuple{Expr}" href="#Catlab.Programs.RelationalPrograms.parse_relation_diagram-Tuple{Expr}"><code>Catlab.Programs.RelationalPrograms.parse_relation_diagram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse an undirected wiring diagram from a relation expression.</p><p>For more information, see the corresponding macro <a href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>@relation</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.@relation-Tuple" href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>Catlab.Programs.RelationalPrograms.@relation</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Construct an undirected wiring diagram using relation notation.</p><p>Unlike the <code>@program</code> macro for directed wiring diagrams, this macro departs from the usual semantics of the Julia programming language. Function calls with n arguments are now interpreted as assertions that an n-ary relation holds at a particular point. For example, the composition of binary relations R ⊆ X × Y and S ⊆ Y × Z can be represented as an undirected wiring diagram by the macro call</p><pre><code class="language-julia">@relation (x,z) where (x::X, y::Y, z::Z) begin
  R(x,y)
  S(y,z)
end</code></pre><p>In general, the context in the <code>where</code> clause defines the set of junctions in the diagram and variable sharing defines the wiring of ports to junctions.</p><p>The ports and junctions of the diagram may be typed or untyped, and the ports may be named or unnamed. Thus four possible types of diagrams may be returned, with the type determined by the form of relation header:</p><ol><li>Untyped, unnamed: <code>@relation (x,z) where (x,y,z) ...</code></li><li>Typed, unnamed: <code>@relation (x,z) where (x::X, y::Y, z::Z) ...</code></li><li>Untyped, named: <code>@relation (out1=x, out2=z) where (x,y,z) ...</code></li><li>Typed, named: <code>@relation (out=1, out2=z) where (x::X, y::Y, z::Z) ...</code></li></ol></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../graphics/">« Graphics</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 27 August 2021 22:04">Friday 27 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
