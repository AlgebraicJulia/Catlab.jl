<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Theories, instances, and expressions · Catlab.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catlab.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Seven Sketches in Compositionality</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/sketches/partitions/">Partitions</a></li><li><a class="tocitem" href="../../generated/sketches/preorders/">Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/meets/">Meets in Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/smc/">Symmetric Monoidal Categories</a></li><li><a class="tocitem" href="../../generated/sketches/cat_elements/">The Category of Elements</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphs/graphs/">The Category of Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/graphs_label/">Labeled Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/subgraphs/">Algebra of subgraphs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Categorical Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/categorical_algebra/diagrams/">Diagrams</a></li><li><a class="tocitem" href="../../generated/categorical_algebra/acset_serialization/">Serializing acsets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Wiring Diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/wd_cset/">Wiring Diagrams as Attributed C-Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/graphviz_graphs/">Drawing graphs in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li class="is-active"><a class="tocitem" href>Theories, instances, and expressions</a><ul class="internal"><li><a class="tocitem" href="#gats"><span>Theories</span></a></li><li><a class="tocitem" href="#instances"><span>Instances</span></a></li><li><a class="tocitem" href="#syntax-systems"><span>Syntax systems</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li><a class="tocitem" href="../categorical_algebra/">Categorical algebra</a></li><li><a class="tocitem" href="../graphs/">Graphs</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li><a class="tocitem" href="../programs/">Programs</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../devdocs/style/">Style Guide for AlgebraicJulia</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Theories, instances, and expressions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Theories, instances, and expressions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/master/docs/src/apis/core.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Theories,-instances,-and-expressions"><a class="docs-heading-anchor" href="#Theories,-instances,-and-expressions">Theories, instances, and expressions</a><a id="Theories,-instances,-and-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Theories,-instances,-and-expressions" title="Permalink"></a></h1><p>At the core of Catlab is a system for defining generalized algebraic structures, such as categories and monoidal categories, and then creating instances of these structures in Julia code. The objects, morphisms, and even higher-order morphisms can also be represented as typed symbolic expressions, as in a computer algebra system. These expressions can be manipulated abstractly or transformed into more concrete representations, such as <a href="../wiring_diagrams/#wiring_diagrams">wiring diagrams</a> or <a href="../programs/#programs">Julia functions</a>.</p><p>The basic elements of this system are:</p><ol><li><p><strong>Generalized algebraic theories</strong> (GATs), defined using the <a href="#Catlab.GAT.@theory-Tuple{Any, Any}"><code>@theory</code></a> macro. Categories and other typed (multisorted) algebraic structures can be defined as GATs. Alternatively, the <a href="#Catlab.GAT.@signature-Tuple{Any, Any}"><code>@signature</code></a> macro can be used when only the signature (not the axioms) of the GAT are to be specified.</p></li><li><p><strong>Instances</strong>, or concrete implementations, of theories, defined using the <a href="#Catlab.GAT.@instance-Tuple{Any, Any}"><code>@instance</code></a> macro.</p></li><li><p><strong>Syntax systems</strong> for theories, defined using the <a href="#Catlab.Syntax.@syntax"><code>@syntax</code></a> macro. These are type-safe expression trees constructed using ordinary Julia functions.</p></li></ol><p>We&#39;ll explain each of these elements in greater detail in the following sections. From the programming perspective, theories can be thought of as <em>interfaces</em> and bear some resemblance to <a href="https://en.wikipedia.org/wiki/Type_class">type classes</a> in languages like Haskell. Both instances and syntax systems can then be thought of as <em>implementations</em> of the interface.</p><h2 id="gats"><a class="docs-heading-anchor" href="#gats">Theories</a><a id="gats-1"></a><a class="docs-heading-anchor-permalink" href="#gats" title="Permalink"></a></h2><p><a href="https://ncatlab.org/nlab/show/generalized+algebraic+theory">Generalized algebraic theories</a> (GATs) are the natural logical system in which to define categories and related algebraic structures. GATs generalize the typed (multisorted) <a href="https://ncatlab.org/nlab/show/algebraic+theory">algebraic theories</a> of <a href="https://en.wikipedia.org/wiki/Universal_algebra">universal algebra</a> by incorporating a fragment of dependent type theory; they are perhaps the simplest dependently typed logics.</p><p>Catlab implements a version of the GAT formalism on top of Julia&#39;s type system, taking advantage of Julia macros to provide a pleasant syntax. GATs are defined using the <a href="#Catlab.GAT.@theory-Tuple{Any, Any}"><code>@theory</code></a> macro.</p><p>For example, the theory of categories could be defined by:</p><pre><code class="language-julia hljs">@theory Category{Ob,Hom} begin
  @op begin
    (→) := Hom
    (⋅) := compose
  end

  Ob::TYPE
  Hom(dom::Ob, codom::Ob)::TYPE

  id(A::Ob)::(A → A)
  compose(f::(A → B), g::(B → C))::(A → C) ⊣ (A::Ob, B::Ob, C::Ob)

  (f ⋅ g) ⋅ h == f ⋅ (g ⋅ h) ⊣ (A::Ob, B::Ob, C::Ob, D::Ob,
                                f::(A → B), g::(B → C), h::(C → D))
  f ⋅ id(B) == f ⊣ (A::Ob, B::Ob, f::(A → B))
  id(A) ⋅ f == f ⊣ (A::Ob, B::Ob, f::(A → B))
end</code></pre><p>The code is simplified only slightly from the official Catlab definition of <code>Category</code>. The theory has two <em>type constructors</em>, <code>Ob</code> (object) and <code>Hom</code> (morphism). The type <code>Hom</code> is a dependent type, depending on two objects, named <code>dom</code> (domain) and <code>codom</code> (codomain). The theory has two <em>term constructors</em>, <code>id</code> (identity) and <code>compose</code> (composition).</p><p>Notice how the return types of the term constructors depend on the argument values. For example, the term <code>id(A)</code> has type <code>Hom(A,A)</code>. The term constructor <code>compose</code> also uses <em>context variables</em>, listed to the right of the <code>⊣</code> symbol. These context variables can also be defined after a <code>where</code> clause, but the left hand side must be surrounded by parentheses. This allows us to write <code>compose(f,g)</code>, instead of the more verbose <code>compose(A,B,C,f,g)</code> (for discussion, see Cartmell, 1986, Sec 10: Informal syntax).</p><p>Notice the <code>@op</code> call where we can create method aliases that can then be used throughout the rest of the theory and outside of definition. We can either use this block notation, or a single line notation such as <code>@op (⋅) := compose</code> to define a single alias. Here we utilize this functionality by replacing the <code>Hom</code> and <code>compose</code> methods with their equivalent Unicode characters, <code>→</code> and <code>⋅</code> respectively. These aliases are also automatically available to definitions that inherit a theory that already has the alias defined.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In general, a GAT consists of a <em>signature</em>, defining the types and terms of the theory, and a set of <em>axioms</em>, the equational laws satisfied by models of the theory. The theory of categories, for example, has axioms of unitality and associativity. At present, Catlab supports the specification of both signatures and the axioms, but is not currently utilizing the axiom definitions in any way, reflecting its status as a programming library, not a proof assistant. It is the programmer&#39;s responsibility to ensure any declared instances of an algebraic structure satisfy its axioms.</p></div></div><h4 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h4><ul><li>Cartmell, 1986: Generalized algebraic theories and contextual categories, <a href="https://doi.org/10.1016/0168-0072(86)90053-9">DOI:10.1016/0168-0072(86)90053-9</a></li><li>Cartmell, 1978, PhD thesis: <em>Generalized algebraic theories and contextual categories</em></li><li>Pitts, 1995: Categorical logic, Sec 6: Dependent types</li></ul><h2 id="instances"><a class="docs-heading-anchor" href="#instances">Instances</a><a id="instances-1"></a><a class="docs-heading-anchor-permalink" href="#instances" title="Permalink"></a></h2><p>A theory can have one or more <em>instances</em>, or instantiations by ordinary Julia types and functions. This feature builds on Julia&#39;s support for generic functions with <a href="https://docs.julialang.org/en/v1/manual/methods/">multiple dispatch</a>.</p><p>Instances are declared using the <a href="#Catlab.GAT.@instance-Tuple{Any, Any}"><code>@instance</code></a> macro. In an instance of a theory, each theory type is mapped to a Julia type and each term is mapped to a Julia method of the same name. For example, the category of matrices could be defined as an instance of the theory <code>Category</code> defined above:</p><pre><code class="language-julia hljs">using LinearAlgebra: I

struct MatrixDomain
  eltype::Type
  dim::Int
end

@instance Category{MatrixDomain, Matrix} begin
  dom(M::Matrix) = MatrixDomain(eltype(M), size(M,1))
  codom(M::Matrix) = MatrixDomain(eltype(M), size(M,2))

  id(m::MatrixDomain) = Matrix{m.eltype}(I, m.dim, m.dim)
  compose(M::Matrix, N::Matrix) = M*N
end</code></pre><pre><code class="language-julia hljs">A = Matrix{Float64}([0 1; 1 0])
id(dom(A))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 1.0  0.0
 0.0  1.0</code></pre><p>In this instance, the theory type <code>Ob</code> is mapped to the custom Julia type <code>MatrixDomain</code>. The latter type has two fields, a Julia type <code>eltype</code> representing a field <span>$k$</span> and an integer <code>dim</code> representing the dimensionality <span>$n$</span>, and so can be interpreted as the <span>$n$</span>-dimensional vector space <span>$k^n$</span>. The theory <code>Hom</code> is mapped to the standard Julia type <code>Matrix</code>.</p><h2 id="syntax-systems"><a class="docs-heading-anchor" href="#syntax-systems">Syntax systems</a><a id="syntax-systems-1"></a><a class="docs-heading-anchor-permalink" href="#syntax-systems" title="Permalink"></a></h2><p>Theories can also be instantiated as systems of symbolic expressions, using the <a href="#Catlab.Syntax.@syntax"><code>@syntax</code></a> macro. The symbolic expressions are expression trees, as commonly used in computer algebra systems. They are similar to Julia&#39;s <code>Expr</code> type but they are instead subtyped from Catlab&#39;s <a href="#Catlab.Syntax.GATExpr"><code>GATExpr</code></a> type and they have a more refined type hierarchy.</p><p>A single theory can have different syntax systems, treating different terms as primitive or performing different simplication or normalization procedures. Catlab tries to make it easy to define new syntax systems. Many of the theories included with Catlab have default syntax systems, but the user is encouraged to define their own to suit their needs.</p><p>To get started, you can always call the <code>@syntax</code> macro with an empty body. Below, we subtype from Catlab&#39;s abstract types <code>ObExpr</code> and <code>HomExpr</code> to enable LaTeX pretty-printing and other convenient features, but this is not required.</p><pre><code class="language-julia hljs">@syntax CategoryExprs{ObExpr, HomExpr} Category begin
end

A, B, C, D = [ Ob(CategoryExprs.Ob, X) for X in [:A, :B, :C, :D] ]
f, g, h = Hom(:f, A, B), Hom(:g, B, C), Hom(:h, C, D)

compose(compose(f,g),h)</code></pre><p class="math-container">\[\left(f \cdot g\right) \cdot h : A \to D\]</p><p>The resulting symbolic expressions perform no simplification. For example, the associativity law is not satisfied:</p><pre><code class="language-julia hljs">compose(compose(f,g),h) == compose(f,compose(g,h))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><p>Thus, unlike instances of a theory, syntactic expressions are not expected to obey all the axioms of the theory.</p><p>However, the user may supply logic in the body of the <code>@syntax</code> macro to enforce the axioms or perform other kinds of simplification. Below, we use the <a href="#Catlab.Rewrite.associate-Tuple{E} where E&lt;:GATExpr"><code>associate</code></a> function provided by Catlab to convert the binary expressions representing composition into <span>$n$</span>-ary expressions for any number <span>$n$</span>. The option <code>strict=true</code> tells Catlab to check that the domain and codomain objects are strictly equal and throw an error if they are not.</p><pre><code class="language-julia hljs">@syntax SimplifyingCategoryExprs{ObExpr, HomExpr} Category begin
  compose(f::Hom, g::Hom) = associate(new(f,g; strict=true))
end

A, B, C, D = [ Ob(SimplifyingCategoryExprs.Ob, X) for X in [:A, :B, :C, :D] ]
f, g, h = Hom(:f, A, B), Hom(:g, B, C), Hom(:h, C, D)

compose(compose(f,g),h)</code></pre><p class="math-container">\[f \cdot g \cdot h : A \to D\]</p><p>Now the associativity law <em>is</em> satisfied:</p><pre><code class="language-julia hljs">compose(compose(f,g),h) == compose(f,compose(g,h))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h3 id="Primitive-versus-derived-operations"><a class="docs-heading-anchor" href="#Primitive-versus-derived-operations">Primitive versus derived operations</a><a id="Primitive-versus-derived-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-versus-derived-operations" title="Permalink"></a></h3><p>In some algebraic structures, there is a choice as to which operations should be considered primitive and which should be derived. For example, in a <a href="https://ncatlab.org/nlab/show/cartesian+monoidal+category">cartesian monoidal category</a>, the copy operation <span>$\Delta_X: X \to X \otimes X$</span> can be defined in terms of the pairing operation <span>$\langle f, g \rangle$</span>, or vice versa. In addition, the projections <span>$\pi_{X,Y}: X \otimes Y \to X$</span> and <span>$\pi_{X,Y}&#39;: X \otimes Y \to Y$</span> can be defined in terms of the deleting operation (terminal morphism) or left as primitive.</p><p>In Catlab, the recommended way to deal with such situations is to define <em>all</em> the operations in the theory and then allow particular syntax systems to determine which operations, if any, will be derived from others. In the case of the cartesian monoidal category, we could define a signature <code>CartesianCategory</code> by inheriting from the builtin theory <code>SymmetricMonoidalCategory</code>.</p><pre><code class="language- hljs">@signature CartesianCategory{Ob,Hom} &lt;: SymmetricMonoidalCategory{Ob,Hom} begin
  mcopy(A::Ob)::(A → (A ⊗ A))
  delete(A::Ob)::(A → munit())

  pair(f::(A → B), g::(A → C))::(A → (B ⊗ C)) ⊣ (A::Ob, B::Ob, C::Ob)
  proj1(A::Ob, B::Ob)::((A ⊗ B) → A)
  proj2(A::Ob, B::Ob)::((A ⊗ B) → B)
end
nothing # hide</code></pre><p>We could then define the copying operation in terms of the pairing.</p><pre><code class="language- hljs">@syntax CartesianCategoryExprsV1{ObExpr,HomExpr} CartesianCategory begin
  mcopy(A::Ob) = pair(id(A), id(A))
end

A = Ob(CartesianCategoryExprsV1.Ob, :A)
mcopy(A)</code></pre><p>Alternatively, we could define the pairing and projections in terms of the copying and deleting operations.</p><pre><code class="language- hljs">@syntax CartesianCategoryExprsV2{ObExpr,HomExpr} CartesianCategory begin
  pair(f::Hom, g::Hom) = compose(mcopy(dom(f)), otimes(f,g))
  proj1(A::Ob, B::Ob) = otimes(id(A), delete(B))
  proj2(A::Ob, B::Ob) = otimes(delete(A), id(B))
end

A, B, C = [ Ob(CartesianCategoryExprsV2.Ob, X) for X in [:A, :B, :C] ]
f, g = Hom(:f, A, B), Hom(:g, A, C)
pair(f, g)</code></pre><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catlab.GAT" href="#Catlab.GAT"><code>Catlab.GAT</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Generalized algebraic theories (GATs) in Julia.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.GAT.invoke_term-Tuple{Type, Tuple, Symbol, Vararg{Any}}" href="#Catlab.GAT.invoke_term-Tuple{Type, Tuple, Symbol, Vararg{Any}}"><code>Catlab.GAT.invoke_term</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Invoke a term constructor by name on an instance.</p><p>This method provides reflection for GATs. In everyday use the generic method for the constructor should be called directly, not through this function.</p><p>Cf. Julia&#39;s builtin <code>invoke()</code> function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.GAT.theory" href="#Catlab.GAT.theory"><code>Catlab.GAT.theory</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Retrieve generalized algebraic theory associated with abstract type.</p><p>For example, if <code>Category</code> is imported from <code>Catlab.Theories</code>, then <code>theory(Category)</code>returns the theory of a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.GAT.@instance-Tuple{Any, Any}" href="#Catlab.GAT.@instance-Tuple{Any, Any}"><code>Catlab.GAT.@instance</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define an <em>instance</em> of a generalized algebraic theory (GAT).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.GAT.@signature-Tuple{Any, Any}" href="#Catlab.GAT.@signature-Tuple{Any, Any}"><code>Catlab.GAT.@signature</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define a signature for a generalized algebraic theory (GAT).</p><p>A signature is the same as a theory, except it may not contain axioms, and therefore only three kinds of things can go in the signature body:</p><ol><li>Type constructors, indicated by the special type <code>TYPE</code>, e.g., <code>Hom(X::Ob,Y::Ob)::TYPE</code></li><li>Term constructors, e.g., <code>id(X::Ob)::Hom(X,X)</code></li><li>Function aliases, e.g., <code>@op Hom :→</code></li></ol><p>A signature can extend existing theories (at present only one).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.GAT.@theory-Tuple{Any, Any}" href="#Catlab.GAT.@theory-Tuple{Any, Any}"><code>Catlab.GAT.@theory</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define a generalized algebraic theory (GAT).</p><p>Four kinds of things can go in the theory body:</p><ol><li>Type constructors, indicated by the special type <code>TYPE</code>, e.g., <code>Hom(X::Ob,Y::Ob)::TYPE</code></li><li>Term constructors, e.g., <code>id(X::Ob)::Hom(X,X)</code></li><li>Function aliases, e.g., <code>@op Hom :→</code></li><li>Equality axioms, e.g., <code>f ⋅ id(B) == f ⊣ (A::Ob, B::Ob, f::(A → B))</code></li></ol><p>A theory can extend existing theories (at present only one).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Syntax" href="#Catlab.Syntax"><code>Catlab.Syntax</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Syntax systems for generalized algebraic theories (GATs).</p><p>In general, a single theory may have many different syntaxes. The purpose of this module to enable the simple but flexible construction of syntax systems.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Syntax.GATExpr" href="#Catlab.Syntax.GATExpr"><code>Catlab.Syntax.GATExpr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Base type for expression in the syntax of a GAT.</p><p>We define Julia types for each <em>type constructor</em> in the theory, e.g., object, morphism, and 2-morphism in the theory of 2-categories. Of course, Julia&#39;s type system does not support dependent types, so the type parameters are incorporated in the Julia types. (They are stored as extra data in the expression instances.)</p><p>The concrete types are structurally similar to the core type <code>Expr</code> in Julia. However, the <em>term constructor</em> is represented as a type parameter, rather than as a <code>head</code> field. This makes dispatch using Julia&#39;s type system more convenient.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Meta.show_sexpr-Tuple{GATExpr}" href="#Base.Meta.show_sexpr-Tuple{GATExpr}"><code>Base.Meta.show_sexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Show the syntax expression as an S-expression.</p><p>Cf. the standard library function <code>Meta.show_sexpr</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.GAT.invoke_term-Tuple{Module, Symbol, Vararg{Any}}" href="#Catlab.GAT.invoke_term-Tuple{Module, Symbol, Vararg{Any}}"><code>Catlab.GAT.invoke_term</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Invoke a term constructor by name in a syntax system.</p><p>This method provides reflection for syntax systems. In everyday use the generic method for the constructor should be called directly, not through this function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Syntax.functor-Tuple{Tuple, GATExpr}" href="#Catlab.Syntax.functor-Tuple{Tuple, GATExpr}"><code>Catlab.Syntax.functor</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Functor from GAT expression to GAT instance.</p><p>Strictly speaking, we should call these &quot;structure-preserving functors&quot; or, better, &quot;model homomorphisms of GATs&quot;. But this is a category theory library, so we&#39;ll go with the simpler &quot;functor&quot;.</p><p>A functor is completely determined by its action on the generators. There are several ways to specify this mapping:</p><ol><li><p>Specify a Julia instance type for each GAT type, using the required <code>types</code> tuple. For this to work, the generator constructors must be defined for the instance types.</p></li><li><p>Explicitly map each generator term to an instance value, using the <code>generators</code> dictionary.</p></li><li><p>For each GAT type (e.g., object and morphism), specify a function mapping generator terms of that type to an instance value, using the <code>terms</code> dictionary.</p></li></ol><p>The <code>terms</code> dictionary can also be used for special handling of non-generator expressions. One use case for this capability is defining forgetful functors, which map non-generators to generators.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Syntax.parse_json_sexpr-Tuple{Module, Any}" href="#Catlab.Syntax.parse_json_sexpr-Tuple{Module, Any}"><code>Catlab.Syntax.parse_json_sexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Deserialize expression from JSON-able S-expression.</p><p>If <code>symbols</code> is true (the default), strings are converted to symbols.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Syntax.show_latex-Tuple{GATExpr}" href="#Catlab.Syntax.show_latex-Tuple{GATExpr}"><code>Catlab.Syntax.show_latex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Show the expression in infix notation using LaTeX math.</p><p>Does <em>not</em> include <code>$</code> or <code>\[begin|end]{equation}</code> delimiters.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Syntax.show_unicode-Tuple{GATExpr}" href="#Catlab.Syntax.show_unicode-Tuple{GATExpr}"><code>Catlab.Syntax.show_unicode</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Show the expression in infix notation using Unicode symbols.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Syntax.to_json_sexpr-Tuple{GATExpr}" href="#Catlab.Syntax.to_json_sexpr-Tuple{GATExpr}"><code>Catlab.Syntax.to_json_sexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Serialize expression as JSON-able S-expression.</p><p>The format is an S-expression encoded as JSON, e.g., &quot;compose(f,g)&quot; is represented as [&quot;compose&quot;, f, g].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Syntax.@syntax" href="#Catlab.Syntax.@syntax"><code>Catlab.Syntax.@syntax</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define a <em>syntax</em> system for a generalized algebraic theory (GAT).</p><p>A syntax system consists of Julia types (with top type <code>GATExpr</code>) for each type constructor in the signature, plus Julia functions for</p><ol><li><em>Generators</em>: creating new generator terms, e.g., objects or morphisms</li><li><em>Accessors</em>: accessing type parameters, e.g., domains and codomains</li><li><em>Term constructors</em>: applying term constructors, e.g., composition and monoidal products</li></ol><p>Julia code for all this is generated by the macro. Any of the methods can be overriden with custom simplification logic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Rewrite" href="#Catlab.Rewrite"><code>Catlab.Rewrite</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Rewriting for GAT expressions.</p><p>The current content of this module is just a stopgap until I can implement a generic term rewriting system.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Rewrite.associate-Tuple{E} where E&lt;:GATExpr" href="#Catlab.Rewrite.associate-Tuple{E} where E&lt;:GATExpr"><code>Catlab.Rewrite.associate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simplify associative binary operation.</p><p>Maintains the normal form <code>op(e1,e2,...)</code> where <code>e1</code>,<code>e2</code>,... are expressions that are <em>not</em> applications of <code>op()</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Rewrite.associate_unit-Tuple{GATExpr, Function}" href="#Catlab.Rewrite.associate_unit-Tuple{GATExpr, Function}"><code>Catlab.Rewrite.associate_unit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simplify associative binary operation with unit.</p><p>Reduces a freely generated (typed) monoid to normal form.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Rewrite.associate_unit_inv-Union{Tuple{E}, Tuple{E, Function, Function}} where E&lt;:GATExpr" href="#Catlab.Rewrite.associate_unit_inv-Union{Tuple{E}, Tuple{E, Function, Function}} where E&lt;:GATExpr"><code>Catlab.Rewrite.associate_unit_inv</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simplify associative binary operation with unit and inverses.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Rewrite.distribute_unary-Tuple{GATExpr, Function, Function}" href="#Catlab.Rewrite.distribute_unary-Tuple{GATExpr, Function, Function}"><code>Catlab.Rewrite.distribute_unary</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Distribute unary operation over binary operation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Rewrite.involute-Tuple{GATExpr}" href="#Catlab.Rewrite.involute-Tuple{GATExpr}"><code>Catlab.Rewrite.involute</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simplify involutive unary operation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Present" href="#Catlab.Present"><code>Catlab.Present</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Finite presentations of a model of a generalized algebraic theory (GAT).</p><p>We support two methods for defining models of a GAT: as Julia objects using the <code>@instance</code> macro and as syntactic objects using the <code>@present</code> macro. Instances are useful for casting generic data structures, such as matrices, abstract tensor systems, and wiring diagrams, in categorical language. Presentations define small categories by generators and relations and are useful in applications like knowledge representation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Present.add_definition!-Tuple{Presentation, Symbol, GATExpr}" href="#Catlab.Present.add_definition!-Tuple{Presentation, Symbol, GATExpr}"><code>Catlab.Present.add_definition!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a generator defined by an equation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Present.add_equation!-Tuple{Presentation, GATExpr, GATExpr}" href="#Catlab.Present.add_equation!-Tuple{Presentation, GATExpr, GATExpr}"><code>Catlab.Present.add_equation!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add an equation between terms to a presentation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Present.add_generator!-Tuple{Presentation, Any}" href="#Catlab.Present.add_generator!-Tuple{Presentation, Any}"><code>Catlab.Present.add_generator!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a generator to a presentation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Present.add_generators!-Tuple{Presentation, Any}" href="#Catlab.Present.add_generators!-Tuple{Presentation, Any}"><code>Catlab.Present.add_generators!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add iterable of generators to a presentation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Present.equations-Tuple{Presentation}" href="#Catlab.Present.equations-Tuple{Presentation}"><code>Catlab.Present.equations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get all equations of a presentation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Present.generator-Tuple{Presentation, Any}" href="#Catlab.Present.generator-Tuple{Presentation, Any}"><code>Catlab.Present.generator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Retrieve generators by name.</p><p>Generators can also be retrieved using indexing notation, so that <code>generator(pres, name)</code> and <code>pres[name]</code> are equivalent.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Present.generator_index-Union{Tuple{Name}, Tuple{T}, Tuple{Presentation{T, Name}, Name}} where {T, Name}" href="#Catlab.Present.generator_index-Union{Tuple{Name}, Tuple{T}, Tuple{Presentation{T, Name}, Name}} where {T, Name}"><code>Catlab.Present.generator_index</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the index of a generator, relative to generators of same GAT type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Present.generators-Tuple{Presentation}" href="#Catlab.Present.generators-Tuple{Presentation}"><code>Catlab.Present.generators</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get all generators of a presentation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Present.has_generator-Tuple{Presentation, Any}" href="#Catlab.Present.has_generator-Tuple{Presentation, Any}"><code>Catlab.Present.has_generator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Does the presentation contain a generator with the given name?</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Present.@present-Tuple{Any, Any}" href="#Catlab.Present.@present-Tuple{Any, Any}"><code>Catlab.Present.@present</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define a presentation using a convenient syntax.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../generated/graphics/layouts_vs_drawings/">« Layouts versus drawings of wiring diagrams</a><a class="docs-footer-nextpage" href="../theories/">Standard library of theories »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 15 March 2023 22:47">Wednesday 15 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
