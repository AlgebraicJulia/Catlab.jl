<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Theories, instances, and expressions · Catlab.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catlab.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Seven Sketches in Compositionality</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/sketches/partitions/">Partitions</a></li><li><a class="tocitem" href="../../generated/sketches/preorders/">Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/meets/">Meets in Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/smc/">Symmetric Monoidal Categories</a></li><li><a class="tocitem" href="../../generated/sketches/cat_elements/">The Category of Elements</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphs/graphs/">The Category of Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/graphs_label/">Labeled Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/subgraphs/">Algebra of subgraphs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Categorical Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/categorical_algebra/diagrams/">Diagrams</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Wiring Diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/wd_cset/">Wiring Diagrams as Attributed C-Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/graphviz_graphs/">Drawing graphs in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li class="is-active"><a class="tocitem" href>Theories, instances, and expressions</a><ul class="internal"><li><a class="tocitem" href="#gats"><span>Theories</span></a></li><li><a class="tocitem" href="#instances"><span>Instances</span></a></li><li><a class="tocitem" href="#syntax-systems"><span>Syntax systems</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li><a class="tocitem" href="../categorical_algebra/">Categorical algebra</a></li><li><a class="tocitem" href="../graphs/">Graphs</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li><a class="tocitem" href="../programs/">Programs</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../devdocs/style/">Style Guide for AlgebraicJulia</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Theories, instances, and expressions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Theories, instances, and expressions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/master/docs/src/apis/core.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Theories,-instances,-and-expressions"><a class="docs-heading-anchor" href="#Theories,-instances,-and-expressions">Theories, instances, and expressions</a><a id="Theories,-instances,-and-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Theories,-instances,-and-expressions" title="Permalink"></a></h1><p>At the core of Catlab is a system for defining generalized algebraic structures, such as categories and monoidal categories, and then creating instances of these structures in Julia code. The objects, morphisms, and even higher-order morphisms can also be represented as typed symbolic expressions, as in a computer algebra system. These expressions can be manipulated abstractly or transformed into more concrete representations, such as <a href="../wiring_diagrams/#wiring_diagrams">wiring diagrams</a> or <a href="../programs/#programs">Julia functions</a>.</p><p>The basic elements of this system are:</p><ol><li><p><strong>Generalized algebraic theories</strong> (GATs), defined using the <a href="apis/@ref"><code>@theory</code></a> macro. Categories and other typed (multisorted) algebraic structures can be defined as GATs. Alternatively, the <a href="apis/@ref"><code>@signature</code></a> macro can be used when only the signature (not the axioms) of the GAT are to be specified.</p></li><li><p><strong>Instances</strong>, or concrete implementations, of theories, defined using the <a href="apis/@ref"><code>@instance</code></a> macro.</p></li><li><p><strong>Syntax systems</strong> for theories, defined using the <a href="apis/@ref"><code>@syntax</code></a> macro. These are type-safe expression trees constructed using ordinary Julia functions.</p></li></ol><p>We&#39;ll explain each of these elements in greater detail in the following sections. From the programming perspective, theories can be thought of as <em>interfaces</em> and bear some resemblance to <a href="https://en.wikipedia.org/wiki/Type_class">type classes</a> in languages like Haskell. Both instances and syntax systems can then be thought of as <em>implementations</em> of the interface.</p><h2 id="gats"><a class="docs-heading-anchor" href="#gats">Theories</a><a id="gats-1"></a><a class="docs-heading-anchor-permalink" href="#gats" title="Permalink"></a></h2><p><a href="https://ncatlab.org/nlab/show/generalized+algebraic+theory">Generalized algebraic theories</a> (GATs) are the natural logical system in which to define categories and related algebraic structures. GATs generalize the typed (multisorted) <a href="https://ncatlab.org/nlab/show/algebraic+theory">algebraic theories</a> of <a href="https://en.wikipedia.org/wiki/Universal_algebra">universal algebra</a> by incorporating a fragment of dependent type theory; they are perhaps the simplest dependently typed logics.</p><p>Catlab implements a version of the GAT formalism on top of Julia&#39;s type system, taking advantage of Julia macros to provide a pleasant syntax. GATs are defined using the <a href="apis/@ref"><code>@theory</code></a> macro.</p><p>For example, the theory of categories could be defined by:</p><pre><code class="language-julia hljs">@theory ThCategory{Ob,Hom} begin
  @op begin
    (→) := Hom
    (⋅) := compose
  end

  Ob::TYPE
  Hom(dom::Ob, codom::Ob)::TYPE

  id(A::Ob)::(A → A)
  compose(f::(A → B), g::(B → C))::(A → C) ⊣ (A::Ob, B::Ob, C::Ob)

  (f ⋅ g) ⋅ h == f ⋅ (g ⋅ h) ⊣ (A::Ob, B::Ob, C::Ob, D::Ob,
                                f::(A → B), g::(B → C), h::(C → D))
  f ⋅ id(B) == f ⊣ (A::Ob, B::Ob, f::(A → B))
  id(A) ⋅ f == f ⊣ (A::Ob, B::Ob, f::(A → B))
end</code></pre><p>The code is simplified only slightly from the official Catlab definition of <code>ThCategory</code>. The theory has two <em>type constructors</em>, <code>Ob</code> (object) and <code>Hom</code> (morphism). The type <code>Hom</code> is a dependent type, depending on two objects, named <code>dom</code> (domain) and <code>codom</code> (codomain). The theory has two <em>term constructors</em>, <code>id</code> (identity) and <code>compose</code> (composition).</p><p>Notice how the return types of the term constructors depend on the argument values. For example, the term <code>id(A)</code> has type <code>Hom(A,A)</code>. The term constructor <code>compose</code> also uses <em>context variables</em>, listed to the right of the <code>⊣</code> symbol. These context variables can also be defined after a <code>where</code> clause, but the left hand side must be surrounded by parentheses. This allows us to write <code>compose(f,g)</code>, instead of the more verbose <code>compose(A,B,C,f,g)</code> (for discussion, see Cartmell, 1986, Sec 10: Informal syntax).</p><p>Notice the <code>@op</code> call where we can create method aliases that can then be used throughout the rest of the theory and outside of definition. We can either use this block notation, or a single line notation such as <code>@op (⋅) := compose</code> to define a single alias. Here we utilize this functionality by replacing the <code>Hom</code> and <code>compose</code> methods with their equivalent Unicode characters, <code>→</code> and <code>⋅</code> respectively. These aliases are also automatically available to definitions that inherit a theory that already has the alias defined.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In general, a GAT consists of a <em>signature</em>, defining the types and terms of the theory, and a set of <em>axioms</em>, the equational laws satisfied by models of the theory. The theory of categories, for example, has axioms of unitality and associativity. At present, Catlab supports the specification of both signatures and the axioms, but is not currently utilizing the axiom definitions in any way, reflecting its status as a programming library, not a proof assistant. It is the programmer&#39;s responsibility to ensure any declared instances of an algebraic structure satisfy its axioms.</p></div></div><h4 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h4><ul><li>Cartmell, 1986: Generalized algebraic theories and contextual categories, <a href="https://doi.org/10.1016/0168-0072(86)90053-9">DOI:10.1016/0168-0072(86)90053-9</a></li><li>Cartmell, 1978, PhD thesis: <em>Generalized algebraic theories and contextual categories</em></li><li>Pitts, 1995: Categorical logic, Sec 6: Dependent types</li></ul><h2 id="instances"><a class="docs-heading-anchor" href="#instances">Instances</a><a id="instances-1"></a><a class="docs-heading-anchor-permalink" href="#instances" title="Permalink"></a></h2><p>A theory can have one or more <em>instances</em>, or instantiations by ordinary Julia types and functions. This feature builds on Julia&#39;s support for generic functions with <a href="https://docs.julialang.org/en/v1/manual/methods/">multiple dispatch</a>.</p><p>Instances are declared using the <a href="apis/@ref"><code>@instance</code></a> macro. In an instance of a theory, each theory type is mapped to a Julia type and each term is mapped to a Julia method of the same name. For example, the category of matrices could be defined as an instance of the theory <code>Category</code> defined above:</p><pre><code class="language-julia hljs">using LinearAlgebra: I

struct MatrixDomain
  eltype::Type
  dim::Int
end

@instance ThCategory{MatrixDomain, Matrix} begin
  dom(M::Matrix) = MatrixDomain(eltype(M), size(M,1))
  codom(M::Matrix) = MatrixDomain(eltype(M), size(M,2))

  id(m::MatrixDomain) = Matrix{m.eltype}(I, m.dim, m.dim)
  compose(M::Matrix, N::Matrix) = M*N
end</code></pre><pre><code class="language-julia hljs">A = Matrix{Float64}([0 1; 1 0])
id(dom(A))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 1.0  0.0
 0.0  1.0</code></pre><p>In this instance, the theory type <code>Ob</code> is mapped to the custom Julia type <code>MatrixDomain</code>. The latter type has two fields, a Julia type <code>eltype</code> representing a field <span>$k$</span> and an integer <code>dim</code> representing the dimensionality <span>$n$</span>, and so can be interpreted as the <span>$n$</span>-dimensional vector space <span>$k^n$</span>. The theory <code>Hom</code> is mapped to the standard Julia type <code>Matrix</code>.</p><h2 id="syntax-systems"><a class="docs-heading-anchor" href="#syntax-systems">Syntax systems</a><a id="syntax-systems-1"></a><a class="docs-heading-anchor-permalink" href="#syntax-systems" title="Permalink"></a></h2><p>Theories can also be instantiated as systems of symbolic expressions, using the <a href="apis/@ref"><code>@syntax</code></a> macro. The symbolic expressions are expression trees, as commonly used in computer algebra systems. They are similar to Julia&#39;s <code>Expr</code> type but they are instead subtyped from Catlab&#39;s <a href="apis/@ref"><code>GATExpr</code></a> type and they have a more refined type hierarchy.</p><p>A single theory can have different syntax systems, treating different terms as primitive or performing different simplication or normalization procedures. Catlab tries to make it easy to define new syntax systems. Many of the theories included with Catlab have default syntax systems, but the user is encouraged to define their own to suit their needs.</p><p>To get started, you can always call the <code>@syntax</code> macro with an empty body. Below, we subtype from Catlab&#39;s abstract types <code>ObExpr</code> and <code>HomExpr</code> to enable LaTeX pretty-printing and other convenient features, but this is not required.</p><pre><code class="language-julia hljs">@syntax CategoryExprs{ObExpr, HomExpr} ThCategory begin
end

A, B, C, D = [ Ob(CategoryExprs.Ob, X) for X in [:A, :B, :C, :D] ]
f, g, h = Hom(:f, A, B), Hom(:g, B, C), Hom(:h, C, D)

compose(compose(f,g),h)</code></pre><p class="math-container">\[\left(f \cdot g\right) \cdot h : A \to D\]</p><p>The resulting symbolic expressions perform no simplification. For example, the associativity law is not satisfied:</p><pre><code class="language-julia hljs">compose(compose(f,g),h) == compose(f,compose(g,h))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><p>Thus, unlike instances of a theory, syntactic expressions are not expected to obey all the axioms of the theory.</p><p>However, the user may supply logic in the body of the <code>@syntax</code> macro to enforce the axioms or perform other kinds of simplification. Below, we use the <a href="apis/@ref"><code>associate</code></a> function provided by Catlab to convert the binary expressions representing composition into <span>$n$</span>-ary expressions for any number <span>$n$</span>. The option <code>strict=true</code> tells Catlab to check that the domain and codomain objects are strictly equal and throw an error if they are not.</p><pre><code class="language-julia hljs">@syntax SimplifyingCategoryExprs{ObExpr, HomExpr} ThCategory begin
  compose(f::Hom, g::Hom) = associate(new(f,g; strict=true))
end

A, B, C, D = [ Ob(SimplifyingCategoryExprs.Ob, X) for X in [:A, :B, :C, :D] ]
f, g, h = Hom(:f, A, B), Hom(:g, B, C), Hom(:h, C, D)

compose(compose(f,g),h)</code></pre><p class="math-container">\[f \cdot g \cdot h : A \to D\]</p><p>Now the associativity law <em>is</em> satisfied:</p><pre><code class="language-julia hljs">compose(compose(f,g),h) == compose(f,compose(g,h))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h3 id="Primitive-versus-derived-operations"><a class="docs-heading-anchor" href="#Primitive-versus-derived-operations">Primitive versus derived operations</a><a id="Primitive-versus-derived-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-versus-derived-operations" title="Permalink"></a></h3><p>In some algebraic structures, there is a choice as to which operations should be considered primitive and which should be derived. For example, in a <a href="https://ncatlab.org/nlab/show/cartesian+monoidal+category">cartesian monoidal category</a>, the copy operation <span>$\Delta_X: X \to X \otimes X$</span> can be defined in terms of the pairing operation <span>$\langle f, g \rangle$</span>, or vice versa. In addition, the projections <span>$\pi_{X,Y}: X \otimes Y \to X$</span> and <span>$\pi_{X,Y}&#39;: X \otimes Y \to Y$</span> can be defined in terms of the deleting operation (terminal morphism) or left as primitive.</p><p>In Catlab, the recommended way to deal with such situations is to define <em>all</em> the operations in the theory and then allow particular syntax systems to determine which operations, if any, will be derived from others. In the case of the cartesian monoidal category, we could define a signature <code>CartesianCategory</code> by inheriting from the builtin theory <code>SymmetricMonoidalCategory</code>.</p><pre><code class="language-julia hljs">@signature ThCartesianCategory{Ob,Hom} &lt;: ThSymmetricMonoidalCategory{Ob,Hom} begin
  mcopy(A::Ob)::(A → (A ⊗ A))
  delete(A::Ob)::(A → munit())

  pair(f::(A → B), g::(A → C))::(A → (B ⊗ C)) ⊣ (A::Ob, B::Ob, C::Ob)
  proj1(A::Ob, B::Ob)::((A ⊗ B) → A)
  proj2(A::Ob, B::Ob)::((A ⊗ B) → B)
end</code></pre><p>We could then define the copying operation in terms of the pairing.</p><pre><code class="language-julia hljs">@syntax CartesianCategoryExprsV1{ObExpr,HomExpr} ThCartesianCategory begin
  mcopy(A::Ob) = pair(id(A), id(A))
end

A = Ob(CartesianCategoryExprsV1.Ob, :A)
mcopy(A)</code></pre><p class="math-container">\[\mathop{\mathrm{pair}}\left[\mathrm{id}_{A},\mathrm{id}_{A}\right] : A \to A \otimes A\]</p><p>Alternatively, we could define the pairing and projections in terms of the copying and deleting operations.</p><pre><code class="language-julia hljs">@syntax CartesianCategoryExprsV2{ObExpr,HomExpr} ThCartesianCategory begin
  pair(f::Hom, g::Hom) = compose(mcopy(dom(f)), otimes(f,g))
  proj1(A::Ob, B::Ob) = otimes(id(A), delete(B))
  proj2(A::Ob, B::Ob) = otimes(delete(A), id(B))
end

A, B, C = [ Ob(CartesianCategoryExprsV2.Ob, X) for X in [:A, :B, :C] ]
f, g = Hom(:f, A, B), Hom(:g, A, C)
pair(f, g)</code></pre><p class="math-container">\[\Delta_{A} \cdot \left(f \otimes g\right) : A \to B \otimes C\]</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><pre><code class="language- hljs">Modules = [
  GAT,
  Syntax,
  Rewrite,
  Present,
]
Private = false</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../generated/graphics/layouts_vs_drawings/">« Layouts versus drawings of wiring diagrams</a><a class="docs-footer-nextpage" href="../theories/">Standard library of theories »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 9 June 2023 06:16">Friday 9 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
