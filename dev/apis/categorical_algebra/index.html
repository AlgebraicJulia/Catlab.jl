<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Categorical algebra · Catlab.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Catlab.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Wiring diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_schema_visualization/">Visualizing Acset Schemas with Graphviz</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../core/">Theories, instances, and expressions</a></li><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li class="is-active"><a class="tocitem" href>Categorical algebra</a><ul class="internal"><li><a class="tocitem" href="#FinSet-and-FinRel"><span>FinSet and FinRel</span></a></li><li><a class="tocitem" href="#Diagrams,-Limits,-and-Colimts"><span>Diagrams, Limits, and Colimts</span></a></li><li class="toplevel"><a class="tocitem" href="#Key-components-of-the-CSet-and-ACSet-machinery"><span>Key components of the CSet and ACSet machinery</span></a></li></ul></li><li><a class="tocitem" href="../graphs/">Graphs</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li><a class="tocitem" href="../programs/">Programs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Categorical algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Categorical algebra</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/master/docs/src/apis/categorical_algebra.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="categorical_algebra"><a class="docs-heading-anchor" href="#categorical_algebra">Categorical algebra</a><a id="categorical_algebra-1"></a><a class="docs-heading-anchor-permalink" href="#categorical_algebra" title="Permalink"></a></h1><h2 id="FinSet-and-FinRel"><a class="docs-heading-anchor" href="#FinSet-and-FinRel">FinSet and FinRel</a><a id="FinSet-and-FinRel-1"></a><a class="docs-heading-anchor-permalink" href="#FinSet-and-FinRel" title="Permalink"></a></h2><p>The following APIs implement FinSet, the category of Finite Sets (actually the skeleton of FinSet). The objects of this category are natural numbers where <code>n</code> represents a set with <code>n</code> elements. The morphisms are functions between such sets. We use the skeleton of FinSet in order to ensure that all sets are finite and morphisms can be stored using lists of integers. Finite relations are built out of FinSet and can be used to do some relational algebra.</p><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets" href="#Catlab.CategoricalAlgebra.FinSets"><code>Catlab.CategoricalAlgebra.FinSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The category of finite sets and functions, and its skeleton.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinDomFunction" href="#Catlab.CategoricalAlgebra.FinSets.FinDomFunction"><code>Catlab.CategoricalAlgebra.FinSets.FinDomFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function out of a finite set.</p><p>This class of functions is convenient because it is exactly the class that can be represented explicitly by a vector of values from the codomain.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinFunction" href="#Catlab.CategoricalAlgebra.FinSets.FinFunction"><code>Catlab.CategoricalAlgebra.FinSets.FinFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function between finite sets.</p><p>The function can be defined implicitly by an arbitrary Julia function, in which case it is evaluated lazily, or explictly by a vector of integers. In the vector representation, the function (1↦1, 2↦3, 3↦2, 4↦3), for example, is represented by the vector [1,3,2,3].</p><p>This type is mildly generalized by <a href="#Catlab.CategoricalAlgebra.FinSets.FinDomFunction"><code>FinDomFunction</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinSet" href="#Catlab.CategoricalAlgebra.FinSets.FinSet"><code>Catlab.CategoricalAlgebra.FinSets.FinSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Finite set.</p><p>This generic type encompasses the category <strong>FinSet</strong> of finite sets and functions, through types <code>FinSet{S} where S &lt;: AbstractSet</code>, as well as the skeleton of this category, through the type <code>FinSet{Int}</code>. In the latter case, the object <code>FinSet(n)</code> represents the set <span>${1,...,n}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.HashJoin" href="#Catlab.CategoricalAlgebra.FinSets.HashJoin"><code>Catlab.CategoricalAlgebra.FinSets.HashJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Hash_join">Hash join</a> algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm" href="#Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm"><code>Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for limit of spans or multispans out of finite sets.</p><p>In the context of relational databases, such limits are joins.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin" href="#Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin"><code>Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Nested_loop_join">Nested-loop join</a> algorithm.</p><p>This is the naive algorithm for computing joins.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SmartJoin" href="#Catlab.CategoricalAlgebra.FinSets.SmartJoin"><code>Catlab.CategoricalAlgebra.FinSets.SmartJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-algorithm for joins that attempts to pick an appropriate algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SortMergeJoin" href="#Catlab.CategoricalAlgebra.FinSets.SortMergeJoin"><code>Catlab.CategoricalAlgebra.FinSets.SortMergeJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Sort-merge_join">Sort-merge join</a> algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.force-Tuple{Catlab.CategoricalAlgebra.Sets.SetFunction{Dom, Codom} where {Dom&lt;:(Catlab.CategoricalAlgebra.FinSets.FinSet{Int64, T} where T), Codom}}" href="#Catlab.CategoricalAlgebra.FinSets.force-Tuple{Catlab.CategoricalAlgebra.Sets.SetFunction{Dom, Codom} where {Dom&lt;:(Catlab.CategoricalAlgebra.FinSets.FinSet{Int64, T} where T), Codom}}"><code>Catlab.CategoricalAlgebra.FinSets.force</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Force evaluation of lazy function or relation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.is_indexed-Tuple{Catlab.CategoricalAlgebra.Sets.SetFunction}" href="#Catlab.CategoricalAlgebra.FinSets.is_indexed-Tuple{Catlab.CategoricalAlgebra.Sets.SetFunction}"><code>Catlab.CategoricalAlgebra.FinSets.is_indexed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Whether the given function is indexed, i.e., supports efficient preimages.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.preimage-Tuple{Catlab.CategoricalAlgebra.Sets.SetFunctionIdentity, Any}" href="#Catlab.CategoricalAlgebra.FinSets.preimage-Tuple{Catlab.CategoricalAlgebra.Sets.SetFunctionIdentity, Any}"><code>Catlab.CategoricalAlgebra.FinSets.preimage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The preimage (inverse image) of the value y in the codomain.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations" href="#Catlab.CategoricalAlgebra.FinRelations"><code>Catlab.CategoricalAlgebra.FinRelations</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The category of finite sets and relations, and its skeleton.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.BoolRig" href="#Catlab.CategoricalAlgebra.FinRelations.BoolRig"><code>Catlab.CategoricalAlgebra.FinRelations.BoolRig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The rig of booleans.</p><p>This struct is needed because in base Julia, the product of booleans is another boolean, but the sum of booleans is coerced to an integer: <code>true + true == 2</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRel" href="#Catlab.CategoricalAlgebra.FinRelations.FinRel"><code>Catlab.CategoricalAlgebra.FinRelations.FinRel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object in the category of finite sets and relations.</p><p>See also: <a href="apis/@ref"><code>FinSet</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelation" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelation"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Binary relation between finite sets.</p><p>A morphism in the category of finite sets and relations. The relation can be represented implicitly by an arbitrary Julia function mapping pairs of elements to booleans or explicitly by a matrix (dense or sparse) taking values in the rig of booleans (<a href="#Catlab.CategoricalAlgebra.FinRelations.BoolRig"><code>BoolRig</code></a>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Relation in FinRel defined by a callable Julia object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Relation in FinRel represented by a boolean matrix.</p><p>Boolean matrices are also known as logical matrices or relation matrices.</p></div></section></article><h2 id="Diagrams,-Limits,-and-Colimts"><a class="docs-heading-anchor" href="#Diagrams,-Limits,-and-Colimts">Diagrams, Limits, and Colimts</a><a id="Diagrams,-Limits,-and-Colimts-1"></a><a class="docs-heading-anchor-permalink" href="#Diagrams,-Limits,-and-Colimts" title="Permalink"></a></h2><p>The following modules define diagrams in an arbitrary category and specify limit and colimt cones over said diagrams. Thes constructions enjoy the fullest support for FinSet and are used below to define presheaf categories as C-Sets. The general idea of these functions is that you set up a limit computation by specifying a diagram and asking for a limit or colimit cone, which is returned as a struct containing the apex object and the leg morphisms. This cone structure can be queried using the functions <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}"><code>apex</code></a> and <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>legs</code></a>. Julia&#39;s multiple dispatch feature is heavily used to specialize limit and colimit computations for various diagram shapes like product/coproduct and equalizer/coequalizer. As a consumer of this API, it is highly recommended that you use multiple dispatch to specialize your code on the diagram shape whenever possible.</p><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams" href="#Catlab.CategoricalAlgebra.FreeDiagrams"><code>Catlab.CategoricalAlgebra.FreeDiagrams</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Free diagrams in a category.</p><p>A <a href="https://ncatlab.org/nlab/show/free+diagram">free diagram</a> in a category is a diagram whose shape is a free category. Examples include the empty diagram, pairs of objects, discrete diagrams, parallel morphisms, spans, and cospans. Limits and colimits are most commonly taken over free diagrams.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A free diagram that is bipartite.</p><p>Such diagrams include most of the fixed shapes, such as spans, cospans, and parallel morphisms. They are the generic shape of diagrams for limits and colimits arising from undirected wiring diagrams. For limits, the boxes correspond to vertices in <span>$V₁$</span> and the junctions to vertics in <span>$V₂$</span>. Colimits are dual.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Cospan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Cospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Cospan of morphisms in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan"><code>Multicospan</code></a>. See also <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Span</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Discrete diagram: a diagram whose only morphisms are identities.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for free diagram of fixed shape.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multicospan of morphisms in a category.</p><p>A multicospan is like a <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Cospan</code></a> except that it may have a number of legs different than two. A limit of this shape is a pullback.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Multispan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multispan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Multispan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multispan of morphisms in a category.</p><p>A <a href="https://ncatlab.org/nlab/show/multispan">multispan</a> is like a <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Span</code></a> except that it may have a number of legs different than two. A colimit of this shape is a pushout.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parallel morphims in a category.</p><p><a href="https://ncatlab.org/nlab/show/parallel+morphisms">Parallel morphisms</a> are just morphisms with the same domain and codomain. A (co)limit of this shape is a (co)equalizer.</p><p>For the common special case of two morphisms, see <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair"><code>ParallelPair</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of parallel morphisms in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms"><code>ParallelMorphisms</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Span" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Span</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Span of morphims in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multispan"><code>Multispan</code></a>. See also <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Cospan</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.apex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apex(span::Multispan)</code></pre><p>returns the object at the top of the multispan, which is the domain of all the legs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs-Tuple{Multispan, Any}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs-Tuple{Multispan, Any}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bundle together legs of a multi(co)span.</p><p>For example, calling <code>bundle_legs(span, SVector((1,2),(3,4)))</code> on a multispan with four legs gives a span whose left leg bundles legs 1 and 2 and whose right leg bundles legs 3 and 4. Note that in addition to bundling, this function can also permute legs and discard them.</p><p>The bundling is performed using the universal property of (co)products, which assumes that these (co)limits exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.feet-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.feet-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.feet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">feet(span::Multispan)</code></pre><p>returns the collection of feet in the multspan, which are the codomains of the legs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.legs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">legs(span::Multispan)</code></pre><p>returns the collection of legs in the multspan, which are the morphisms sharing a common domain.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits" href="#Catlab.CategoricalAlgebra.Limits"><code>Catlab.CategoricalAlgebra.Limits</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Limits and colimits in a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.AbstractColimit" href="#Catlab.CategoricalAlgebra.Limits.AbstractColimit"><code>Catlab.CategoricalAlgebra.Limits.AbstractColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for colimit in a category.</p><p>The standard concrete subtype is <a href="#Catlab.CategoricalAlgebra.Limits.Colimit"><code>Colimit</code></a>, although for computational reasons certain categories may use different subtypes to include extra data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.AbstractLimit" href="#Catlab.CategoricalAlgebra.Limits.AbstractLimit"><code>Catlab.CategoricalAlgebra.Limits.AbstractLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for limit in a category.</p><p>The standard concrete subtype is <a href="#Catlab.CategoricalAlgebra.Limits.Limit"><code>Limit</code></a>, although for computational reasons certain categories may use different subtypes to include extra data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.Colimit" href="#Catlab.CategoricalAlgebra.Limits.Colimit"><code>Catlab.CategoricalAlgebra.Limits.Colimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Colimit in a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm" href="#Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm"><code>Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for computing colimits.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer" href="#Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer"><code>Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute pushout by composing a coproduct with a coequalizer.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer"><code>ComposeProductEqualizer</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer" href="#Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer"><code>Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute pullback by composing a product with an equalizer.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer"><code>ComposeCoproductCoequalizer</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.Limit" href="#Catlab.CategoricalAlgebra.Limits.Limit"><code>Catlab.CategoricalAlgebra.Limits.Limit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Limit in a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.LimitAlgorithm" href="#Catlab.CategoricalAlgebra.Limits.LimitAlgorithm"><code>Catlab.CategoricalAlgebra.Limits.LimitAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for computing limits.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.colimit" href="#Catlab.CategoricalAlgebra.Limits.colimit"><code>Catlab.CategoricalAlgebra.Limits.colimit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Colimit of a diagram.</p><p>To define colimits in a category with objects <code>Ob</code>, override the method <code>colimit(::FreeDiagram{Ob})</code> for general colimits or <code>colimit(::D)</code> with suitable type <code>D &lt;: FixedShapeFreeDiagram{Ob}</code> for colimits of specific shape, such as coproducts or coequalizers.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.limit"><code>limit</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.limit" href="#Catlab.CategoricalAlgebra.Limits.limit"><code>Catlab.CategoricalAlgebra.Limits.limit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Limit of a diagram.</p><p>To define limits in a category with objects <code>Ob</code>, override the method <code>limit(::FreeDiagram{Ob})</code> for general limits or <code>limit(::D)</code> with suitable type <code>D &lt;: FixedShapeFreeDiagram{Ob}</code> for limits of specific shape, such as products or equalizers.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.colimit"><code>colimit</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.pullback-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.pullback-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.pullback</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pullback of a pair of morphisms with common codomain.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::Cospan{T})</code> and/or <code>limit(::Multicospan{T})</code> or, if you have already implemented products and equalizers, rely on the default implementation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.pushout-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.pushout-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.pushout</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pushout of a pair of morphisms with common domain.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::Span{T})</code> and/or <code>colimit(::Multispan{T})</code> or, if you have already implemented coproducts and coequalizers, rely on the default implementation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.universal" href="#Catlab.CategoricalAlgebra.Limits.universal"><code>Catlab.CategoricalAlgebra.Limits.universal</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Universal property of (co)limits.</p><p>Compute the morphism whose existence and uniqueness is guaranteed by the universal property of (co)limits.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.limit"><code>limit</code></a>, <a href="#Catlab.CategoricalAlgebra.Limits.colimit"><code>colimit</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.coequalizer-Tuple{Any, Any}" href="#Catlab.Theories.coequalizer-Tuple{Any, Any}"><code>Catlab.Theories.coequalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coequalizer of morphisms with common domain and codomain.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::ParallelPair{T})</code> or <code>colimit(::ParallelMorphisms{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.copair-Tuple{Any, Any}" href="#Catlab.Theories.copair-Tuple{Any, Any}"><code>Catlab.Theories.copair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Copairing of morphisms: universal property of coproducts/pushouts.</p><p>To implement for coproducts of type <code>T</code>, define the method <code>universal(::BinaryCoproduct{T}, ::Cospan{T})</code> and/or <code>universal(::Coproduct{T}, ::Multicospan{T})</code> and similarly for pushouts.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.coproduct-Tuple{Any, Any}" href="#Catlab.Theories.coproduct-Tuple{Any, Any}"><code>Catlab.Theories.coproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coproduct of objects.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::ObjectPair{T})</code> and/or <code>colimit(::DiscreteDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.create-Tuple{T} where T" href="#Catlab.Theories.create-Tuple{T} where T"><code>Catlab.Theories.create</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unique morphism out of an initial object.</p><p>To implement for a type <code>T</code>, define the method <code>universal(::Initial{T}, ::SMulticospan{0,T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.delete-Tuple{T} where T" href="#Catlab.Theories.delete-Tuple{T} where T"><code>Catlab.Theories.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unique morphism into a terminal object.</p><p>To implement for a type <code>T</code>, define the method <code>universal(::Terminal{T}, ::SMultispan{0,T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.equalizer-Tuple{Any, Any}" href="#Catlab.Theories.equalizer-Tuple{Any, Any}"><code>Catlab.Theories.equalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Equalizer of morphisms with common domain and codomain.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::ParallelPair{T})</code> and/or <code>limit(::ParallelMorphisms{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.factorize-Tuple{Equalizer{Ob, var&quot;#s127&quot;} where {Ob, var&quot;#s127&quot;&lt;:ParallelMorphisms}, Any}" href="#Catlab.Theories.factorize-Tuple{Equalizer{Ob, var&quot;#s127&quot;} where {Ob, var&quot;#s127&quot;&lt;:ParallelMorphisms}, Any}"><code>Catlab.Theories.factorize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Factor morphism through (co)equalizer, via the universal property.</p><p>To implement for equalizers of type <code>T</code>, define the method <code>universal(::Equalizer{T}, ::SMultispan{1,T})</code>. For coequalizers of type <code>T</code>, define the method <code>universal(::Coequalizer{T}, ::SMulticospan{1,T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.initial-Tuple{Type}" href="#Catlab.Theories.initial-Tuple{Type}"><code>Catlab.Theories.initial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initial object.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::EmptyDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.pair-Tuple{Any, Any}" href="#Catlab.Theories.pair-Tuple{Any, Any}"><code>Catlab.Theories.pair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pairing of morphisms: universal property of products/pullbacks.</p><p>To implement for products of type <code>T</code>, define the method <code>universal(::BinaryProduct{T}, ::Span{T})</code> and/or <code>universal(::Product{T}, ::Multispan{T})</code> and similarly for pullbacks.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.product-Tuple{Any, Any}" href="#Catlab.Theories.product-Tuple{Any, Any}"><code>Catlab.Theories.product</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Product of objects.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::ObjectPair{T})</code> and/or <code>limit(::DiscreteDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.terminal-Tuple{Type}" href="#Catlab.Theories.terminal-Tuple{Type}"><code>Catlab.Theories.terminal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Terminal object.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::EmptyDiagram{T})</code>.</p></div></section></article><h1 id="Key-components-of-the-CSet-and-ACSet-machinery"><a class="docs-heading-anchor" href="#Key-components-of-the-CSet-and-ACSet-machinery">Key components of the CSet and ACSet machinery</a><a id="Key-components-of-the-CSet-and-ACSet-machinery-1"></a><a class="docs-heading-anchor-permalink" href="#Key-components-of-the-CSet-and-ACSet-machinery" title="Permalink"></a></h1><p><code>FreeSchema</code> A finite presentation of a category that will be used as the schema of a database in the <em>algebraic databases</em> conception of categorical database theory. Functors out of a schema into FinSet are combinatorial structures over the schema. Attributes in a schema allow you to encode numerical (any julia type) into the database. You can find several examples of schemas in <code>Catlab.Graphs</code> where they define categorical versions of graph theory.</p><p><code>CSet/AttributedCSet</code> is a struct/constructors whose values (tables, indices) are parameterized by a CatDesc/AttrDesc. These are in memory databases over the schema equiped with <code>ACSetTranformations</code> as natural transformations that encode relationships between database instances.</p><p><code>CSetType/AttributedCSetType</code>provides a function to construct a julia type for ACSet instances, parameterized by CatDesc/AttrDesc. This function constructs the new type at runtime. In order to have the interactive nature of Julia, and to dynamically construct schemas based on runtime values, we need to define new Julia types at runtime. This function converts the schema spec to the corresponding Julia type.</p><p><code>CatDesc/AttrDesc</code> the encoding of a schema into a Julia type. These exist because Julia only allows certain kinds of data in the parameter of a dependent type. Thus, we have to serialize a schema into those primitive data types so that we can use them to parameterize the ACSet type over the schema. This is an implementation detail subject to complete overhaul.</p><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets" href="#Catlab.CategoricalAlgebra.CSets"><code>Catlab.CategoricalAlgebra.CSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Categories of C-sets and attributed C-sets.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.ACSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.ACSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Transformation between attributed C-sets.</p><p>A homomorphism of C-sets is a natural transformation: a transformation between functors C → Set satisfying the naturality axiom for all morphisms in C. This struct records the data of a transformation; it does not enforce naturality, but see <a href="#Catlab.CategoricalAlgebra.CSets.is_natural-Union{Tuple{ACSetTransformation{CD, AD, Comp, Dom, Codom} where {Comp&lt;:NamedTuple, Dom&lt;:(Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple), Codom&lt;:(Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple)}}, Tuple{AD}, Tuple{CD}} where {CD, AD}"><code>is_natural</code></a>.</p><p>A C-set transformation has a component for every object in C. When C-sets have attributes, the data types are assumed to be fixed. Thus, the naturality axiom for data attributes is a commutative triangle, rather than a commutative square.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.generate_json_acset-Tuple{T} where T&lt;:Catlab.CSetDataStructures.AbstractAttributedCSet" href="#Catlab.CategoricalAlgebra.CSets.generate_json_acset-Tuple{T} where T&lt;:Catlab.CSetDataStructures.AbstractAttributedCSet"><code>Catlab.CategoricalAlgebra.CSets.generate_json_acset</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Serialize an ACSet object to a JSON string</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}" href="#Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}"><code>Catlab.CategoricalAlgebra.CSets.homomorphism</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find a homomorphism between two attributed <span>$C$</span>-sets.</p><p>Returns <code>nothing</code> if no homomorphism exists. For many categories <span>$C$</span>, the <span>$C$</span>-set homomorphism problem is NP-complete and thus this procedure generally runs in exponential time. It works best when the domain object is small.</p><p>This procedure uses the classic backtracking search algorithm for a combinatorial constraint satisfaction problem (CSP). As is well known, the homomorphism problem for relational databases is equivalent to CSP. Since the C-set homomorphism problem is &quot;the same&quot; as the database homomorphism problem (insofar as attributed C-sets are &quot;the same&quot; as relational databases), it is also equivalent to CSP. Backtracking search for CSP is described in many computer science textbooks, such as (Russell &amp; Norvig 2010, <em>Artificial Intelligence</em>, Third Ed., Chapter 6: Constraint satisfaction problems, esp. Algorithm 6.5). In our implementation, the search tree is ordered using the popular heuristic of &quot;minimum remaining values&quot; (MRV), also known as &quot;most constrained variable.&quot;</p><p>Set the keyword argument <code>monic=true</code> to restrict to monomorphisms: homomorphisms whose components are all injective functions.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.CSets.homomorphisms-Union{Tuple{AD}, Tuple{CD}, Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple, Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple}} where {CD, AD}"><code>homomorphisms</code></a>, <a href="#Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}"><code>isomorphism</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.homomorphisms-Union{Tuple{AD}, Tuple{CD}, Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple, Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple}} where {CD, AD}" href="#Catlab.CategoricalAlgebra.CSets.homomorphisms-Union{Tuple{AD}, Tuple{CD}, Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple, Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple}} where {CD, AD}"><code>Catlab.CategoricalAlgebra.CSets.homomorphisms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find all homomorphisms between two attributed <span>$C$</span>-sets.</p><p>This function is at least as expensive as <a href="#Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}"><code>homomorphism</code></a> and when no homomorphisms exist, it is exactly as expensive.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.is_homomorphic-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}" href="#Catlab.CategoricalAlgebra.CSets.is_homomorphic-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}"><code>Catlab.CategoricalAlgebra.CSets.is_homomorphic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the first attributed <span>$C$</span>-set homomorphic to the second?</p><p>A convenience function based on <a href="#Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}"><code>homomorphism</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.is_isomorphic-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}" href="#Catlab.CategoricalAlgebra.CSets.is_isomorphic-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}"><code>Catlab.CategoricalAlgebra.CSets.is_isomorphic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Are the two attributed <span>$C$</span>-sets isomorphic?</p><p>A convenience function based on <a href="#Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}"><code>isomorphism</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.is_natural-Union{Tuple{ACSetTransformation{CD, AD, Comp, Dom, Codom} where {Comp&lt;:NamedTuple, Dom&lt;:(Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple), Codom&lt;:(Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple)}}, Tuple{AD}, Tuple{CD}} where {CD, AD}" href="#Catlab.CategoricalAlgebra.CSets.is_natural-Union{Tuple{ACSetTransformation{CD, AD, Comp, Dom, Codom} where {Comp&lt;:NamedTuple, Dom&lt;:(Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple), Codom&lt;:(Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple)}}, Tuple{AD}, Tuple{CD}} where {CD, AD}"><code>Catlab.CategoricalAlgebra.CSets.is_natural</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the transformation between C-sets a natural transformation?</p><p>Uses the fact that to check whether a transformation is natural, it suffices to check the naturality equation on a generating set of morphisms.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}" href="#Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}"><code>Catlab.CategoricalAlgebra.CSets.isomorphism</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find an isomorphism between two attributed <span>$C$</span>-sets, if one exists.</p><p>See <a href="#Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}"><code>homomorphism</code></a> for more information about the algorithms involved.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.isomorphisms-Union{Tuple{AD}, Tuple{CD}, Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple, Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple}} where {CD, AD}" href="#Catlab.CategoricalAlgebra.CSets.isomorphisms-Union{Tuple{AD}, Tuple{CD}, Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple, Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple}} where {CD, AD}"><code>Catlab.CategoricalAlgebra.CSets.isomorphisms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find all isomorphisms between two attributed <span>$C$</span>-sets.</p><p>This function is at least as expensive as <a href="#Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{Catlab.CSetDataStructures.AbstractAttributedCSet, Catlab.CSetDataStructures.AbstractAttributedCSet}"><code>isomorphism</code></a> and when no homomorphisms exist, it is exactly as expensive.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.parse_json_acset-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T&lt;:Catlab.CSetDataStructures.AbstractAttributedCSet" href="#Catlab.CategoricalAlgebra.CSets.parse_json_acset-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T&lt;:Catlab.CSetDataStructures.AbstractAttributedCSet"><code>Catlab.CategoricalAlgebra.CSets.parse_json_acset</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Deserialize a dictionary from a parsed JSON string to an object of the given ACSet type</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.parse_json_acset-Union{Tuple{T}, Tuple{Type{T}, String}} where T&lt;:Catlab.CSetDataStructures.AbstractAttributedCSet" href="#Catlab.CategoricalAlgebra.CSets.parse_json_acset-Union{Tuple{T}, Tuple{Type{T}, String}} where T&lt;:Catlab.CSetDataStructures.AbstractAttributedCSet"><code>Catlab.CategoricalAlgebra.CSets.parse_json_acset</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Deserialize a JSON string to an object of the given ACSet type</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.read_json_acset-Union{Tuple{T}, Tuple{Type{T}, String}} where T&lt;:Catlab.CSetDataStructures.AbstractAttributedCSet" href="#Catlab.CategoricalAlgebra.CSets.read_json_acset-Union{Tuple{T}, Tuple{Type{T}, String}} where T&lt;:Catlab.CSetDataStructures.AbstractAttributedCSet"><code>Catlab.CategoricalAlgebra.CSets.read_json_acset</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read a JSON file to an object of the given ACSet type</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.write_json_acset-Union{Tuple{T}, Tuple{T, AbstractString}} where T&lt;:Catlab.CSetDataStructures.AbstractAttributedCSet" href="#Catlab.CategoricalAlgebra.CSets.write_json_acset-Union{Tuple{T}, Tuple{T, AbstractString}} where T&lt;:Catlab.CSetDataStructures.AbstractAttributedCSet"><code>Catlab.CategoricalAlgebra.CSets.write_json_acset</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Serialize an ACSet object to a JSON file</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans" href="#Catlab.CategoricalAlgebra.StructuredCospans"><code>Catlab.CategoricalAlgebra.StructuredCospans</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Structured cospans.</p><p>This module provides a generic interface for structured cospans with a concrete implementation for attributed C-sets.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structured cospan.</p><p>The first type parameter <code>L</code> encodes a functor L: A → X from the base category <code>A</code>, often FinSet, to a category <code>X</code> with &quot;extra structure.&quot; An L-structured cospan is then a cospan in X whose feet are images under L of objects in A. The category X is assumed to have pushouts.</p><p>Structured cospans form a double category with no further assumptions on the functor L. To obtain a symmetric monoidal double category, L must preserve finite coproducts. In practice, L usually has a right adjoint R: X → A, which implies that L preserves all finite colimits. It also allows structured cospans to be constructed more conveniently from an object x in X plus a cospan in A with apex R(x).</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan"><code>StructuredMulticospan</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Any, Multicospan{Ob, Hom, var&quot;#s127&quot;} where {Ob, Hom, var&quot;#s127&quot;&lt;:StaticArrays.StaticVector{2, Hom}}}} where L" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Any, Multicospan{Ob, Hom, var&quot;#s127&quot;} where {Ob, Hom, var&quot;#s127&quot;&lt;:StaticArrays.StaticVector{2, Hom}}}} where L"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct structured cospan in R-form.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Multicospan{Ob, Hom, var&quot;#s127&quot;} where {Ob, Hom, var&quot;#s127&quot;&lt;:StaticArrays.StaticVector{2, Hom}}, StaticArrays.StaticVector{2, T} where T}} where L" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Multicospan{Ob, Hom, var&quot;#s127&quot;} where {Ob, Hom, var&quot;#s127&quot;&lt;:StaticArrays.StaticVector{2, Hom}}, StaticArrays.StaticVector{2, T} where T}} where L"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct structured cospan in L-form.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object in the category of L-structured cospans.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structured multicospan.</p><p>A structured multicospan is like a structured cospan except that it may have a number of legs different than two.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan"><code>StructuredCospan</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan-Union{Tuple{L}, Tuple{Any, Multicospan}} where L" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan-Union{Tuple{L}, Tuple{Any, Multicospan}} where L"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct structured multicospan in R-form.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{AD}, Tuple{CD}, Tuple{Type{X}, Symbol}} where {CD&lt;:Catlab.Theories.CatDesc, AD&lt;:(Catlab.Theories.AttrDesc{CD, Data, Attr, ADom, ACodom} where {Data, Attr, ADom, ACodom}), X&lt;:(Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple)}" href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{AD}, Tuple{CD}, Tuple{Type{X}, Symbol}} where {CD&lt;:Catlab.Theories.CatDesc, AD&lt;:(Catlab.Theories.AttrDesc{CD, Data, Attr, ADom, ACodom} where {Data, Attr, ADom, ACodom}), X&lt;:(Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple)}"><code>Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create types for open attributed C-sets from an attributed C-set type.</p><p>The resulting types, for objects and morphisms, each have the same type parameters for data types as the original type.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{CD}, Tuple{Type{X}, Symbol}} where {CD&lt;:Catlab.Theories.CatDesc, X&lt;:AbstractCSet{CD}}"><code>OpenCSetTypes</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{CD}, Tuple{Type{X}, Symbol}} where {CD&lt;:Catlab.Theories.CatDesc, X&lt;:AbstractCSet{CD}}" href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{CD}, Tuple{Type{X}, Symbol}} where {CD&lt;:Catlab.Theories.CatDesc, X&lt;:AbstractCSet{CD}}"><code>Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create types for open C-sets from a C-set type.</p><p>Returns two types, for objects, a subtype of <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb"><code>StructuredCospanOb</code></a>, and for morphisms, a subtype of <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan"><code>StructuredMulticospan</code></a>.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{AD}, Tuple{CD}, Tuple{Type{X}, Symbol}} where {CD&lt;:Catlab.Theories.CatDesc, AD&lt;:(Catlab.Theories.AttrDesc{CD, Data, Attr, ADom, ACodom} where {Data, Attr, ADom, ACodom}), X&lt;:(Catlab.CSetDataStructures.AbstractAttributedCSet{CD, AD, Ts} where Ts&lt;:Tuple)}"><code>OpenACSetTypes</code></a>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theories/">« Standard library of theories</a><a class="docs-footer-nextpage" href="../graphs/">Graphs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 21 June 2021 22:26">Monday 21 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
