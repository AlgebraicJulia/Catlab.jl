<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Categorical algebra · Catlab.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catlab.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Seven Sketches in Compositionality</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/sketches/partitions/">Partitions</a></li><li><a class="tocitem" href="../../generated/sketches/preorders/">Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/meets/">Meets in Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/smc/">Symmetric Monoidal Categories</a></li><li><a class="tocitem" href="../../generated/sketches/cat_elements/">The Category of Elements</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphs/graphs/">The Category of Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/graphs_label/">Labeled Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/subgraphs/">Algebra of subgraphs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Categorical Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/categorical_algebra/diagrams/">Diagrams</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Wiring Diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/wd_cset/">Wiring Diagrams as Attributed C-Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/graphviz_graphs/">Drawing graphs in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../core/">Theories, instances, and expressions</a></li><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li class="is-active"><a class="tocitem" href>Categorical algebra</a><ul class="internal"><li><a class="tocitem" href="#Sets-and-Relations"><span>Sets and Relations</span></a></li><li><a class="tocitem" href="#Free-Diagrams,-Limits,-and-Colimts"><span>Free Diagrams, Limits, and Colimts</span></a></li><li><a class="tocitem" href="#Categories"><span>Categories</span></a></li><li><a class="tocitem" href="#Acsets"><span>Acsets</span></a></li></ul></li><li><a class="tocitem" href="../graphs/">Graphs</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li><a class="tocitem" href="../programs/">Programs</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../devdocs/style/">Style Guide for AlgebraicJulia</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Categorical algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Categorical algebra</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/master/docs/src/apis/categorical_algebra.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="categorical_algebra"><a class="docs-heading-anchor" href="#categorical_algebra">Categorical algebra</a><a id="categorical_algebra-1"></a><a class="docs-heading-anchor-permalink" href="#categorical_algebra" title="Permalink"></a></h1><h2 id="Sets-and-Relations"><a class="docs-heading-anchor" href="#Sets-and-Relations">Sets and Relations</a><a id="Sets-and-Relations-1"></a><a class="docs-heading-anchor-permalink" href="#Sets-and-Relations" title="Permalink"></a></h2><p>The following APIs implement FinSet, the category of Finite Sets (actually the skeleton of FinSet). The objects of this category are natural numbers where <code>n</code> represents a set with <code>n</code> elements. The morphisms are functions between such sets. We use the skeleton of FinSet in order to ensure that all sets are finite and morphisms can be stored using lists of integers. Finite relations are built out of FinSet and can be used to do some relational algebra.</p><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets" href="#Catlab.CategoricalAlgebra.Sets"><code>Catlab.CategoricalAlgebra.Sets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Category of (possibly infinite) sets and functions.</p><p>This module defines generic types for the category of sets (<a href="#Catlab.CategoricalAlgebra.Sets.SetOb"><code>SetOb</code></a>, <a href="#Catlab.CategoricalAlgebra.Sets.SetFunction"><code>SetFunction</code></a>), as well as a few basic concrete types, such as a wrapper type to view Julia types as sets (<a href="#Catlab.CategoricalAlgebra.Sets.TypeSet"><code>TypeSet</code></a>). Extensive support for finite sets is provided by another module, <a href="apis/@ref"><code>FinSets</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Sets.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.ConstantFunction" href="#Catlab.CategoricalAlgebra.Sets.ConstantFunction"><code>Catlab.CategoricalAlgebra.Sets.ConstantFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function in <strong>Set</strong> taking a constant value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Sets.jl#L131-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.PredicatedSet" href="#Catlab.CategoricalAlgebra.Sets.PredicatedSet"><code>Catlab.CategoricalAlgebra.Sets.PredicatedSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Set defined by a predicate (boolean-valued function) on a Julia data type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Sets.jl#L148-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.SetFunction" href="#Catlab.CategoricalAlgebra.Sets.SetFunction"><code>Catlab.CategoricalAlgebra.Sets.SetFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for morphism in the category <strong>Set</strong>.</p><p>Every instance of <code>SetFunction{&lt;:SetOb{T},&lt;:SetOb{T′}}</code> is callable with elements of type <code>T</code>, returning an element of type <code>T′</code>.</p><p>Note: This type would be better called simply <code>Function</code> but that name is already taken by the base Julia type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Sets.jl#L43-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.SetOb" href="#Catlab.CategoricalAlgebra.Sets.SetOb"><code>Catlab.CategoricalAlgebra.Sets.SetOb</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for object in the category <strong>Set</strong>.</p><p>The type parameter <code>T</code> is the element type of the set.</p><p>Note: This type is more abstract than the built-in Julia types <code>AbstractSet</code> and <code>Set</code>, which are intended for data structures for finite sets. Those are encompassed by the subtype <a href="apis/@ref"><code>FinSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Sets.jl#L22-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.TypeSet" href="#Catlab.CategoricalAlgebra.Sets.TypeSet"><code>Catlab.CategoricalAlgebra.Sets.TypeSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Julia data type regarded as a set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Sets.jl#L34-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.Ob-Union{Tuple{TypeCat{T}}, Tuple{T}} where T" href="#Catlab.Theories.Ob-Union{Tuple{TypeCat{T}}, Tuple{T}} where T"><code>Catlab.Theories.Ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Forgetful functor Ob: Cat → Set.</p><p>Sends a category to its set of objects and a functor to its object map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Sets.jl#L209-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets" href="#Catlab.CategoricalAlgebra.FinSets"><code>Catlab.CategoricalAlgebra.FinSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The category of finite sets and functions, and its skeleton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinDomFunction" href="#Catlab.CategoricalAlgebra.FinSets.FinDomFunction"><code>Catlab.CategoricalAlgebra.FinSets.FinDomFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function out of a finite set.</p><p>This class of functions is convenient because it is exactly the class that can be represented explicitly by a vector of values from the codomain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L212-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinFunction" href="#Catlab.CategoricalAlgebra.FinSets.FinFunction"><code>Catlab.CategoricalAlgebra.FinSets.FinFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function between finite sets.</p><p>The function can be defined implicitly by an arbitrary Julia function, in which case it is evaluated lazily, or explictly by a vector of integers. In the vector representation, the function (1↦1, 2↦3, 3↦2, 4↦3), for example, is represented by the vector [1,3,2,3].</p><p>FinFunctions can be constructed with or without an explicitly provided codomain. If a codomain is provided, by default the constructor checks it is valid.</p><p>This type is mildly generalized by <a href="#Catlab.CategoricalAlgebra.FinSets.FinDomFunction"><code>FinDomFunction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L168-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinSet" href="#Catlab.CategoricalAlgebra.FinSets.FinSet"><code>Catlab.CategoricalAlgebra.FinSets.FinSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Finite set.</p><p>A finite set has abstract type <code>FinSet{S,T}</code>. The second type parameter <code>T</code> is the element type of the set and the first parameter <code>S</code> is the collection type, which can be a subtype of <code>AbstractSet</code> or another Julia collection type. In addition, the skeleton of the category <strong>FinSet</strong> is the important special case <code>S = Int</code>. The set <span>${1,…,n}$</span> is represented by the object <code>FinSet(n)</code> of type <code>FinSet{Int,Int}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.HashJoin" href="#Catlab.CategoricalAlgebra.FinSets.HashJoin"><code>Catlab.CategoricalAlgebra.FinSets.HashJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Hash_join">Hash join</a> algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L785-L787">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm" href="#Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm"><code>Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for limit of cospan or multicospan with feet being finite sets.</p><p>In the context of relational databases, such limits are called <em>joins</em>. The trivial join algorithm is <a href="#Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin"><code>NestedLoopJoin</code></a>, which is algorithmically equivalent to the generic algorithm <code>ComposeProductEqualizer</code>. The algorithms <a href="#Catlab.CategoricalAlgebra.FinSets.HashJoin"><code>HashJoin</code></a> and <a href="#Catlab.CategoricalAlgebra.FinSets.SortMergeJoin"><code>SortMergeJoin</code></a> are usually much faster. If you are unsure what algorithm to pick, use <a href="#Catlab.CategoricalAlgebra.FinSets.SmartJoin"><code>SmartJoin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L654-L662">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin" href="#Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin"><code>Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Nested_loop_join">Nested-loop join</a> algorithm.</p><p>This is the naive algorithm for computing joins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L707-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SmartJoin" href="#Catlab.CategoricalAlgebra.FinSets.SmartJoin"><code>Catlab.CategoricalAlgebra.FinSets.SmartJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-algorithm for joins that attempts to pick an appropriate algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L664-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SortMergeJoin" href="#Catlab.CategoricalAlgebra.FinSets.SortMergeJoin"><code>Catlab.CategoricalAlgebra.FinSets.SortMergeJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Sort-merge_join">Sort-merge join</a> algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L732-L734">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SubFinSet" href="#Catlab.CategoricalAlgebra.FinSets.SubFinSet"><code>Catlab.CategoricalAlgebra.FinSets.SubFinSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Subset of a finite set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L1403-L1405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SubOpBoolean" href="#Catlab.CategoricalAlgebra.FinSets.SubOpBoolean"><code>Catlab.CategoricalAlgebra.FinSets.SubOpBoolean</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm to compute subobject operations using elementwise boolean logic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L1456-L1458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.TabularLimit" href="#Catlab.CategoricalAlgebra.FinSets.TabularLimit"><code>Catlab.CategoricalAlgebra.FinSets.TabularLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Limit of finite sets viewed as a table.</p><p>Any limit of finite sets can be canonically viewed as a table (<a href="#Catlab.CategoricalAlgebra.FinSets.TabularSet"><code>TabularSet</code></a>) whose columns are the legs of the limit cone and whose rows correspond to elements of the limit object. To construct this table from an already computed limit, call <code>TabularLimit(::AbstractLimit; ...)</code>. The column names of the table are given by the optional argument <code>names</code>.</p><p>In this tabular form, applying the universal property of the limit is trivial since it is just tupling. Thus, this representation can be useful when the original limit algorithm does not support efficient application of the universal property. On the other hand, this representation has the disadvantage of generally making the element type of the limit set more complicated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L1042-L1056">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.TabularSet" href="#Catlab.CategoricalAlgebra.FinSets.TabularSet"><code>Catlab.CategoricalAlgebra.FinSets.TabularSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Finite set whose elements are rows of a table.</p><p>The underlying table should be compliant with Tables.jl. For the sake of uniformity, the rows are provided as named tuples, which assumes that the table is not &quot;extremely wide&quot;. This should not be a major limitation in practice but see the Tables.jl documentation for further discussion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L85-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.VarFunction" href="#Catlab.CategoricalAlgebra.FinSets.VarFunction"><code>Catlab.CategoricalAlgebra.FinSets.VarFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Data type of a map out of a set of attribute variables</p><p>Currently, domains are FinSet{Int} and codomains are expected to be FinSet{Int}. This could be generalized to being FinSet{Symbol} to allow for symbolic attributes. (Likewise, AttrVars will have to wrap Any rather than Int)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L313-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.is_indexed-Tuple{SetFunction}" href="#Catlab.CategoricalAlgebra.FinSets.is_indexed-Tuple{SetFunction}"><code>Catlab.CategoricalAlgebra.FinSets.is_indexed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Whether the given function is indexed, i.e., supports efficient preimages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L440-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.preimage-Tuple{Catlab.CategoricalAlgebra.Sets.IdentityFunction, Any}" href="#Catlab.CategoricalAlgebra.FinSets.preimage-Tuple{Catlab.CategoricalAlgebra.Sets.IdentityFunction, Any}"><code>Catlab.CategoricalAlgebra.FinSets.preimage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The preimage (inverse image) of the value y in the codomain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinSets.jl#L447-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations" href="#Catlab.CategoricalAlgebra.FinRelations"><code>Catlab.CategoricalAlgebra.FinRelations</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The category of finite sets and relations, and its skeleton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinRelations.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.BoolRig" href="#Catlab.CategoricalAlgebra.FinRelations.BoolRig"><code>Catlab.CategoricalAlgebra.FinRelations.BoolRig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The rig of booleans.</p><p>This struct is needed because in base Julia, the product of booleans is another boolean, but the sum of booleans is coerced to an integer: <code>true + true == 2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinRelations.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRel" href="#Catlab.CategoricalAlgebra.FinRelations.FinRel"><code>Catlab.CategoricalAlgebra.FinRelations.FinRel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object in the category of finite sets and relations.</p><p>See also: <a href="apis/@ref"><code>FinSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinRelations.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelation" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelation"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Binary relation between finite sets.</p><p>A morphism in the category of finite sets and relations. The relation can be represented implicitly by an arbitrary Julia function mapping pairs of elements to booleans or explicitly by a matrix (dense or sparse) taking values in the rig of booleans (<a href="#Catlab.CategoricalAlgebra.FinRelations.BoolRig"><code>BoolRig</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinRelations.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Relation in FinRel defined by a callable Julia object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinRelations.jl#L73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Relation in FinRel represented by a boolean matrix.</p><p>Boolean matrices are also known as logical matrices or relation matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinRelations.jl#L90-L94">source</a></section></article><h2 id="Free-Diagrams,-Limits,-and-Colimts"><a class="docs-heading-anchor" href="#Free-Diagrams,-Limits,-and-Colimts">Free Diagrams, Limits, and Colimts</a><a id="Free-Diagrams,-Limits,-and-Colimts-1"></a><a class="docs-heading-anchor-permalink" href="#Free-Diagrams,-Limits,-and-Colimts" title="Permalink"></a></h2><p>The following modules define free diagrams in an arbitrary category and specify limit and colimt cones over said diagrams. Thes constructions enjoy the fullest support for FinSet and are used below to define presheaf categories as C-Sets. The general idea of these functions is that you set up a limit computation by specifying a diagram and asking for a limit or colimit cone, which is returned as a struct containing the apex object and the leg morphisms. This cone structure can be queried using the functions <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}"><code>apex</code></a> and <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>legs</code></a>. Julia&#39;s multiple dispatch feature is heavily used to specialize limit and colimit computations for various diagram shapes like product/coproduct and equalizer/coequalizer. As a consumer of this API, it is highly recommended that you use multiple dispatch to specialize your code on the diagram shape whenever possible.</p><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams" href="#Catlab.CategoricalAlgebra.FreeDiagrams"><code>Catlab.CategoricalAlgebra.FreeDiagrams</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Free diagrams in a category.</p><p>A <a href="https://ncatlab.org/nlab/show/free+diagram">free diagram</a> in a category is a diagram whose shape is a free category. Examples include the empty diagram, pairs of objects, discrete diagrams, parallel pairs, composable pairs, and spans and cospans. Limits and colimits are most commonly taken over free diagrams.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A free diagram with a bipartite structure.</p><p>Such diagrams include most of the fixed shapes, such as spans, cospans, and parallel morphisms. They are also the generic shape of diagrams for limits and colimits arising from undirected wiring diagrams. For limits, the boxes correspond to vertices in <span>$V₁$</span> and the junctions to vertices in <span>$V₂$</span>. Colimits are dual.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L329-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram-Union{Tuple{Functor{&lt;:Category{Int64, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where Hom}}, Tuple{Hom}, Tuple{Ob}} where {Ob, Hom}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram-Union{Tuple{Functor{&lt;:Category{Int64, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where Hom}}, Tuple{Hom}, Tuple{Ob}} where {Ob, Hom}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert a free diagram to a bipartite free diagram.</p><p>Reduce a free diagram to a free bipartite diagram with the same limit (the default, <code>colimit=false</code>) or the same colimit (<code>colimit=true</code>). The reduction is essentially the same in both cases, except for the choice of where to put isolated vertices, where we follow the conventions described at <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}"><code>cone_objects</code></a> and <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}"><code>cocone_objects</code></a>. The resulting object is a bipartite free diagram equipped with maps from the vertices of the bipartite diagram to the vertices of the original diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L429-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Composable morphisms in a category.</p><p>Composable morphisms are a sequence of morphisms in a category that form a path in the underlying graph of the category.</p><p>For the common special case of two morphisms, see <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair"><code>ComposablePair</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L282-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of composable morphisms in a category.</p><p><a href="https://ncatlab.org/nlab/show/composable+pair">Composable pairs</a> are a common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms"><code>ComposableMorphisms</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L301-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Cospan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Cospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Cospan of morphisms in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan"><code>Multicospan</code></a>. See also <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Span</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Discrete diagram: a diagram with no non-identity morphisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L68-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for free diagram of fixed shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L59-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multicospan of morphisms in a category.</p><p>A multicospan is like a <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Cospan</code></a> except that it may have a number of legs different than two. A limit of this shape is a pullback.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L163-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Multispan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multispan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Multispan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multispan of morphisms in a category.</p><p>A <a href="https://ncatlab.org/nlab/show/multispan">multispan</a> is like a <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Span</code></a> except that it may have a number of legs different than two. A colimit of this shape is a pushout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parallel morphims in a category.</p><p><a href="https://ncatlab.org/nlab/show/parallel+morphisms">Parallel morphisms</a> are just morphisms with the same domain and codomain. A (co)limit of this shape is a (co)equalizer.</p><p>For the common special case of two morphisms, see <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair"><code>ParallelPair</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L228-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of parallel morphisms in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms"><code>ParallelMorphisms</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L248-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Span" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Span</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Span of morphims in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multispan"><code>Multispan</code></a>. See also <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Cospan</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.apex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apex of multispan or multicospan.</p><p>The apex of a multi(co)span is the object that is the (co)domain of all the <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>legs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs-Tuple{Multispan, Any}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs-Tuple{Multispan, Any}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bundle together legs of a multi(co)span.</p><p>For example, calling <code>bundle_legs(span, SVector((1,2),(3,4)))</code> on a multispan with four legs gives a span whose left leg bundles legs 1 and 2 and whose right leg bundles legs 3 and 4. Note that in addition to bundling, this function can also permute legs and discard them.</p><p>The bundling is performed using the universal property of (co)products, which assumes that these (co)limits exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L205-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Objects in diagram that will have explicit legs in colimit cocone.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}"><code>cone_objects</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Objects in diagram that will have explicit legs in limit cone.</p><p>In category theory, it is common practice to elide legs of limit cones that can be computed from other legs, especially for diagrams of certain fixed shapes. For example, when it taking a pullback (the limit of a cospan), the limit object is often treated as having two projections, rather than three. This function encodes such conventions by listing the objects in the diagram that will have corresponding legs in the limit object created by Catlab.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}"><code>cocone_objects</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L37-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type" href="#Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type"><code>Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given a diagram in a category <span>$C$</span>, return Julia type of objects and morphisms in <span>$C$</span> as a tuple type of form <span>$Tuple{Ob,Hom}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L32-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.feet-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.feet-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.feet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Feet of multispan or multicospan.</p><p>The feet of a multispan are the codomains of the <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>legs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.left-Tuple{Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.left-Tuple{Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.left</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Left leg of span or cospan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L149-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.legs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Legs of multispan or multicospan.</p><p>The legs are the morphisms comprising the multi(co)span.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.right-Tuple{Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.right-Tuple{Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.right</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Right leg of span or cospan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FreeDiagrams.jl#L153-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits" href="#Catlab.CategoricalAlgebra.Limits"><code>Catlab.CategoricalAlgebra.Limits</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Limits and colimits in a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.AbstractColimit" href="#Catlab.CategoricalAlgebra.Limits.AbstractColimit"><code>Catlab.CategoricalAlgebra.Limits.AbstractColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for colimit in a category.</p><p>The standard concrete subtype is <a href="#Catlab.CategoricalAlgebra.Limits.Colimit"><code>Colimit</code></a>, although for computational reasons certain categories may use different subtypes to include extra data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.AbstractLimit" href="#Catlab.CategoricalAlgebra.Limits.AbstractLimit"><code>Catlab.CategoricalAlgebra.Limits.AbstractLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for limit in a category.</p><p>The standard concrete subtype is <a href="#Catlab.CategoricalAlgebra.Limits.Limit"><code>Limit</code></a>, although for computational reasons certain categories may use different subtypes to include extra data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.Colimit" href="#Catlab.CategoricalAlgebra.Limits.Colimit"><code>Catlab.CategoricalAlgebra.Limits.Colimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Colimit in a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L92-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm" href="#Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm"><code>Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for computing colimits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L112-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer" href="#Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer"><code>Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute pushout by composing a coproduct with a coequalizer.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer"><code>ComposeProductEqualizer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L511-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer" href="#Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer"><code>Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute pullback by composing a product with an equalizer.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer"><code>ComposeCoproductCoequalizer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L477-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.Limit" href="#Catlab.CategoricalAlgebra.Limits.Limit"><code>Catlab.CategoricalAlgebra.Limits.Limit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Limit in a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L49-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.LimitAlgorithm" href="#Catlab.CategoricalAlgebra.Limits.LimitAlgorithm"><code>Catlab.CategoricalAlgebra.Limits.LimitAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for computing limits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L69-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.SpecializeColimit" href="#Catlab.CategoricalAlgebra.Limits.SpecializeColimit"><code>Catlab.CategoricalAlgebra.Limits.SpecializeColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-algorithm that reduces general colimits to common special cases.</p><p>Dual to <a href="#Catlab.CategoricalAlgebra.Limits.SpecializeLimit"><code>SpecializeLimit</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L417-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.SpecializeLimit" href="#Catlab.CategoricalAlgebra.Limits.SpecializeLimit"><code>Catlab.CategoricalAlgebra.Limits.SpecializeLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-algorithm that reduces general limits to common special cases.</p><p>Reduces limits of free diagrams that happen to be discrete to products. If this fails, fall back to the given algorithm (if any).</p><p>TODO: Reduce free diagrams that are (multi)cospans to (wide) pullbacks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L384-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit" href="#Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit"><code>Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute a colimit by reducing the diagram to a free bipartite diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L579-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit" href="#Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit"><code>Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute a limit by reducing the diagram to a free bipartite diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L543-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.coimage-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.coimage-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.coimage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>https://en.wikipedia.org/wiki/Coimage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.colimit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Colimit of a diagram.</p><p>To define colimits in a category with objects <code>Ob</code>, override the method <code>colimit(::FreeDiagram{Ob})</code> for general colimits or <code>colimit(::D)</code> with suitable type <code>D &lt;: FixedShapeFreeDiagram{Ob}</code> for colimits of specific shape, such as coproducts or coequalizers.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}"><code>limit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L131-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.epi_mono-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.epi_mono-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.epi_mono</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The image and coimage are isomorphic. We get this isomorphism using univeral properties.</p><pre><code class="nohighlight hljs">  CoIm′ ╌╌&gt; I ↠ CoIm
    ┆ ⌟     |
    v       v
    I   ⟶  R ↩ Im
    |       ┆
    v    ⌜  v
    R ╌╌&gt; Im′</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L274-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.image-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.image-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.image</code></a> — <span class="docstring-category">Method</span></header><section><div><p>https://en.wikipedia.org/wiki/Image<em>(category</em>theory)#Second_definition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.limit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Limit of a diagram.</p><p>To define limits in a category with objects <code>Ob</code>, override the method <code>limit(::FreeDiagram{Ob})</code> for general limits or <code>limit(::D)</code> with suitable type <code>D &lt;: FixedShapeFreeDiagram{Ob}</code> for limits of specific shape, such as products or equalizers.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}"><code>colimit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L119-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.pullback-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.pullback-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.pullback</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pullback of a pair of morphisms with common codomain.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::Cospan{T})</code> and/or <code>limit(::Multicospan{T})</code> or, if you have already implemented products and equalizers, rely on the default implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L215-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.pushout-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.pushout-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.pushout</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pushout of a pair of morphisms with common domain.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::Span{T})</code> and/or <code>colimit(::Multispan{T})</code> or, if you have already implemented coproducts and coequalizers, rely on the default implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.coequalizer-Tuple{Any, Any}" href="#Catlab.Theories.coequalizer-Tuple{Any, Any}"><code>Catlab.Theories.coequalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coequalizer of morphisms with common domain and codomain.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::ParallelPair{T})</code> or <code>colimit(::ParallelMorphisms{T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L207-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.copair-Tuple{Any, Any}" href="#Catlab.Theories.copair-Tuple{Any, Any}"><code>Catlab.Theories.copair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Copairing of morphisms: universal property of coproducts/pushouts.</p><p>To implement for coproducts of type <code>T</code>, define the method <code>universal(::BinaryCoproduct{T}, ::Cospan{T})</code> and/or <code>universal(::Coproduct{T}, ::Multicospan{T})</code> and similarly for pushouts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L246-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.coproduct-Tuple{Any, Any}" href="#Catlab.Theories.coproduct-Tuple{Any, Any}"><code>Catlab.Theories.coproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coproduct of objects.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::ObjectPair{T})</code> and/or <code>colimit(::DiscreteDiagram{T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L191-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.create-Tuple{T} where T" href="#Catlab.Theories.create-Tuple{T} where T"><code>Catlab.Theories.create</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unique morphism out of an initial object.</p><p>To implement for a type <code>T</code>, define the method <code>universal(::Initial{T}, ::SMulticospan{0,T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L175-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.delete-Tuple{T} where T" href="#Catlab.Theories.delete-Tuple{T} where T"><code>Catlab.Theories.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unique morphism into a terminal object.</p><p>To implement for a type <code>T</code>, define the method <code>universal(::Terminal{T}, ::SMultispan{0,T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L167-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.equalizer-Tuple{Any, Any}" href="#Catlab.Theories.equalizer-Tuple{Any, Any}"><code>Catlab.Theories.equalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Equalizer of morphisms with common domain and codomain.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::ParallelPair{T})</code> and/or <code>limit(::ParallelMorphisms{T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L199-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.factorize-Tuple{Equalizer, Any}" href="#Catlab.Theories.factorize-Tuple{Equalizer, Any}"><code>Catlab.Theories.factorize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Factor morphism through (co)equalizer, via the universal property.</p><p>To implement for equalizers of type <code>T</code>, define the method <code>universal(::Equalizer{T}, ::SMultispan{1,T})</code>. For coequalizers of type <code>T</code>, define the method <code>universal(::Coequalizer{T}, ::SMulticospan{1,T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L259-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.initial-Tuple{Type}" href="#Catlab.Theories.initial-Tuple{Type}"><code>Catlab.Theories.initial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initial object.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::EmptyDiagram{T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.pair-Tuple{Any, Any}" href="#Catlab.Theories.pair-Tuple{Any, Any}"><code>Catlab.Theories.pair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pairing of morphisms: universal property of products/pullbacks.</p><p>To implement for products of type <code>T</code>, define the method <code>universal(::BinaryProduct{T}, ::Span{T})</code> and/or <code>universal(::Product{T}, ::Multispan{T})</code> and similarly for pullbacks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L233-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.product-Tuple{Any, Any}" href="#Catlab.Theories.product-Tuple{Any, Any}"><code>Catlab.Theories.product</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Product of objects.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::ObjectPair{T})</code> and/or <code>limit(::DiscreteDiagram{T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.terminal-Tuple{Type}" href="#Catlab.Theories.terminal-Tuple{Type}"><code>Catlab.Theories.terminal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Terminal object.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::EmptyDiagram{T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.universal" href="#Catlab.Theories.universal"><code>Catlab.Theories.universal</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Universal property of (co)limits.</p><p>Compute the morphism whose existence and uniqueness is guaranteed by the universal property of (co)limits.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}"><code>limit</code></a>, <a href="#Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}"><code>colimit</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L143-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define cartesian monoidal structure using limits.</p><p>Implements an instance of <a href="../theories/#Catlab.Theories.ThCartesianCategory"><code>ThCartesianCategory</code></a> assuming that finite products have been implemented following the limits interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L295-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define cocartesian monoidal structure using colimits.</p><p>Implements an instance of <a href="../theories/#Catlab.Theories.ThCocartesianCategory"><code>ThCocartesianCategory</code></a> assuming that finite coproducts have been implemented following the colimits interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Limits.jl#L336-L341">source</a></section></article><h2 id="Categories"><a class="docs-heading-anchor" href="#Categories">Categories</a><a id="Categories-1"></a><a class="docs-heading-anchor-permalink" href="#Categories" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories" href="#Catlab.CategoricalAlgebra.Categories"><code>Catlab.CategoricalAlgebra.Categories</code></a> — <span class="docstring-category">Module</span></header><section><div><p>2-category of categories, functors, and natural transformations.</p><p>Categories in mathematics appear in the large, often as categories of sets with extra structure, and in the small, as algebraic structures that generalize groups, monoids, preorders, and graphs. This division manifests in Catlab as well. Large categories (in spirit, if not in the <a href="https://ncatlab.org/nlab/show/large+category">technical sense</a>) occur throughout Catlab as <code>@instance</code>s of the theory of categories. For computational reasons, small categories are usually presented by generators and relations.</p><p>This module provides a minimal interface to accomodate both situations. Category instances are supported through the wrapper type <a href="#Catlab.CategoricalAlgebra.Categories.TypeCat"><code>TypeCat</code></a>. Finitely presented categories are provided by another module, <a href="apis/@ref"><code>FinCats</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Cat" href="#Catlab.CategoricalAlgebra.Categories.Cat"><code>Catlab.CategoricalAlgebra.Categories.Cat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Alias for <a href="#Catlab.CategoricalAlgebra.Categories.Category"><code>Category</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L58-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.CatSize" href="#Catlab.CategoricalAlgebra.Categories.CatSize"><code>Catlab.CategoricalAlgebra.Categories.CatSize</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Size of a category, used for dispatch and subtyping purposes.</p><p>A <a href="#Catlab.CategoricalAlgebra.Categories.Category"><code>Category</code></a> type having a particular <code>CatSize</code> means that categories of that type are <em>at most</em> that large.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Category" href="#Catlab.CategoricalAlgebra.Categories.Category"><code>Catlab.CategoricalAlgebra.Categories.Category</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for a category.</p><p>The objects and morphisms in the category have Julia types <code>Ob</code> and <code>Hom</code>, respectively. Note that these types do <em>not</em> necessarily form an <code>@instance</code> of the theory of categories, as they may not meaningfully form a category outside the context of this object. For example, a finite category regarded as a reflexive graph with a composition operation might have type <code>Cat{Int,Int}</code>, where the objects and morphisms are numerical identifiers for vertices and edges in the graph.</p><p>The basic operations available in any category are: <a href="#ACSets.Schemas.dom-Tuple{Category, Any}"><code>dom</code></a>, <a href="#ACSets.Schemas.codom-Tuple{Category, Any}"><code>codom</code></a>, <a href="#Catlab.Theories.id-Tuple{Category, Any}"><code>id</code></a>, <a href="#Catlab.Theories.compose-Tuple{Category, Vararg{Any}}"><code>compose</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L43-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.CompositeFunctor" href="#Catlab.CategoricalAlgebra.Categories.CompositeFunctor"><code>Catlab.CategoricalAlgebra.Categories.CompositeFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Composite of functors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L163-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Functor" href="#Catlab.CategoricalAlgebra.Categories.Functor"><code>Catlab.CategoricalAlgebra.Categories.Functor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for a functor between categories.</p><p>A functor has a domain and a codomain (<a href="#ACSets.Schemas.dom-Tuple{Category, Any}"><code>dom</code></a> and <a href="#ACSets.Schemas.codom-Tuple{Category, Any}"><code>codom</code></a>), which are categories, and object and morphism maps, which can be evaluated using <a href="#Catlab.CategoricalAlgebra.Categories.ob_map-Tuple{Functor, Any}"><code>ob_map</code></a> and <a href="#Catlab.CategoricalAlgebra.Categories.hom_map-Tuple{Functor, Any}"><code>hom_map</code></a>. The functor object can also be called directly when the objects and morphisms have distinct Julia types. This is sometimes but not always the case (see <a href="#Catlab.CategoricalAlgebra.Categories.Category"><code>Category</code></a>), so when writing generic code one should prefer the <code>ob_map</code> and <code>hom_map</code> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L127-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.FunctorCallable" href="#Catlab.CategoricalAlgebra.Categories.FunctorCallable"><code>Catlab.CategoricalAlgebra.Categories.FunctorCallable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Functor defined by two Julia callables, an object map and a morphism map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L209-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.IdentityFunctor" href="#Catlab.CategoricalAlgebra.Categories.IdentityFunctor"><code>Catlab.CategoricalAlgebra.Categories.IdentityFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Identity functor on a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L146-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.LargeCatSize" href="#Catlab.CategoricalAlgebra.Categories.LargeCatSize"><code>Catlab.CategoricalAlgebra.Categories.LargeCatSize</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Size of a large category, such as Set.</p><p>To the extent that they form a category, we regard Julia types and functions (<a href="#Catlab.CategoricalAlgebra.Categories.TypeCat"><code>TypeCat</code></a>) as forming a large category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.OppositeCat" href="#Catlab.CategoricalAlgebra.Categories.OppositeCat"><code>Catlab.CategoricalAlgebra.Categories.OppositeCat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Opposite category, where morphism are reversed.</p><p>Call <code>op(::Cat)</code> instead of directly instantiating this type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L365-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.OppositeFunctor" href="#Catlab.CategoricalAlgebra.Categories.OppositeFunctor"><code>Catlab.CategoricalAlgebra.Categories.OppositeFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Opposite functor, given by the same mapping between opposite categories.</p><p>Call <code>op(::Functor)</code> instead of directly instantiating this type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L382-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Transformation" href="#Catlab.CategoricalAlgebra.Categories.Transformation"><code>Catlab.CategoricalAlgebra.Categories.Transformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for a natural transformation between functors.</p><p>A natural transformation <span>$α: F ⇒ G$</span> has a domain <span>$F$</span> and codomain <span>$G$</span> (<a href="#ACSets.Schemas.dom-Tuple{Category, Any}"><code>dom</code></a> and <a href="#ACSets.Schemas.codom-Tuple{Category, Any}"><code>codom</code></a>), which are functors <span>$F,G: C → D$</span> having the same domain <span>$C$</span> and codomain <span>$D$</span>. The transformation consists of a component <span>$αₓ: Fx → Gx$</span> in <span>$D$</span> for each object <span>$x ∈ C$</span>, accessible using <a href="#Catlab.CategoricalAlgebra.Categories.component"><code>component</code></a> or indexing notation (<code>Base.getindex</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L234-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.TypeCat" href="#Catlab.CategoricalAlgebra.Categories.TypeCat"><code>Catlab.CategoricalAlgebra.Categories.TypeCat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of Julia types regarded as a category.</p><p>The Julia types should form an <code>@instance</code> of the theory of categories (<code>Theories.Category</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ACSets.Schemas.codom-Tuple{Category, Any}" href="#ACSets.Schemas.codom-Tuple{Category, Any}"><code>ACSets.Schemas.codom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Codomain of morphism in category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L83-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ACSets.Schemas.dom-Tuple{Category, Any}" href="#ACSets.Schemas.dom-Tuple{Category, Any}"><code>ACSets.Schemas.dom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Domain of morphism in category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L79-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ACSets.Schemas.hom" href="#ACSets.Schemas.hom"><code>ACSets.Schemas.hom</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Coerce or look up morphism in category.</p><p>See also: <a href="#ACSets.Schemas.ob"><code>ob</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ACSets.Schemas.ob" href="#ACSets.Schemas.ob"><code>ACSets.Schemas.ob</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Coerce or look up object in category.</p><p>Converts the input to an object in the category, which should be of type <code>Ob</code> in a category of type <code>Cat{Ob,Hom}</code>. How this works depends on the category, but a common case is to look up objects, which might be integers or GAT expressions, by their human-readable name, usually a symbol.</p><p>See also: <a href="#ACSets.Schemas.hom"><code>hom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L62-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.co" href="#Catlab.CategoricalAlgebra.Categories.co"><code>Catlab.CategoricalAlgebra.Categories.co</code></a> — <span class="docstring-category">Function</span></header><section><div><p>2-cell dual of a 2-category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L443-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.codom_ob-Tuple{Transformation}" href="#Catlab.CategoricalAlgebra.Categories.codom_ob-Tuple{Transformation}"><code>Catlab.CategoricalAlgebra.Categories.codom_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Codomain object of natural transformation.</p><p>Given <span>$α: F ⇒ G: C → D$</span>, this function returns <span>$D$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L256-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.component" href="#Catlab.CategoricalAlgebra.Categories.component"><code>Catlab.CategoricalAlgebra.Categories.component</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Component of natural transformation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L244-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.dom_ob-Tuple{Transformation}" href="#Catlab.CategoricalAlgebra.Categories.dom_ob-Tuple{Transformation}"><code>Catlab.CategoricalAlgebra.Categories.dom_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Domain object of natural transformation.</p><p>Given <span>$α: F ⇒ G: C → D$</span>, this function returns <span>$C$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.hom_map-Tuple{Functor, Any}" href="#Catlab.CategoricalAlgebra.Categories.hom_map-Tuple{Functor, Any}"><code>Catlab.CategoricalAlgebra.Categories.hom_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate functor on morphism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L142-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.is_hom_equal-Tuple{Category, Any, Any}" href="#Catlab.CategoricalAlgebra.Categories.is_hom_equal-Tuple{Category, Any, Any}"><code>Catlab.CategoricalAlgebra.Categories.is_hom_equal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Are two morphisms in a category equal?</p><p>By default, just checks for equality of Julia objects using <span>$==$</span>. In some categories, checking equality of morphisms may involve nontrivial reasoning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.ob_map-Tuple{Functor, Any}" href="#Catlab.CategoricalAlgebra.Categories.ob_map-Tuple{Functor, Any}"><code>Catlab.CategoricalAlgebra.Categories.ob_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate functor on object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L138-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.op-Tuple{Category}" href="#Catlab.CategoricalAlgebra.Categories.op-Tuple{Category}"><code>Catlab.CategoricalAlgebra.Categories.op</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Oppositization 2-functor.</p><p>The oppositization endo-2-functor on Cat, sending a category to its opposite, is covariant on objects and morphisms and contravariant on 2-morphisms, i.e., is a 2-functor <span>$op: Catᶜᵒ → Cat$</span>. For more explanation, see the <a href="https://ncatlab.org/nlab/show/opposite+category">nLab</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L429-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.compose-Tuple{Category, Vararg{Any}}" href="#Catlab.Theories.compose-Tuple{Category, Vararg{Any}}"><code>Catlab.Theories.compose</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compose morphisms in a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L91-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.id-Tuple{Category, Any}" href="#Catlab.Theories.id-Tuple{Category, Any}"><code>Catlab.Theories.id</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Identity morphism on object in category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Categories.jl#L87-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats" href="#Catlab.CategoricalAlgebra.FinCats"><code>Catlab.CategoricalAlgebra.FinCats</code></a> — <span class="docstring-category">Module</span></header><section><div><p>2-category of finitely presented categories.</p><p>This module is for the 2-category <strong>Cat</strong> what the module <a href="apis/@ref"><code>FinSets</code></a> is for the category <strong>Set</strong>: a finitary, combinatorial setting where explicit calculations can be carried out. We emphasize that the prefix <code>Fin</code> means &quot;finitely presented,&quot; not &quot;finite,&quot; as finite categories are too restrictive a notion for many purposes. For example, the free category on a graph is finite if and only if the graph is DAG, which is a fairly special condition. This usage of <code>Fin</code> is also consistent with <code>FinSet</code> because for sets, being finite and being finitely presented are equivalent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCat" href="#Catlab.CategoricalAlgebra.FinCats.FinCat"><code>Catlab.CategoricalAlgebra.FinCats.FinCat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A finitely presented (but not necessarily finite!) category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L41-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatGraph" href="#Catlab.CategoricalAlgebra.FinCats.FinCatGraph"><code>Catlab.CategoricalAlgebra.FinCats.FinCatGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for category backed by finite generating graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L120-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq" href="#Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq"><code>Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Category presented by a finite graph together with path equations.</p><p>The objects of the category are vertices in the graph and the morphisms are paths, quotiented by the congruence relation generated by the path equations. See (Spivak, 2014, <em>Category theory for the sciences</em>, §4.5).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L252-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph" href="#Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph"><code>Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for category whose morphisms are paths in a graph.</p><p>(Or equivalence classes of paths in a graph, but we compute with</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatPresentation" href="#Catlab.CategoricalAlgebra.FinCats.FinCatPresentation"><code>Catlab.CategoricalAlgebra.FinCats.FinCatPresentation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Category defined by a <code>Presentation</code> object.</p><p>The presentation type can, of course, be a category (<code>Theories.Category</code>). It can also be a schema (<code>Theories.Schema</code>). In this case, the schema&#39;s objects and attribute types are regarded as the category&#39;s objects and the schema&#39;s morphisms, attributes, and attribute types as the category&#39;s morphisms (where the attribute types are identity morphisms). When the schema is formalized as a profunctor whose codomain category is discrete, this amounts to taking the collage of the profunctor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L280-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatSize" href="#Catlab.CategoricalAlgebra.FinCats.FinCatSize"><code>Catlab.CategoricalAlgebra.FinCats.FinCatSize</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Size of a finitely presented category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L37-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinDomFunctor" href="#Catlab.CategoricalAlgebra.FinCats.FinDomFunctor"><code>Catlab.CategoricalAlgebra.FinCats.FinDomFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A functor out of a finitely presented category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L355-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap" href="#Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap"><code>Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Functor out of a finitely presented category given by explicit mappings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L461-L463">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinFunctor" href="#Catlab.CategoricalAlgebra.FinCats.FinFunctor"><code>Catlab.CategoricalAlgebra.FinCats.FinFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A functor between finitely presented categories.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L445-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinTransformation" href="#Catlab.CategoricalAlgebra.FinCats.FinTransformation"><code>Catlab.CategoricalAlgebra.FinCats.FinTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A natural transformation whose domain category is finitely generated.</p><p>This type is for natural transformations <span>$α: F ⇒ G: C → D$</span> such that the domain category <span>$C$</span> is finitely generated. Such a natural transformation is given by a finite amount of data (one morphism in <span>$D$</span> for each generating object of <span>$C$</span>) and its naturality is verified by finitely many equations (one equation for each generating morphism of <span>$C$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L542-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinTransformationMap" href="#Catlab.CategoricalAlgebra.FinCats.FinTransformationMap"><code>Catlab.CategoricalAlgebra.FinCats.FinTransformationMap</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Natural transformation with components given by explicit mapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L604-L606">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FreeCatGraph" href="#Catlab.CategoricalAlgebra.FinCats.FreeCatGraph"><code>Catlab.CategoricalAlgebra.FinCats.FreeCatGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Free category generated by a finite graph.</p><p>The objects of the free category are vertices in the graph and the morphisms are (possibly empty) paths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L229-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.Path" href="#Catlab.CategoricalAlgebra.FinCats.Path"><code>Catlab.CategoricalAlgebra.FinCats.Path</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Path in a graph.</p><p>The path is allowed to be empty but always has definite start and end points (source and target vertices).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.collect_hom-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}" href="#Catlab.CategoricalAlgebra.FinCats.collect_hom-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>Catlab.CategoricalAlgebra.FinCats.collect_hom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Collect assignments of functor&#39;s morphism map as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L400-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.collect_ob-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}" href="#Catlab.CategoricalAlgebra.FinCats.collect_ob-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>Catlab.CategoricalAlgebra.FinCats.collect_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Collect assignments of functor&#39;s object map as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L396-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.components-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}" href="#Catlab.CategoricalAlgebra.FinCats.components-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}"><code>Catlab.CategoricalAlgebra.FinCats.components</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Components of a natural transformation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L555-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.force" href="#Catlab.CategoricalAlgebra.FinCats.force"><code>Catlab.CategoricalAlgebra.FinCats.force</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Force evaluation of lazily defined function or functor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L515-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.functoriality_failures-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}" href="#Catlab.CategoricalAlgebra.FinCats.functoriality_failures-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>Catlab.CategoricalAlgebra.FinCats.functoriality_failures</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the purported functor on a presented category functorial?</p><p>This function checks that functor preserves domains and codomains. When <code>check_equations</code> is <code>true</code> (the default is <code>false</code>), it also purports to check that the functor preserves all equations in the domain category. No nontrivial  checks are currently implemented, so this only functions for identity functors.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}"><code>is_natural</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L404-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.graph-Tuple{FinCatGraph}" href="#Catlab.CategoricalAlgebra.FinCats.graph-Tuple{FinCatGraph}"><code>Catlab.CategoricalAlgebra.FinCats.graph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generating graph for a finitely presented category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L124-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.hom_generator" href="#Catlab.CategoricalAlgebra.FinCats.hom_generator"><code>Catlab.CategoricalAlgebra.FinCats.hom_generator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Coerce or look up morphism generator in a finitely presented category.</p><p>Since morphism generators often have a different data type than morphisms (e.g., in a free category on a graph, the morphism generators are edges and the morphisms are paths), the return type of this function is generally different than that of <a href="#ACSets.Schemas.hom"><code>hom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L70-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.hom_generator_name" href="#Catlab.CategoricalAlgebra.FinCats.hom_generator_name"><code>Catlab.CategoricalAlgebra.FinCats.hom_generator_name</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Name of morphism generator, if any.</p><p>When morphism generators have names, this function is a one-sided inverse to <a href="#Catlab.CategoricalAlgebra.FinCats.hom_generator"><code>hom_generator</code></a>. See also: <a href="#Catlab.CategoricalAlgebra.FinCats.ob_generator_name"><code>ob_generator_name</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.hom_generators" href="#Catlab.CategoricalAlgebra.FinCats.hom_generators"><code>Catlab.CategoricalAlgebra.FinCats.hom_generators</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Morphism generators of finitely presented category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L57-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_discrete-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.FinCats.is_discrete-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.FinCats.is_discrete</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the category discrete?</p><p>A category is <em>discrete</em> if it is has no non-identity morphisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_free-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.FinCats.is_free-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.FinCats.is_free</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the category freely generated?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L102-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_initial-Tuple{Functor{Dom, Codom} where {Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}}" href="#Catlab.CategoricalAlgebra.FinCats.is_initial-Tuple{Functor{Dom, Codom} where {Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}}"><code>Catlab.CategoricalAlgebra.FinCats.is_initial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Dual to a <a href="https://ncatlab.org/nlab/show/final+functor">final functor</a>, an <em>initial functor</em> is one for which pulling back diagrams along it does not change the limits of these diagrams.</p><p>This amounts to checking, for a functor C-&gt;D, that, for every object d in Ob(D), the comma category (F/d) is connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L661-L668">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}" href="#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}"><code>Catlab.CategoricalAlgebra.FinCats.is_natural</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the transformation between <code>FinDomFunctors</code> a natural transformation?</p><p>This function uses the fact that to check whether a transformation is natural, it suffices to check the naturality equations on a generating set of morphisms of the domain category. In some cases, checking the equations may be expensive or impossible. When the keyword argument <code>check_equations</code> is <code>false</code>, only the domains and codomains of the components are checked.</p><p>See also: <a href="apis/@ref"><code>is_functorial</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L560-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.ob_generator" href="#Catlab.CategoricalAlgebra.FinCats.ob_generator"><code>Catlab.CategoricalAlgebra.FinCats.ob_generator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Coerce or look up object generator in a finitely presented category.</p><p>Because object generators usually coincide with objects, the default method for <a href="#ACSets.Schemas.ob"><code>ob</code></a> in finitely presented categories simply calls this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.ob_generator_name" href="#Catlab.CategoricalAlgebra.FinCats.ob_generator_name"><code>Catlab.CategoricalAlgebra.FinCats.ob_generator_name</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Name of object generator, if any.</p><p>When object generators have names, this function is a one-sided inverse to <a href="#Catlab.CategoricalAlgebra.FinCats.ob_generator"><code>ob_generator</code></a> in that <code>ob_generator(C, ob_generator_name(C, x)) == x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.ob_generators" href="#Catlab.CategoricalAlgebra.FinCats.ob_generators"><code>Catlab.CategoricalAlgebra.FinCats.ob_generators</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Object generators of finitely presented category.</p><p>The object generators of finite presented category are almost always the same as the objects. In principle, however, it is possible to have equations between objects, so that there are fewer objects than object generators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/FinCats.jl#L49-L55">source</a></section></article><h2 id="Acsets"><a class="docs-heading-anchor" href="#Acsets">Acsets</a><a id="Acsets-1"></a><a class="docs-heading-anchor-permalink" href="#Acsets" title="Permalink"></a></h2><h3 id="Overview-and-Theory"><a class="docs-heading-anchor" href="#Overview-and-Theory">Overview and Theory</a><a id="Overview-and-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-and-Theory" title="Permalink"></a></h3><p>For an in depth look into the theory behind acsets, we refer the reader to <a href="https://arxiv.org/abs/2106.04703">our paper</a> on the subject, which also gives some sense as to how the implementation works. Here, we give a brief tutorial before the the API documentation.</p><p>The most essential part of the acset machinery is the schema. The schema <em>parameterizes</em> the acset: each schema corresponds to a different type of acset. Schemas consist of four parts.</p><ul><li>Objects <span>$X,Y$</span> (<code>(X,Y,Z)::Ob</code>)</li><li>Homomorphisms <span>$f \colon X \to Y$</span> (<code>f :: Hom(X,Y)</code>), which go from objects to objects</li><li>Attribute types <span>$\mathtt{T}$</span> (<code>T :: AttrType</code>)</li><li>Attributes <span>$a \colon X \to \mathtt{T}$</span> (<code>a :: Attr(X,T)</code>), which go from objects to data types</li></ul><p>For those with a categorical background, a schema is a presentation of a category <span>$|S|$</span> along with a functor <span>$S$</span> from <span>$|S|$</span> to the arrow category <span>$0 \to 1$</span>, such that <span>$S^{-1}(1)$</span> is discrete.</p><p>An acset <span>$F$</span> on a schema consists of...</p><ul><li>a set <span>$F(X)$</span> of &quot;primary keys&quot; for each object</li><li>a function <span>$F(f) \colon F(X) \to F(Y)$</span> for each morphism</li><li>a Julia data type <span>$F(\mathtt{T})$</span> for each data type <span>$\mathtt{T}$</span></li><li>a function <span>$F(a) \colon F(X) \to F(\mathtt{T})$</span> for each attribute <span>$a$</span>.</li></ul><p>For those with a categorical background, an acset on a schema <span>$S$</span> consists of a functor from <span>$S$</span> to <span>$\mathsf{Set}$</span>, such that objects in <span>$S^{-1}(0)$</span> map to finite sets, and objects in <span>$S^{-1}(1)$</span> map to sets that represent types. For any particular functor <span>$K \colon S^{-1}(1) \to \mathsf{Set}$</span>, we can also take the category of acsets that restrict to this map on <span>$S^{-1}$</span>.</p><p>We can also add equations to this presentation, but we currently do nothing with those equations in the implementation; they mostly serve as documentation.</p><p>We will now give an example of how this all works in practice.</p><pre><code class="language-julia hljs">using Catlab, Catlab.CategoricalAlgebra

# Write down the schema for a weighted graph
@present SchWeightedGraph(FreeSchema) begin
  V::Ob
  E::Ob
  src::Hom(E,V)
  tgt::Hom(E,V)
  T::AttrType
  weight::Attr(E,T)
end

# Construct the type used to store acsets on the previous schema
# We *index* src and tgt, which means that we store not only
# the forwards map, but also the backwards map.
@acset_type WeightedGraph(SchWeightedGraph, index=[:src,:tgt])

# Construct a weighted graph, with floats as edge weights
g = @acset WeightedGraph{Float64} begin
  V = 4
  E = 5
  src = [1,1,1,2,3]
  tgt = [2,3,4,4,4]
  weight = [7.2, 9.3, 9.4, 0.1, 42.0]
end</code></pre><div class="c-set">
<span class="c-set-summary">Main.__atexample__334.WeightedGraph{Float64} with elements V = 1:4, E = 1:5, T = 1:0</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowNumber" style = "font-weight: bold; text-align: right;">E</th>
      <th style = "text-align: right;">src</th>
      <th style = "text-align: right;">tgt</th>
      <th style = "text-align: right;">weight</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">7.2</td>
    </tr>
    <tr>
      <td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">9.3</td>
    </tr>
    <tr>
      <td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">9.4</td>
    </tr>
    <tr>
      <td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">0.1</td>
    </tr>
    <tr>
      <td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">42.0</td>
    </tr>
  </tbody>
</table>
</div>
<h3 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h3><p>The mathematical abstraction of an acset can of course be implemented in many different ways. Currently, there are three implementations of acsets in Catlab, which share a great deal of code.</p><p>These implementations can be split into two categories.</p><p>The first category is <strong>static acset types</strong>. In this implementation, different schemas correspond to different Julia types. Methods on these Julia types are then custom-generated for the schema, using <a href="https://github.com/AlgebraicJulia/CompTime.jl">CompTime.jl</a>.</p><p>Under this category, there are two classes of static acset types. The first class is acset types that are generated using the <code>@acset_type</code> macro. These acset types are custom-derived structs. The advantage of this is that the structs have names like <code>Graph</code> or <code>WiringDiagram</code> that are printed out in error messages. The disadvantage is that if you are taking in schemas at runtime, you have to <code>eval</code> code in order to use them.</p><p>Here is an example of using <code>@acset_type</code></p><pre><code class="language-julia hljs">@acset_type WeightedGraph(SchWeightedGraph, index=[:src,:tgt])
g = WeightedGraph()</code></pre><p>The second class is <code>AnonACSet</code>s. Like acset types derived from <code>@acset_type</code>, these contain the schema in their type. However, they also contain the type of their fields in their types, so the types printed out in error messages are long and ugly. The advantage of these is that they can be used in situations where the schema is passed in at runtime, and they don&#39;t require using <code>eval</code> to create a new acset type.</p><p>Here is an example of using <code>AnonACSet</code></p><pre><code class="language-julia hljs">const WeightedGraph = AnonACSetType(SchWeightedGraph, index=[:src,:tgt])
g = WeightedGraph()</code></pre><p>The second category is <strong>dynamic acset types</strong>. Currently, there is just one type that falls under this category: <code>DynamicACSet</code>. This type has a <strong>field</strong> for the schema, and no code-generation is done for operations on acsets of this type. This means that if the schema is large compared to the data, this type will often be faster than the static acsets.</p><p>However, dynamics acsets are a new addition to Catlab, and much of the machinery of limits, colimits, and other high-level acset constructions assumes that the schema of an acset can be derived from the type. Thus, more work will have to be done before dynamic acsets become a drop-in replacement for static acsets.</p><p>Here is an example of using a dynamic acset</p><pre><code class="language-julia hljs">g = DynamicACSet(&quot;WeightedGraph&quot;, SchWeightedGraph; index=[:src,:tgt])</code></pre><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets" href="#Catlab.CategoricalAlgebra.CSets"><code>Catlab.CategoricalAlgebra.CSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Categories of C-sets and attributed C-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetHomomorphismAlgorithm" href="#Catlab.CategoricalAlgebra.CSets.ACSetHomomorphismAlgorithm"><code>Catlab.CategoricalAlgebra.CSets.ACSetHomomorphismAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for finding homomorphisms between attributed <span>$C$</span>-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L704">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.ACSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.ACSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Transformation between attributed C-sets.</p><p>Homomorphisms of attributed C-sets generalize homomorphisms of C-sets (<a href="#Catlab.CategoricalAlgebra.CSets.CSetTransformation"><code>CSetTransformation</code></a>), which you should understand before reading this.</p><p>A <em>homomorphism</em> of attributed C-sets with schema S: C ↛ A (a profunctor) is a natural transformation between the corresponding functors col(S) → Set, where col(S) is the collage of S. When the components on attribute types, indexed by objects of A, are all identity functions, the morphism is called <em>tight</em>; in general, it is called <em>loose</em>. With this terminology, acsets on a fixed schema are the objects of an ℳ-category (see <code>Catlab.Theories.MCategory</code>). Calling <code>ACSetTransformation</code> will construct a tight or loose morphism as appropriate, depending on which components are specified.</p><p>Since every tight morphism can be considered a loose one, the distinction between tight and loose may seem a minor technicality, but it has important consequences because limits and colimits in a category depend as much on the morphisms as on the objects. In particular, limits and colimits of acsets differ greatly depending on whether they are taken in the category of acsets with tight morphisms or with loose morphisms. Tight morphisms suffice for many purposes, including most applications of colimits. However, when computing limits of acsets, loose morphisms are usually preferable. For more information about limits and colimits in these categories, see <a href="#Catlab.CategoricalAlgebra.CSets.TightACSetTransformation"><code>TightACSetTransformation</code></a> and <a href="#Catlab.CategoricalAlgebra.CSets.LooseACSetTransformation"><code>LooseACSetTransformation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L252-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.ACSetTransformation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Move components as first argument</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{StructACSet}" href="#Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{StructACSet}"><code>Catlab.CategoricalAlgebra.CSets.ACSetTransformation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A map f (from A to B) as a map from A to a subobject of B</p><p><strong>i.e. get the image of f as a subobject of B</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L1559-L1562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{Subobject{&lt;:StructACSet{S}} where S}" href="#Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{Subobject{&lt;:StructACSet{S}} where S}"><code>Catlab.CategoricalAlgebra.CSets.ACSetTransformation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A map f (from A to B) as a map of subobjects of A to subjects of B</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L1550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.BacktrackingSearch" href="#Catlab.CategoricalAlgebra.CSets.BacktrackingSearch"><code>Catlab.CategoricalAlgebra.CSets.BacktrackingSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Find attributed <span>$C$</span>-set homomorphisms using backtracking search.</p><p>This procedure uses the classic backtracking search algorithm for a combinatorial constraint satisfaction problem (CSP). As is well known, the homomorphism problem for relational databases is reducible to CSP. Since the C-set homomorphism problem is &quot;the same&quot; as the database homomorphism problem (insofar as attributed C-sets are &quot;the same&quot; as relational databases), it is also reducible to CSP. Backtracking search for CSP is described in many computer science textbooks, such as (Russell &amp; Norvig 2010, <em>Artificial Intelligence</em>, Third Ed., Chapter 6: Constraint satisfaction problems, esp. Algorithm 6.5). In our implementation, the search tree is ordered using the popular heuristic of &quot;minimum remaining values&quot; (MRV), also known as &quot;most constrained variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L707-L720">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.CSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.CSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.CSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Transformation between C-sets.</p><p>Recall that a C-set homomorphism is a natural transformation: a transformation between functors C → Set satisfying the naturality axiom for every morphism, or equivalently every generating morphism, in C.</p><p>This data type records the data of a C-set transformation. Naturality is not strictly enforced but is expected to be satisfied. It can be checked using the function <a href="#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}"><code>is_natural</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L360-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.HomomorphismQuery" href="#Catlab.CategoricalAlgebra.CSets.HomomorphismQuery"><code>Catlab.CategoricalAlgebra.CSets.HomomorphismQuery</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Find attributed <span>$C$</span>-set homomorphisms using a conjunctive query.</p><p>This algorithm evaluates a conjunctive query (limit in <code>FinSet</code>) to find all homomorphisms between two <span>$C$</span>-sets. In fact, conjunctive queries are exactly the <em>representable</em> functors from <span>$C$</span>-sets to sets, so every conjunctive query arises in this way, with the caveat that conjunctive queries may correspond to to infinite <span>$C$</span>-sets when <span>$C$</span> is infinite (but possibly finitely presented).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L722-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.LooseACSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.LooseACSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.LooseACSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Loose transformation between attributed C-sets.</p><p>Limits and colimits in the category of attributed C-sets and loose homomorphisms are computed pointwise on both objects <em>and</em> attribute types. This implies that (co)limits of Julia types must be computed. Due to limitations in the expressivity of Julia&#39;s type system, only certain simple kinds of (co)limits, such as products, are supported.</p><p>Alternatively, colimits involving loose acset transformations can be constructed with respect to explicitly given attribute type components for the legs of the cocone, via the keyword argument <code>type_components</code> to <code>colimit</code> and related functions. This uses the universal property of the colimit. To see how this works, notice that a diagram of acsets and loose acset transformations can be expressed as a diagram D: J → C-Set (for the C-sets) along with another diagram A: J → C-Set (for the attribute sets) and a natural transformation α: D ⇒ A (assigning attributes). Given a natural transformation τ: A ⇒ ΔB to a constant functor ΔB, with components given by <code>type_components</code>, the composite transformation α⋅τ: D ⇒ ΔB is a cocone under D, hence factors through the colimit cocone of D. This factoring yields an assigment of attributes to the colimit in C-Set.</p><p>For the distinction between tight and loose, see <a href="apis/@ref"><code>ACSetTranformation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L292-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.SubCSet" href="#Catlab.CategoricalAlgebra.CSets.SubCSet"><code>Catlab.CategoricalAlgebra.CSets.SubCSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Sub-C-set of a C-set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L1388-L1390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.TightACSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.TightACSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.TightACSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tight transformation between attributed C-sets.</p><p>The category of attributed C-sets and tight homomorphisms is isomorphic to a slice category of C-Set, as explained in our paper &quot;Categorical Data Structures for Technical Computing&quot;. Colimits in this category thus reduce to colimits of C-sets, by a standard result about slice categories. Limits are more complicated and are currently not supported.</p><p>For the distinction between tight and loose, see <a href="apis/@ref"><code>ACSetTranformation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L279-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ACSets.ACSetInterface.copy_parts!-Tuple{ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}" href="#ACSets.ACSetInterface.copy_parts!-Tuple{ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>ACSets.ACSetInterface.copy_parts!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Copy parts from a set-valued <code>FinDomFunctor</code> to an <code>ACSet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L230-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.homomorphism</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find a homomorphism between two attributed <span>$C$</span>-sets.</p><p>Returns <code>nothing</code> if no homomorphism exists. For many categories <span>$C$</span>, the <span>$C$</span>-set homomorphism problem is NP-complete and thus this procedure generally runs in exponential time. It works best when the domain object is small.</p><p>To restrict to <em>monomorphisms</em>, or homomorphisms whose components are all injective functions, set the keyword argument <code>monic=true</code>. To restrict only certain components to be injective or bijective, use <code>monic=[...]</code> or <code>iso=[...]</code>. For example, setting <code>monic=[:V]</code> for a graph homomorphism ensures that the vertex map is injective but imposes no constraints on the edge map.</p><p>To restrict the homomorphism to a given partial assignment, set the keyword argument <code>initial</code>. For example, to fix the first source vertex to the third target vertex in a graph homomorphism, set <code>initial=(V=Dict(1 =&gt; 3),)</code>. Use  the keyword argument <code>type_components</code> to specify nontrivial components on  attribute types for a loose homomorphism. These components must be callable: either Julia functions on the appropriate types or FinFunction(Dict(...)).</p><p>Use the keyword argument <code>alg</code> to set the homomorphism-finding algorithm. By default, a backtracking search algorithm is used (<a href="#Catlab.CategoricalAlgebra.CSets.BacktrackingSearch"><code>BacktrackingSearch</code></a>). Use the keyword argument error_failures = true to get errors explaining  any immediate inconsistencies in specified initial data.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.CSets.homomorphisms-Tuple{ACSet, ACSet}"><code>homomorphisms</code></a>, <a href="#Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{ACSet, ACSet}"><code>isomorphism</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L732-L758">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.homomorphisms-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.homomorphisms-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.homomorphisms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find all homomorphisms between two attributed <span>$C$</span>-sets.</p><p>This function is at least as expensive as <a href="#Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{ACSet, ACSet}"><code>homomorphism</code></a> and when no homomorphisms exist, it is exactly as expensive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L769-L774">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.is_homomorphic-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.is_homomorphic-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.is_homomorphic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the first attributed <span>$C$</span>-set homomorphic to the second?</p><p>This function generally reduces to <a href="#Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{ACSet, ACSet}"><code>homomorphism</code></a> but certain algorithms may have minor optimizations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L785-L790">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.is_isomorphic-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.is_isomorphic-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.is_isomorphic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Are the two attributed <span>$C$</span>-sets isomorphic?</p><p>This function generally reduces to <a href="#Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{ACSet, ACSet}"><code>isomorphism</code></a> but certain algorithms may have minor optimizations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L817-L822">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.isomorphism</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find an isomorphism between two attributed <span>$C$</span>-sets, if one exists.</p><p>See <a href="#Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{ACSet, ACSet}"><code>homomorphism</code></a> for more information about the algorithms involved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L796-L800">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.isomorphisms-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.isomorphisms-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.isomorphisms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find all isomorphisms between two attributed <span>$C$</span>-sets.</p><p>This function is at least as expensive as <a href="#Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{ACSet, ACSet}"><code>isomorphism</code></a> and when no homomorphisms exist, it is exactly as expensive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L806-L811">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.maximum_common_subobject-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:ACSet" href="#Catlab.CategoricalAlgebra.CSets.maximum_common_subobject-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:ACSet"><code>Catlab.CategoricalAlgebra.CSets.maximum_common_subobject</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the Maximimum Common C-Sets from a vector of C-Sets.</p><p>Find an ACSet `<span>$a$</span> with maximum possible size (<span>$|a|$</span>) such that there is a   monic span of ACSets <span>$a₁ ← a → a₂$</span>. There may be many maps from this overlap  into each of the inputs, so a Vector{Vector{ACSetTransformations}} per overlap  is returned (a cartesian product can be taken of these to obtain all possible  multispans for that overlap). If there are multiple overlaps of equal size,  these are all returned.</p><p>If there are attributes, we ignore these and use variables in the apex of the  overlap.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L1785-L1797">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.naturality_failures-Tuple{Any, Any, Any}" href="#Catlab.CategoricalAlgebra.CSets.naturality_failures-Tuple{Any, Any, Any}"><code>Catlab.CategoricalAlgebra.CSets.naturality_failures</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a dictionary whose keys are contained in the names in <code>arrows(S)</code> and whose value at <code>:f</code>, for an arrow <code>(f,c,d)</code>, is a lazy iterator over the elements of X(c) on which α&#39;s naturality square for f does not commute. Components should be a NamedTuple or Dictionary with keys contained in the names of S&#39;s morphisms and values vectors or dicts defining partial functions from X(c) to Y(c).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L551-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.subobject_graph-Tuple{ACSet}" href="#Catlab.CategoricalAlgebra.CSets.subobject_graph-Tuple{ACSet}"><code>Catlab.CategoricalAlgebra.CSets.subobject_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Preorder of subobjects via inclusion.  Returns a graph + list of subobjects corresponding to its vertices.  The subobjects are ordered by decreasing size (so it&#39;s topologically sorted)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L1633-L1637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{LooseACSetTransformation}" href="#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{LooseACSetTransformation}"><code>Catlab.CategoricalAlgebra.FinCats.is_natural</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check naturality condition for a purported ACSetTransformation, α: X→Y.  For each hom in the schema, e.g. h: m → n, the following square must commute:      αₘ   Xₘ –&gt; Yₘ Xₕ ↓  ✓  ↓ Yₕ   Xₙ –&gt; Yₙ      αₙ  You&#39;re allowed to run this on a named tuple partly specifying an ACSetTransformation, though at this time the domain and codomain must be fully specified ACSets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L531-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.@acset_transformation-Tuple{Any, Any, Vararg{Any}}" href="#Catlab.CategoricalAlgebra.CSets.@acset_transformation-Tuple{Any, Any, Vararg{Any}}"><code>Catlab.CategoricalAlgebra.CSets.@acset_transformation</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Provides a shorthand for constructing a tight acset transformation by giving its components. Homomorphism search allows partial specification, with the return value being the unique extension if it exists.</p><p>Keyword arguments can be passed on to the search function after the body of the transformation.</p><p>Example usage for transformation between <code>WeightedGraph{String}</code>:</p><pre><code class="nohighlight hljs">@acset_transformation A B begin
  V = [3,5,2] #complete specification can be a vector
  E = Dict(1 =&gt; 3, 4 =&gt; 3) #otherwise use a dict
end monic=true iso=[:V] or [:V,:E], etc</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/CSets.jl#L624-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.DataMigrations" href="#Catlab.CategoricalAlgebra.DataMigrations"><code>Catlab.CategoricalAlgebra.DataMigrations</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Functorial data migration for attributed C-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/DataMigrations.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.DataMigrations.DataMigration" href="#Catlab.CategoricalAlgebra.DataMigrations.DataMigration"><code>Catlab.CategoricalAlgebra.DataMigrations.DataMigration</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Data migration functor given contravariantly.</p><p>This type encompasses data migration functors from <span>$C$</span>-sets to <span>$D$</span>-sets given contravariantly by a functor out of the schema <span>$D$</span>. The simplest such functor is a pullback data migration (<a href="#Catlab.CategoricalAlgebra.DataMigrations.DeltaMigration"><code>DeltaMigration</code></a>), specified by a functor <span>$D → C$</span> between the schemas. Other important cases include conjunctive and duc data migrations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/DataMigrations.jl#L74-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.DataMigrations.DeltaMigration" href="#Catlab.CategoricalAlgebra.DataMigrations.DeltaMigration"><code>Catlab.CategoricalAlgebra.DataMigrations.DeltaMigration</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Delta or pullback functorial data migration between acsets.</p><p>Given a functor <span>$F: D → C$</span>, the delta migration functor <span>$Δ_F$</span> from <span>$C$</span>-sets to <span>$D$</span>-sets is defined contravariantly by <span>$Δ_F(X) := X ∘ F$</span>.</p><p>See (Spivak, 2014, <em>Category Theory for the Sciences</em>) for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/DataMigrations.jl#L93-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.DataMigrations.SigmaMigration" href="#Catlab.CategoricalAlgebra.DataMigrations.SigmaMigration"><code>Catlab.CategoricalAlgebra.DataMigrations.SigmaMigration</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Sigma or left pushforward functorial data migration between acsets.</p><p>Given a functor <span>$F: C → D$</span>, the sigma data migration <span>$Σ_F$</span> is a functor from <span>$C$</span>-sets to <span>$D$</span>-sets that is left adjoint to the delta migration functor <span>$Δ_F$</span> (<a href="#Catlab.CategoricalAlgebra.DataMigrations.DeltaMigration"><code>DeltaMigration</code></a>). Explicitly, the <span>$D$</span>-set <span>$Σ_F(X)$</span> is given on objects <span>$d ∈ D$</span> by the formula <span>$Σ_F(x)(d) = \mathrm{colim}_{F ↓ d} X ∘ π$</span>, where <span>$π: (F ↓ d) → C$</span> is the projection.</p><p>See (Spivak, 2014, <em>Category Theory for the Sciences</em>) for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/DataMigrations.jl#L248-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.DataMigrations.SigmaMigration-Tuple{ACSet}" href="#Catlab.CategoricalAlgebra.DataMigrations.SigmaMigration-Tuple{ACSet}"><code>Catlab.CategoricalAlgebra.DataMigrations.SigmaMigration</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a C-Set for the collage of the functor. Initialize data in the domain  portion of the collage, then run the chase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/DataMigrations.jl#L268-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.DataMigrations.colimit_representables-Tuple{Functor{D, C} where {D&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}, Any}" href="#Catlab.CategoricalAlgebra.DataMigrations.colimit_representables-Tuple{Functor{D, C} where {D&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}, Any}"><code>Catlab.CategoricalAlgebra.DataMigrations.colimit_representables</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Interpret conjunctive data migration as a colimit of representables.</p><p>Given a conjunctive data migration (a functor <code>J → Diag{op}(C)</code>) and the Yoneda embedding for <code>C</code> (a functor <code>op(C) → C-Set</code> computed via <a href="#Catlab.CategoricalAlgebra.DataMigrations.yoneda-Tuple{Any, Presentation{ThSchema}}"><code>yoneda</code></a>), take colimits of representables to construct a <code>op(J)</code>-shaped diagram of C-sets.</p><p>Since every C-set is a colimit of representables, this is a generic way of constructing diagrams of C-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/DataMigrations.jl#L378-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.DataMigrations.migrate!-Tuple{ACSet, ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}" href="#Catlab.CategoricalAlgebra.DataMigrations.migrate!-Tuple{ACSet, ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>Catlab.CategoricalAlgebra.DataMigrations.migrate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Contravariantly migrate data from the acset <code>Y</code> to the acset <code>X</code>.</p><p>This is the mutating variant of <a href="#Catlab.CategoricalAlgebra.DataMigrations.migrate!-Tuple{ACSet, ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>migrate!</code></a>. When the functor on schemas is the identity, this operation is equivalent to <a href="#ACSets.ACSetInterface.copy_parts!-Tuple{ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>copy_parts!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/DataMigrations.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.DataMigrations.migrate-Union{Tuple{T}, Tuple{Type{T}, ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}} where T&lt;:ACSet" href="#Catlab.CategoricalAlgebra.DataMigrations.migrate-Union{Tuple{T}, Tuple{Type{T}, ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}} where T&lt;:ACSet"><code>Catlab.CategoricalAlgebra.DataMigrations.migrate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Contravariantly migrate data from the acset <code>Y</code> to a new acset of type <code>T</code>.</p><p>The mutating variant of this function is <a href="#Catlab.CategoricalAlgebra.DataMigrations.migrate!-Tuple{ACSet, ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>migrate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/DataMigrations.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.DataMigrations.representable-Tuple{Any, Presentation{ThSchema}, Symbol}" href="#Catlab.CategoricalAlgebra.DataMigrations.representable-Tuple{Any, Presentation{ThSchema}, Symbol}"><code>Catlab.CategoricalAlgebra.DataMigrations.representable</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a representable C-set.</p><p>Recall that a <em>representable</em> C-set is one of form <span>$C(c,-): C → Set$</span> for some object <span>$c ∈ C$</span>.</p><p>This function computes the <span>$c$</span> representable as the left pushforward data migration of the singleton <span>${c}$</span>-set along the inclusion functor <span>${c} ↪ C$</span>, which works because left Kan extensions take representables to representables (Mac Lane 1978, Exercise X.3.2). Besides the intrinsic difficulties with representables (they can be infinite), this function thus inherits any limitations of our implementation of left pushforward data migrations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/DataMigrations.jl#L315-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.DataMigrations.representable-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T&lt;:StructACSet" href="#Catlab.CategoricalAlgebra.DataMigrations.representable-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T&lt;:StructACSet"><code>Catlab.CategoricalAlgebra.DataMigrations.representable</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ACSet types do not store info about equations, so this info is lost when we try to recover the presentation from the datatype. Thus, this method for  <code>representable</code> should only be used for free schemas</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/DataMigrations.jl#L336-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.DataMigrations.yoneda-Tuple{Any, Presentation{ThSchema}}" href="#Catlab.CategoricalAlgebra.DataMigrations.yoneda-Tuple{Any, Presentation{ThSchema}}"><code>Catlab.CategoricalAlgebra.DataMigrations.yoneda</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Yoneda embedding of category C in category of C-sets.</p><p>Because Catlab privileges copresheaves (C-sets) over presheaves, this is the <em>contravariant</em> Yoneda embedding, i.e., the embedding C^op → C-Set.</p><p>If representables have already been computed (which can be expensive) they can be provided via the <code>cache</code> keyword argument.</p><p>Input <code>cons</code> is a constructor for the ACSet</p><p>Returns a <code>FinDomFunctor</code> with domain <code>op(C)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/DataMigrations.jl#L344-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Chase" href="#Catlab.CategoricalAlgebra.Chase"><code>Catlab.CategoricalAlgebra.Chase</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The chase is an algorithm which subjects a C-Set instance to constraints  expressed in the language of regular logic, called embedded dependencies  (EDs, or &#39;triggers&#39;). </p><p>A morphism S-&gt;T, encodes an embedded dependency. If the pattern  S is matched (via a homomorphism S-&gt;I), we demand there exist a morphism T-&gt;I  (for some database instance I) that makes the triangle commute in order to  satisfy the dependency (if this is not the case, then the trigger is &#39;active&#39;).</p><p>Homomorphisms can merge elements and introduce new ones. The former kind are called &quot;equality generating dependencies&quot; (EGDs) and the latter &quot;tuple generating dependencies&quot; (TGDs). Any homomorphism can be factored into EGD and TGD components by, respectively, restricting the codomain to the image or restricting the domain to the coimage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Chase.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Chase.chase-Tuple{ACSet, AbstractDict, Int64}" href="#Catlab.CategoricalAlgebra.Chase.chase-Tuple{ACSet, AbstractDict, Int64}"><code>Catlab.CategoricalAlgebra.Chase.chase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chase(I::ACSet, Σ::AbstractDict, n::Int)</code></pre><p>Chase a C-Set or C-Rel instance given a list of embedded dependencies. This may not terminate, so a bound <code>n</code> on the number of iterations is required.</p><pre><code class="nohighlight hljs">[,]</code></pre><p>ΣS  ⟶ Iₙ ⊕↓      ⋮  (resulting morphism)  ΣT ... Iₙ₊₁</p><p>There is a copy of S and T for each active trigger. A trigger is a map from S into the current instance. What makes it &#39;active&#39; is that there is no morphism from T to I that makes the triangle commute.</p><p>Each iteration constructs the above pushout square. The result is a morphism, so that one can keep track of the provenance of elements in the original CSet instance within the chased result.</p><p>Whether or not the result is due to success or timeout is returned as a boolean flag.</p><p>TODO: this algorithm could be made more efficient by homomorphism caching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/Chase.jl#L253-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans" href="#Catlab.CategoricalAlgebra.StructuredCospans"><code>Catlab.CategoricalAlgebra.StructuredCospans</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Structured cospans.</p><p>This module provides a generic interface for structured cospans with a concrete implementation for attributed C-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/StructuredCospans.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetLeg" href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetLeg"><code>Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetLeg</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Leg of a structured (multi)cospan of acsets in R-form.</p><p>A convenience type that contains the data of an acset transformation, except for the codomain, since that data is already given by the decoration of the R-form structured cospan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/StructuredCospans.jl#L237-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structured cospan.</p><p>The first type parameter <code>L</code> encodes a functor L: A → X from the base category <code>A</code>, often FinSet, to a category <code>X</code> with &quot;extra structure.&quot; An L-structured cospan is then a cospan in X whose feet are images under L of objects in A. The category X is assumed to have pushouts.</p><p>Structured cospans form a double category with no further assumptions on the functor L. To obtain a symmetric monoidal double category, L must preserve finite coproducts. In practice, L usually has a right adjoint R: X → A, which implies that L preserves all finite colimits. It also allows structured cospans to be constructed more conveniently from an object x in X plus a cospan in A with apex R(x).</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan"><code>StructuredMulticospan</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/StructuredCospans.jl#L55-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Any, Multicospan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}} where L" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Any, Multicospan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}} where L"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct structured cospan in R-form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/StructuredCospans.jl#L79-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Multicospan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}, StaticArraysCore.StaticArray{Tuple{2}, T, 1} where T}} where L" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Multicospan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}, StaticArraysCore.StaticArray{Tuple{2}, T, 1} where T}} where L"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct structured cospan in L-form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/StructuredCospans.jl#L74-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object in the category of L-structured cospans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/StructuredCospans.jl#L98-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structured multicospan.</p><p>A structured multicospan is like a structured cospan except that it may have a number of legs different than two.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan"><code>StructuredCospan</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/StructuredCospans.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan-Union{Tuple{L}, Tuple{Any, Multicospan}} where L" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan-Union{Tuple{L}, Tuple{Any, Multicospan}} where L"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct structured multicospan in R-form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/StructuredCospans.jl#L43-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S, X&lt;:(StructACSet{S})}" href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S, X&lt;:(StructACSet{S})}"><code>Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create types for open attributed C-sets from an attributed C-set type.</p><p>The type parameters of the given acset type should <em>not</em> be instantiated with specific Julia types. This function returns a pair of types, one for objects, a subtype of <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb"><code>StructuredCospanOb</code></a>, and one for morphisms, a subtype of <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan"><code>StructuredMulticospan</code></a>. Both types will have the same type parameters for attribute types as the given acset type.</p><p>Mathematically speaking, this function sets up structured (multi)cospans with a functor <span>$L: A → X$</span> between categories of acsets that creates &quot;discrete acsets.&quot; Such a &quot;discrete acset functor&quot; is a functor that is left adjoint to a certain kind of forgetful functor between categories of acsets, namely one that is a pullback along an inclusion of schemas such that the image of inclusion has no outgoing arrows. For example, the schema inclusion <span>${V} ↪ {E ⇉ V}$</span> has this property but <span>${E} ↪ {E ⇉ V}$</span> does not.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{Type{X}, Vararg{Any}}} where X&lt;:(StructCSet)"><code>OpenCSetTypes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/StructuredCospans.jl#L192-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{Type{X}, Vararg{Any}}} where X&lt;:(StructCSet)" href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{Type{X}, Vararg{Any}}} where X&lt;:(StructCSet)"><code>Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create types for open C-sets from a C-set type.</p><p>A special case of <a href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S, X&lt;:(StructACSet{S})}"><code>OpenACSetTypes</code></a>. See there for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/2f38f6a2e3289012f1020c008cf6025ffc6ed671/src/categorical_algebra/StructuredCospans.jl#L184-L188">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theories/">« Standard library of theories</a><a class="docs-footer-nextpage" href="../graphs/">Graphs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 8 June 2023 04:07">Thursday 8 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
