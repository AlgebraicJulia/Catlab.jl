<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Categorical algebra · Catlab.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catlab.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Seven Sketches in Compositionality</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/sketches/partitions/">Partitions</a></li><li><a class="tocitem" href="../../generated/sketches/preorders/">Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/meets/">Meets in Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/smc/">Symmetric Monoidal Categories</a></li><li><a class="tocitem" href="../../generated/sketches/cat_elements/">The Category of Elements</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphs/graphs/">The Category of Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/graphs_label/">Labeled Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/subgraphs/">Algebra of subgraphs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Categorical Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/categorical_algebra/diagrams/">Diagrams</a></li><li><a class="tocitem" href="../../generated/categorical_algebra/acset_serialization/">Serializing acsets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Wiring Diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/wd_cset/">Wiring Diagrams as Attributed C-Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/graphviz_graphs/">Drawing graphs in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../core/">Theories, instances, and expressions</a></li><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li class="is-active"><a class="tocitem" href>Categorical algebra</a><ul class="internal"><li><a class="tocitem" href="#Sets-and-Relations"><span>Sets and Relations</span></a></li><li><a class="tocitem" href="#Free-Diagrams,-Limits,-and-Colimts"><span>Free Diagrams, Limits, and Colimts</span></a></li><li><a class="tocitem" href="#Categories"><span>Categories</span></a></li><li><a class="tocitem" href="#Acsets"><span>Acsets</span></a></li></ul></li><li><a class="tocitem" href="../graphs/">Graphs</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li><a class="tocitem" href="../programs/">Programs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Categorical algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Categorical algebra</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/master/docs/src/apis/categorical_algebra.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="categorical_algebra"><a class="docs-heading-anchor" href="#categorical_algebra">Categorical algebra</a><a id="categorical_algebra-1"></a><a class="docs-heading-anchor-permalink" href="#categorical_algebra" title="Permalink"></a></h1><h2 id="Sets-and-Relations"><a class="docs-heading-anchor" href="#Sets-and-Relations">Sets and Relations</a><a id="Sets-and-Relations-1"></a><a class="docs-heading-anchor-permalink" href="#Sets-and-Relations" title="Permalink"></a></h2><p>The following APIs implement FinSet, the category of Finite Sets (actually the skeleton of FinSet). The objects of this category are natural numbers where <code>n</code> represents a set with <code>n</code> elements. The morphisms are functions between such sets. We use the skeleton of FinSet in order to ensure that all sets are finite and morphisms can be stored using lists of integers. Finite relations are built out of FinSet and can be used to do some relational algebra.</p><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets" href="#Catlab.CategoricalAlgebra.Sets"><code>Catlab.CategoricalAlgebra.Sets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Category of (possibly infinite) sets and functions.</p><p>This module defines generic types for the category of sets (<a href="#Catlab.CategoricalAlgebra.Sets.SetOb"><code>SetOb</code></a>, <a href="#Catlab.CategoricalAlgebra.Sets.SetFunction"><code>SetFunction</code></a>), as well as a few basic concrete types, such as a wrapper type to view Julia types as sets (<a href="#Catlab.CategoricalAlgebra.Sets.TypeSet"><code>TypeSet</code></a>). Extensive support for finite sets is provided by another module, <a href="apis/@ref"><code>FinSets</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.ConstantFunction" href="#Catlab.CategoricalAlgebra.Sets.ConstantFunction"><code>Catlab.CategoricalAlgebra.Sets.ConstantFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function in <strong>Set</strong> taking a constant value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.PredicatedSet" href="#Catlab.CategoricalAlgebra.Sets.PredicatedSet"><code>Catlab.CategoricalAlgebra.Sets.PredicatedSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Set defined by a predicate (boolean-valued function) on a Julia data type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.SetFunction" href="#Catlab.CategoricalAlgebra.Sets.SetFunction"><code>Catlab.CategoricalAlgebra.Sets.SetFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for morphism in the category <strong>Set</strong>.</p><p>Every instance of <code>SetFunction{&lt;:SetOb{T},&lt;:SetOb{T′}}</code> is callable with elements of type <code>T</code>, returning an element of type <code>T′</code>.</p><p>Note: This type would be better called simply <code>Function</code> but that name is already taken by the base Julia type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.SetOb" href="#Catlab.CategoricalAlgebra.Sets.SetOb"><code>Catlab.CategoricalAlgebra.Sets.SetOb</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for object in the category <strong>Set</strong>.</p><p>The type parameter <code>T</code> is the element type of the set.</p><p>Note: This type is more abstract than the built-in Julia types <code>AbstractSet</code> and <code>Set</code>, which are intended for data structures for finite sets. Those are encompassed by the subtype <a href="apis/@ref"><code>FinSet</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.TypeSet" href="#Catlab.CategoricalAlgebra.Sets.TypeSet"><code>Catlab.CategoricalAlgebra.Sets.TypeSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Julia data type regarded as a set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.Ob-Union{Tuple{TypeCat{T}}, Tuple{T}} where T" href="#Catlab.Theories.Ob-Union{Tuple{TypeCat{T}}, Tuple{T}} where T"><code>Catlab.Theories.Ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Forgetful functor Ob: Cat → Set.</p><p>Sends a category to its set of objects and a functor to its object map.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets" href="#Catlab.CategoricalAlgebra.FinSets"><code>Catlab.CategoricalAlgebra.FinSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The category of finite sets and functions, and its skeleton.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinDomFunction" href="#Catlab.CategoricalAlgebra.FinSets.FinDomFunction"><code>Catlab.CategoricalAlgebra.FinSets.FinDomFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function out of a finite set.</p><p>This class of functions is convenient because it is exactly the class that can be represented explicitly by a vector of values from the codomain.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinFunction" href="#Catlab.CategoricalAlgebra.FinSets.FinFunction"><code>Catlab.CategoricalAlgebra.FinSets.FinFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function between finite sets.</p><p>The function can be defined implicitly by an arbitrary Julia function, in which case it is evaluated lazily, or explictly by a vector of integers. In the vector representation, the function (1↦1, 2↦3, 3↦2, 4↦3), for example, is represented by the vector [1,3,2,3].</p><p>This type is mildly generalized by <a href="#Catlab.CategoricalAlgebra.FinSets.FinDomFunction"><code>FinDomFunction</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinSet" href="#Catlab.CategoricalAlgebra.FinSets.FinSet"><code>Catlab.CategoricalAlgebra.FinSets.FinSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Finite set.</p><p>A finite set has abstract type <code>FinSet{S,T}</code>. The second type parameter <code>T</code> is the element type of the set and the first parameter <code>S</code> is the collection type, which can be a subtype of <code>AbstractSet</code> or another Julia collection type. In addition, the skeleton of the category <strong>FinSet</strong> is the important special case <code>S = Int</code>. The set <span>${1,…,n}$</span> is represented by the object <code>FinSet(n)</code> of type <code>FinSet{Int,Int}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.HashJoin" href="#Catlab.CategoricalAlgebra.FinSets.HashJoin"><code>Catlab.CategoricalAlgebra.FinSets.HashJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Hash_join">Hash join</a> algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm" href="#Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm"><code>Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for limit of cospan or multicospan with feet being finite sets.</p><p>In the context of relational databases, such limits are called <em>joins</em>. The trivial join algorithm is <a href="#Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin"><code>NestedLoopJoin</code></a>, which is algorithmically equivalent to the generic algorithm <code>ComposeProductEqualizer</code>. The algorithms <a href="#Catlab.CategoricalAlgebra.FinSets.HashJoin"><code>HashJoin</code></a> and <a href="#Catlab.CategoricalAlgebra.FinSets.SortMergeJoin"><code>SortMergeJoin</code></a> are usually much faster. If you are unsure what algorithm to pick, use <a href="#Catlab.CategoricalAlgebra.FinSets.SmartJoin"><code>SmartJoin</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin" href="#Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin"><code>Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Nested_loop_join">Nested-loop join</a> algorithm.</p><p>This is the naive algorithm for computing joins.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SmartJoin" href="#Catlab.CategoricalAlgebra.FinSets.SmartJoin"><code>Catlab.CategoricalAlgebra.FinSets.SmartJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-algorithm for joins that attempts to pick an appropriate algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SortMergeJoin" href="#Catlab.CategoricalAlgebra.FinSets.SortMergeJoin"><code>Catlab.CategoricalAlgebra.FinSets.SortMergeJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Sort-merge_join">Sort-merge join</a> algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SubFinSet" href="#Catlab.CategoricalAlgebra.FinSets.SubFinSet"><code>Catlab.CategoricalAlgebra.FinSets.SubFinSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Subset of a finite set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SubOpBoolean" href="#Catlab.CategoricalAlgebra.FinSets.SubOpBoolean"><code>Catlab.CategoricalAlgebra.FinSets.SubOpBoolean</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm to compute subobject operations using elementwise boolean logic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.TabularLimit" href="#Catlab.CategoricalAlgebra.FinSets.TabularLimit"><code>Catlab.CategoricalAlgebra.FinSets.TabularLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Limit of finite sets viewed as a table.</p><p>Any limit of finite sets can be canonically viewed as a table (<a href="#Catlab.CategoricalAlgebra.FinSets.TabularSet"><code>TabularSet</code></a>) whose columns are the legs of the limit cone and whose rows correspond to elements of the limit object. To construct this table from an already computed limit, call <code>TabularLimit(::AbstractLimit; ...)</code>. The column names of the table are given by the optional argument <code>names</code>.</p><p>In this tabular form, applying the universal property of the limit is trivial since it is just tupling. Thus, this representation can be useful when the original limit algorithm does not support efficient application of the universal property. On the other hand, this representation has the disadvantage of generally making the element type of the limit set more complicated.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.TabularSet" href="#Catlab.CategoricalAlgebra.FinSets.TabularSet"><code>Catlab.CategoricalAlgebra.FinSets.TabularSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Finite set whose elements are rows of a table.</p><p>The underlying table should be compliant with Tables.jl. For the sake of uniformity, the rows are provided as named tuples, which assumes that the table is not &quot;extremely wide&quot;. This should not be a major limitation in practice but see the Tables.jl documentation for further discussion.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.is_indexed-Tuple{SetFunction}" href="#Catlab.CategoricalAlgebra.FinSets.is_indexed-Tuple{SetFunction}"><code>Catlab.CategoricalAlgebra.FinSets.is_indexed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Whether the given function is indexed, i.e., supports efficient preimages.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.preimage-Tuple{Catlab.CategoricalAlgebra.Sets.IdentityFunction, Any}" href="#Catlab.CategoricalAlgebra.FinSets.preimage-Tuple{Catlab.CategoricalAlgebra.Sets.IdentityFunction, Any}"><code>Catlab.CategoricalAlgebra.FinSets.preimage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The preimage (inverse image) of the value y in the codomain.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations" href="#Catlab.CategoricalAlgebra.FinRelations"><code>Catlab.CategoricalAlgebra.FinRelations</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The category of finite sets and relations, and its skeleton.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.BoolRig" href="#Catlab.CategoricalAlgebra.FinRelations.BoolRig"><code>Catlab.CategoricalAlgebra.FinRelations.BoolRig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The rig of booleans.</p><p>This struct is needed because in base Julia, the product of booleans is another boolean, but the sum of booleans is coerced to an integer: <code>true + true == 2</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRel" href="#Catlab.CategoricalAlgebra.FinRelations.FinRel"><code>Catlab.CategoricalAlgebra.FinRelations.FinRel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object in the category of finite sets and relations.</p><p>See also: <a href="apis/@ref"><code>FinSet</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelation" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelation"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Binary relation between finite sets.</p><p>A morphism in the category of finite sets and relations. The relation can be represented implicitly by an arbitrary Julia function mapping pairs of elements to booleans or explicitly by a matrix (dense or sparse) taking values in the rig of booleans (<a href="#Catlab.CategoricalAlgebra.FinRelations.BoolRig"><code>BoolRig</code></a>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Relation in FinRel defined by a callable Julia object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Relation in FinRel represented by a boolean matrix.</p><p>Boolean matrices are also known as logical matrices or relation matrices.</p></div></section></article><h2 id="Free-Diagrams,-Limits,-and-Colimts"><a class="docs-heading-anchor" href="#Free-Diagrams,-Limits,-and-Colimts">Free Diagrams, Limits, and Colimts</a><a id="Free-Diagrams,-Limits,-and-Colimts-1"></a><a class="docs-heading-anchor-permalink" href="#Free-Diagrams,-Limits,-and-Colimts" title="Permalink"></a></h2><p>The following modules define free diagrams in an arbitrary category and specify limit and colimt cones over said diagrams. Thes constructions enjoy the fullest support for FinSet and are used below to define presheaf categories as C-Sets. The general idea of these functions is that you set up a limit computation by specifying a diagram and asking for a limit or colimit cone, which is returned as a struct containing the apex object and the leg morphisms. This cone structure can be queried using the functions <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}"><code>apex</code></a> and <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>legs</code></a>. Julia&#39;s multiple dispatch feature is heavily used to specialize limit and colimit computations for various diagram shapes like product/coproduct and equalizer/coequalizer. As a consumer of this API, it is highly recommended that you use multiple dispatch to specialize your code on the diagram shape whenever possible.</p><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams" href="#Catlab.CategoricalAlgebra.FreeDiagrams"><code>Catlab.CategoricalAlgebra.FreeDiagrams</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Free diagrams in a category.</p><p>A <a href="https://ncatlab.org/nlab/show/free+diagram">free diagram</a> in a category is a diagram whose shape is a free category. Examples include the empty diagram, pairs of objects, discrete diagrams, parallel pairs, composable pairs, and spans and cospans. Limits and colimits are most commonly taken over free diagrams.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A free diagram with a bipartite structure.</p><p>Such diagrams include most of the fixed shapes, such as spans, cospans, and parallel morphisms. They are also the generic shape of diagrams for limits and colimits arising from undirected wiring diagrams. For limits, the boxes correspond to vertices in <span>$V₁$</span> and the junctions to vertices in <span>$V₂$</span>. Colimits are dual.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram-Union{Tuple{Functor{&lt;:Category{Int64, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where Hom}}, Tuple{Hom}, Tuple{Ob}} where {Ob, Hom}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram-Union{Tuple{Functor{&lt;:Category{Int64, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where Hom}}, Tuple{Hom}, Tuple{Ob}} where {Ob, Hom}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert a free diagram to a bipartite free diagram.</p><p>Reduce a free diagram to a free bipartite diagram with the same limit (the default, <code>colimit=false</code>) or the same colimit (<code>colimit=true</code>). The reduction is essentially the same in both cases, except for the choice of where to put isolated vertices, where we follow the conventions described at <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}"><code>cone_objects</code></a> and <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}"><code>cocone_objects</code></a>. The resulting object is a bipartite free diagram equipped with maps from the vertices of the bipartite diagram to the vertices of the original diagram.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Composable morphisms in a category.</p><p>Composable morphisms are a sequence of morphisms in a category that form a path in the underlying graph of the category.</p><p>For the common special case of two morphisms, see <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair"><code>ComposablePair</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of composable morphisms in a category.</p><p><a href="https://ncatlab.org/nlab/show/composable+pair">Composable pairs</a> are a common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms"><code>ComposableMorphisms</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Cospan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Cospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Cospan of morphisms in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan"><code>Multicospan</code></a>. See also <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Span</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Discrete diagram: a diagram with no non-identity morphisms.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for free diagram of fixed shape.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multicospan of morphisms in a category.</p><p>A multicospan is like a <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Cospan</code></a> except that it may have a number of legs different than two. A limit of this shape is a pullback.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Multispan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multispan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Multispan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multispan of morphisms in a category.</p><p>A <a href="https://ncatlab.org/nlab/show/multispan">multispan</a> is like a <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Span</code></a> except that it may have a number of legs different than two. A colimit of this shape is a pushout.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parallel morphims in a category.</p><p><a href="https://ncatlab.org/nlab/show/parallel+morphisms">Parallel morphisms</a> are just morphisms with the same domain and codomain. A (co)limit of this shape is a (co)equalizer.</p><p>For the common special case of two morphisms, see <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair"><code>ParallelPair</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of parallel morphisms in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms"><code>ParallelMorphisms</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Span" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Span</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Span of morphims in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multispan"><code>Multispan</code></a>. See also <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Cospan</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.apex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apex of multispan or multicospan.</p><p>The apex of a multi(co)span is the object that is the (co)domain of all the <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>legs</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs-Tuple{Multispan, Any}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs-Tuple{Multispan, Any}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bundle together legs of a multi(co)span.</p><p>For example, calling <code>bundle_legs(span, SVector((1,2),(3,4)))</code> on a multispan with four legs gives a span whose left leg bundles legs 1 and 2 and whose right leg bundles legs 3 and 4. Note that in addition to bundling, this function can also permute legs and discard them.</p><p>The bundling is performed using the universal property of (co)products, which assumes that these (co)limits exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Objects in diagram that will have explicit legs in colimit cocone.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}"><code>cone_objects</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Objects in diagram that will have explicit legs in limit cone.</p><p>In category theory, it is common practice to elide legs of limit cones that can be computed from other legs, especially for diagrams of certain fixed shapes. For example, when it taking a pullback (the limit of a cospan), the limit object is often treated as having two projections, rather than three. This function encodes such conventions by listing the objects in the diagram that will have corresponding legs in the limit object created by Catlab.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}"><code>cocone_objects</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type" href="#Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type"><code>Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given a diagram in a category <span>$C$</span>, return Julia type of objects and morphisms in <span>$C$</span> as a tuple type of form <span>$Tuple{Ob,Hom}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.feet-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.feet-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.feet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Feet of multispan or multicospan.</p><p>The feet of a multispan are the codomains of the <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>legs</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.left-Tuple{Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.left-Tuple{Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.left</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Left leg of span or cospan.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.legs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Legs of multispan or multicospan.</p><p>The legs are the morphisms comprising the multi(co)span.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.right-Tuple{Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.right-Tuple{Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.right</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Right leg of span or cospan.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits" href="#Catlab.CategoricalAlgebra.Limits"><code>Catlab.CategoricalAlgebra.Limits</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Limits and colimits in a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.AbstractColimit" href="#Catlab.CategoricalAlgebra.Limits.AbstractColimit"><code>Catlab.CategoricalAlgebra.Limits.AbstractColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for colimit in a category.</p><p>The standard concrete subtype is <a href="#Catlab.CategoricalAlgebra.Limits.Colimit"><code>Colimit</code></a>, although for computational reasons certain categories may use different subtypes to include extra data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.AbstractLimit" href="#Catlab.CategoricalAlgebra.Limits.AbstractLimit"><code>Catlab.CategoricalAlgebra.Limits.AbstractLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for limit in a category.</p><p>The standard concrete subtype is <a href="#Catlab.CategoricalAlgebra.Limits.Limit"><code>Limit</code></a>, although for computational reasons certain categories may use different subtypes to include extra data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.Colimit" href="#Catlab.CategoricalAlgebra.Limits.Colimit"><code>Catlab.CategoricalAlgebra.Limits.Colimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Colimit in a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm" href="#Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm"><code>Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for computing colimits.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer" href="#Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer"><code>Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute pushout by composing a coproduct with a coequalizer.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer"><code>ComposeProductEqualizer</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer" href="#Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer"><code>Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute pullback by composing a product with an equalizer.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer"><code>ComposeCoproductCoequalizer</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.Limit" href="#Catlab.CategoricalAlgebra.Limits.Limit"><code>Catlab.CategoricalAlgebra.Limits.Limit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Limit in a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.LimitAlgorithm" href="#Catlab.CategoricalAlgebra.Limits.LimitAlgorithm"><code>Catlab.CategoricalAlgebra.Limits.LimitAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for computing limits.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.SpecializeColimit" href="#Catlab.CategoricalAlgebra.Limits.SpecializeColimit"><code>Catlab.CategoricalAlgebra.Limits.SpecializeColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-algorithm that reduces general colimits to common special cases.</p><p>Dual to <a href="#Catlab.CategoricalAlgebra.Limits.SpecializeLimit"><code>SpecializeLimit</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.SpecializeLimit" href="#Catlab.CategoricalAlgebra.Limits.SpecializeLimit"><code>Catlab.CategoricalAlgebra.Limits.SpecializeLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-algorithm that reduces general limits to common special cases.</p><p>Reduces limits of free diagrams that happen to be discrete to products. If this fails, fall back to the given algorithm (if any).</p><p>TODO: Reduce free diagrams that are (multi)cospans to (wide) pullbacks.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit" href="#Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit"><code>Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute a colimit by reducing the diagram to a free bipartite diagram.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit" href="#Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit"><code>Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute a limit by reducing the diagram to a free bipartite diagram.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.coimage-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.coimage-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.coimage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>https://en.wikipedia.org/wiki/Coimage</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.colimit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Colimit of a diagram.</p><p>To define colimits in a category with objects <code>Ob</code>, override the method <code>colimit(::FreeDiagram{Ob})</code> for general colimits or <code>colimit(::D)</code> with suitable type <code>D &lt;: FixedShapeFreeDiagram{Ob}</code> for colimits of specific shape, such as coproducts or coequalizers.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}"><code>limit</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.epi_mono-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.epi_mono-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.epi_mono</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The image and coimage are isomorphic. We get this isomorphism using univeral properties.</p><pre><code class="nohighlight hljs">  CoIm′ ╌╌&gt; I ↠ CoIm
    ┆ ⌟     |
    v       v
    I   ⟶  R ↩ Im
    |       ┆
    v    ⌜  v
    R ╌╌&gt; Im′</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.image-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.image-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.image</code></a> — <span class="docstring-category">Method</span></header><section><div><p>https://en.wikipedia.org/wiki/Image<em>(category</em>theory)#Second_definition</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.limit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Limit of a diagram.</p><p>To define limits in a category with objects <code>Ob</code>, override the method <code>limit(::FreeDiagram{Ob})</code> for general limits or <code>limit(::D)</code> with suitable type <code>D &lt;: FixedShapeFreeDiagram{Ob}</code> for limits of specific shape, such as products or equalizers.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}"><code>colimit</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.pullback-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.pullback-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.pullback</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pullback of a pair of morphisms with common codomain.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::Cospan{T})</code> and/or <code>limit(::Multicospan{T})</code> or, if you have already implemented products and equalizers, rely on the default implementation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.pushout-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.pushout-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.pushout</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pushout of a pair of morphisms with common domain.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::Span{T})</code> and/or <code>colimit(::Multispan{T})</code> or, if you have already implemented coproducts and coequalizers, rely on the default implementation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.coequalizer-Tuple{Any, Any}" href="#Catlab.Theories.coequalizer-Tuple{Any, Any}"><code>Catlab.Theories.coequalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coequalizer of morphisms with common domain and codomain.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::ParallelPair{T})</code> or <code>colimit(::ParallelMorphisms{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.copair-Tuple{Any, Any}" href="#Catlab.Theories.copair-Tuple{Any, Any}"><code>Catlab.Theories.copair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Copairing of morphisms: universal property of coproducts/pushouts.</p><p>To implement for coproducts of type <code>T</code>, define the method <code>universal(::BinaryCoproduct{T}, ::Cospan{T})</code> and/or <code>universal(::Coproduct{T}, ::Multicospan{T})</code> and similarly for pushouts.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.coproduct-Tuple{Any, Any}" href="#Catlab.Theories.coproduct-Tuple{Any, Any}"><code>Catlab.Theories.coproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coproduct of objects.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::ObjectPair{T})</code> and/or <code>colimit(::DiscreteDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.create-Tuple{T} where T" href="#Catlab.Theories.create-Tuple{T} where T"><code>Catlab.Theories.create</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unique morphism out of an initial object.</p><p>To implement for a type <code>T</code>, define the method <code>universal(::Initial{T}, ::SMulticospan{0,T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.delete-Tuple{T} where T" href="#Catlab.Theories.delete-Tuple{T} where T"><code>Catlab.Theories.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unique morphism into a terminal object.</p><p>To implement for a type <code>T</code>, define the method <code>universal(::Terminal{T}, ::SMultispan{0,T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.equalizer-Tuple{Any, Any}" href="#Catlab.Theories.equalizer-Tuple{Any, Any}"><code>Catlab.Theories.equalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Equalizer of morphisms with common domain and codomain.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::ParallelPair{T})</code> and/or <code>limit(::ParallelMorphisms{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.factorize-Tuple{Equalizer, Any}" href="#Catlab.Theories.factorize-Tuple{Equalizer, Any}"><code>Catlab.Theories.factorize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Factor morphism through (co)equalizer, via the universal property.</p><p>To implement for equalizers of type <code>T</code>, define the method <code>universal(::Equalizer{T}, ::SMultispan{1,T})</code>. For coequalizers of type <code>T</code>, define the method <code>universal(::Coequalizer{T}, ::SMulticospan{1,T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.initial-Tuple{Type}" href="#Catlab.Theories.initial-Tuple{Type}"><code>Catlab.Theories.initial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initial object.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::EmptyDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.pair-Tuple{Any, Any}" href="#Catlab.Theories.pair-Tuple{Any, Any}"><code>Catlab.Theories.pair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pairing of morphisms: universal property of products/pullbacks.</p><p>To implement for products of type <code>T</code>, define the method <code>universal(::BinaryProduct{T}, ::Span{T})</code> and/or <code>universal(::Product{T}, ::Multispan{T})</code> and similarly for pullbacks.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.product-Tuple{Any, Any}" href="#Catlab.Theories.product-Tuple{Any, Any}"><code>Catlab.Theories.product</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Product of objects.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::ObjectPair{T})</code> and/or <code>limit(::DiscreteDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.terminal-Tuple{Type}" href="#Catlab.Theories.terminal-Tuple{Type}"><code>Catlab.Theories.terminal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Terminal object.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::EmptyDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.universal" href="#Catlab.Theories.universal"><code>Catlab.Theories.universal</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Universal property of (co)limits.</p><p>Compute the morphism whose existence and uniqueness is guaranteed by the universal property of (co)limits.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}"><code>limit</code></a>, <a href="#Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}"><code>colimit</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define cartesian monoidal structure using limits.</p><p>Implements an instance of <a href="../theories/#Catlab.Theories.ThCartesianCategory"><code>ThCartesianCategory</code></a> assuming that finite products have been implemented following the limits interface.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define cocartesian monoidal structure using colimits.</p><p>Implements an instance of <a href="../theories/#Catlab.Theories.ThCocartesianCategory"><code>ThCocartesianCategory</code></a> assuming that finite coproducts have been implemented following the colimits interface.</p></div></section></article><h2 id="Categories"><a class="docs-heading-anchor" href="#Categories">Categories</a><a id="Categories-1"></a><a class="docs-heading-anchor-permalink" href="#Categories" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories" href="#Catlab.CategoricalAlgebra.Categories"><code>Catlab.CategoricalAlgebra.Categories</code></a> — <span class="docstring-category">Module</span></header><section><div><p>2-category of categories, functors, and natural transformations.</p><p>Categories in mathematics appear in the large, often as categories of sets with extra structure, and in the small, as algebraic structures that generalize groups, monoids, preorders, and graphs. This division manifests in Catlab as well. Large categories (in spirit, if not in the <a href="https://ncatlab.org/nlab/show/large+category">technical sense</a>) occur throughout Catlab as <code>@instance</code>s of the theory of categories. For computational reasons, small categories are usually presented by generators and relations.</p><p>This module provides a minimal interface to accomodate both situations. Category instances are supported through the wrapper type <a href="#Catlab.CategoricalAlgebra.Categories.TypeCat"><code>TypeCat</code></a>. Finitely presented categories are provided by another module, <a href="apis/@ref"><code>FinCats</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Cat" href="#Catlab.CategoricalAlgebra.Categories.Cat"><code>Catlab.CategoricalAlgebra.Categories.Cat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Alias for <a href="#Catlab.CategoricalAlgebra.Categories.Category"><code>Category</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.CatSize" href="#Catlab.CategoricalAlgebra.Categories.CatSize"><code>Catlab.CategoricalAlgebra.Categories.CatSize</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Size of a category, used for dispatch and subtyping purposes.</p><p>A <a href="#Catlab.CategoricalAlgebra.Categories.Category"><code>Category</code></a> type having a particular <code>CatSize</code> means that categories of that type are <em>at most</em> that large.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Category" href="#Catlab.CategoricalAlgebra.Categories.Category"><code>Catlab.CategoricalAlgebra.Categories.Category</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for a category.</p><p>The objects and morphisms in the category have Julia types <code>Ob</code> and <code>Hom</code>, respectively. Note that these types do <em>not</em> necessarily form an <code>@instance</code> of the theory of categories, as they may not meaningfully form a category outside the context of this object. For example, a finite category regarded as a reflexive graph with a composition operation might have type <code>Cat{Int,Int}</code>, where the objects and morphisms are numerical identifiers for vertices and edges in the graph.</p><p>The basic operations available in any category are: <a href="#Catlab.Schemas.dom-Tuple{Category, Any}"><code>dom</code></a>, <a href="#Catlab.Schemas.codom-Tuple{Category, Any}"><code>codom</code></a>, <a href="#Catlab.Theories.id-Tuple{Category, Any}"><code>id</code></a>, <a href="#Catlab.Theories.compose-Tuple{Category, Vararg{Any}}"><code>compose</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.CompositeFunctor" href="#Catlab.CategoricalAlgebra.Categories.CompositeFunctor"><code>Catlab.CategoricalAlgebra.Categories.CompositeFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Composite of functors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Functor" href="#Catlab.CategoricalAlgebra.Categories.Functor"><code>Catlab.CategoricalAlgebra.Categories.Functor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for a functor between categories.</p><p>A functor has a domain and a codomain (<a href="#Catlab.Schemas.dom-Tuple{Category, Any}"><code>dom</code></a> and <a href="#Catlab.Schemas.codom-Tuple{Category, Any}"><code>codom</code></a>), which are categories, and object and morphism maps, which can be evaluated using <a href="#Catlab.CategoricalAlgebra.Categories.ob_map-Tuple{Functor, Any}"><code>ob_map</code></a> and <a href="#Catlab.CategoricalAlgebra.Categories.hom_map-Tuple{Functor, Any}"><code>hom_map</code></a>. The functor object can also be called directly when the objects and morphisms have distinct Julia types. This is sometimes but not always the case (see <a href="#Catlab.CategoricalAlgebra.Categories.Category"><code>Category</code></a>), so when writing generic code one should prefer the <code>ob_map</code> and <code>hom_map</code> functions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.FunctorCallable" href="#Catlab.CategoricalAlgebra.Categories.FunctorCallable"><code>Catlab.CategoricalAlgebra.Categories.FunctorCallable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Functor defined by two Julia callables, an object map and a morphism map.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.IdentityFunctor" href="#Catlab.CategoricalAlgebra.Categories.IdentityFunctor"><code>Catlab.CategoricalAlgebra.Categories.IdentityFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Identity functor on a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.LargeCatSize" href="#Catlab.CategoricalAlgebra.Categories.LargeCatSize"><code>Catlab.CategoricalAlgebra.Categories.LargeCatSize</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Size of a large category, such as Set.</p><p>To the extent that they form a category, we regard Julia types and functions (<a href="#Catlab.CategoricalAlgebra.Categories.TypeCat"><code>TypeCat</code></a>) as forming a large category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.OppositeCat" href="#Catlab.CategoricalAlgebra.Categories.OppositeCat"><code>Catlab.CategoricalAlgebra.Categories.OppositeCat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Opposite category, where morphism are reversed.</p><p>Call <code>op(::Cat)</code> instead of directly instantiating this type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.OppositeFunctor" href="#Catlab.CategoricalAlgebra.Categories.OppositeFunctor"><code>Catlab.CategoricalAlgebra.Categories.OppositeFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Opposite functor, given by the same mapping between opposite categories.</p><p>Call <code>op(::Functor)</code> instead of directly instantiating this type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Transformation" href="#Catlab.CategoricalAlgebra.Categories.Transformation"><code>Catlab.CategoricalAlgebra.Categories.Transformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for a natural transformation between functors.</p><p>A natural transformation <span>$α: F ⇒ G$</span> has a domain <span>$F$</span> and codomain <span>$G$</span> (<a href="#Catlab.Schemas.dom-Tuple{Category, Any}"><code>dom</code></a> and <a href="#Catlab.Schemas.codom-Tuple{Category, Any}"><code>codom</code></a>), which are functors <span>$F,G: C → D$</span> having the same domain <span>$C$</span> and codomain <span>$D$</span>. The transformation consists of a component <span>$αₓ: Fx → Gx$</span> in <span>$D$</span> for each object <span>$x ∈ C$</span>, accessible using <a href="#Catlab.CategoricalAlgebra.Categories.component"><code>component</code></a> or indexing notation (<code>Base.getindex</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.TypeCat" href="#Catlab.CategoricalAlgebra.Categories.TypeCat"><code>Catlab.CategoricalAlgebra.Categories.TypeCat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of Julia types regarded as a category.</p><p>The Julia types should form an <code>@instance</code> of the theory of categories (<code>Theories.Category</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.co" href="#Catlab.CategoricalAlgebra.Categories.co"><code>Catlab.CategoricalAlgebra.Categories.co</code></a> — <span class="docstring-category">Function</span></header><section><div><p>2-cell dual of a 2-category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.codom_ob-Tuple{Transformation}" href="#Catlab.CategoricalAlgebra.Categories.codom_ob-Tuple{Transformation}"><code>Catlab.CategoricalAlgebra.Categories.codom_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Codomain object of natural transformation.</p><p>Given <span>$α: F ⇒ G: C → D$</span>, this function returns <span>$D$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.component" href="#Catlab.CategoricalAlgebra.Categories.component"><code>Catlab.CategoricalAlgebra.Categories.component</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Component of natural transformation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.dom_ob-Tuple{Transformation}" href="#Catlab.CategoricalAlgebra.Categories.dom_ob-Tuple{Transformation}"><code>Catlab.CategoricalAlgebra.Categories.dom_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Domain object of natural transformation.</p><p>Given <span>$α: F ⇒ G: C → D$</span>, this function returns <span>$C$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.hom_map-Tuple{Functor, Any}" href="#Catlab.CategoricalAlgebra.Categories.hom_map-Tuple{Functor, Any}"><code>Catlab.CategoricalAlgebra.Categories.hom_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate functor on morphism.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.is_hom_equal-Tuple{Category, Any, Any}" href="#Catlab.CategoricalAlgebra.Categories.is_hom_equal-Tuple{Category, Any, Any}"><code>Catlab.CategoricalAlgebra.Categories.is_hom_equal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Are two morphisms in a category equal?</p><p>By default, just checks for equality of Julia objects using <span>$==$</span>. In some categories, checking equality of morphisms may involve nontrivial reasoning.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.ob_map-Tuple{Functor, Any}" href="#Catlab.CategoricalAlgebra.Categories.ob_map-Tuple{Functor, Any}"><code>Catlab.CategoricalAlgebra.Categories.ob_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate functor on object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.op-Tuple{Category}" href="#Catlab.CategoricalAlgebra.Categories.op-Tuple{Category}"><code>Catlab.CategoricalAlgebra.Categories.op</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Oppositization 2-functor.</p><p>The oppositization endo-2-functor on Cat, sending a category to its opposite, is covariant on objects and morphisms and contravariant on 2-morphisms, i.e., is a 2-functor <span>$op: Catᶜᵒ → Cat$</span>. For more explanation, see the <a href="https://ncatlab.org/nlab/show/opposite+category">nLab</a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Schemas.codom-Tuple{Category, Any}" href="#Catlab.Schemas.codom-Tuple{Category, Any}"><code>Catlab.Schemas.codom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Codomain of morphism in category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Schemas.dom-Tuple{Category, Any}" href="#Catlab.Schemas.dom-Tuple{Category, Any}"><code>Catlab.Schemas.dom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Domain of morphism in category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Schemas.hom" href="#Catlab.Schemas.hom"><code>Catlab.Schemas.hom</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Coerce or look up morphism in category.</p><p>See also: <a href="#Catlab.Schemas.ob"><code>ob</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Schemas.ob" href="#Catlab.Schemas.ob"><code>Catlab.Schemas.ob</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Coerce or look up object in category.</p><p>Converts the input to an object in the category, which should be of type <code>Ob</code> in a category of type <code>Cat{Ob,Hom}</code>. How this works depends on the category, but a common case is to look up objects, which might be integers or GAT expressions, by their human-readable name, usually a symbol.</p><p>See also: <a href="#Catlab.Schemas.hom"><code>hom</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.compose-Tuple{Category, Vararg{Any}}" href="#Catlab.Theories.compose-Tuple{Category, Vararg{Any}}"><code>Catlab.Theories.compose</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compose morphisms in a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.id-Tuple{Category, Any}" href="#Catlab.Theories.id-Tuple{Category, Any}"><code>Catlab.Theories.id</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Identity morphism on object in category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats" href="#Catlab.CategoricalAlgebra.FinCats"><code>Catlab.CategoricalAlgebra.FinCats</code></a> — <span class="docstring-category">Module</span></header><section><div><p>2-category of finitely presented categories.</p><p>This module is for the 2-category <strong>Cat</strong> what the module <a href="apis/@ref">`FinSets</a> is for the category <strong>Set</strong>: a finitary, combinatorial setting where explicit calculations can be carried out. We emphasize that the prefix <code>Fin</code> means &quot;finitely presented,&quot; not &quot;finite,&quot; as finite categories are too restrictive a notion for many purposes. For example, the free category on a graph is finite if and only if the graph is DAG, which is a fairly special condition. This usage of <code>Fin</code> is also consistent with <code>FinSet</code> because for sets, being finite and being finitely presented are equivalent.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCat" href="#Catlab.CategoricalAlgebra.FinCats.FinCat"><code>Catlab.CategoricalAlgebra.FinCats.FinCat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A finitely presented (but not necessarily finite!) category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatGraph" href="#Catlab.CategoricalAlgebra.FinCats.FinCatGraph"><code>Catlab.CategoricalAlgebra.FinCats.FinCatGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for category backed by finite generating graph.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq" href="#Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq"><code>Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Category presented by a finite graph together with path equations.</p><p>The objects of the category are vertices in the graph and the morphisms are paths, quotiented by the congruence relation generated by the path equations. See (Spivak, 2014, <em>Category theory for the sciences</em>, §4.5).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph" href="#Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph"><code>Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for category whose morphisms are paths in a graph.</p><p>(Or equivalence classes of paths in a graph, but we compute with</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatPresentation" href="#Catlab.CategoricalAlgebra.FinCats.FinCatPresentation"><code>Catlab.CategoricalAlgebra.FinCats.FinCatPresentation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Category defined by a <code>Presentation</code> object.</p><p>The presentation type can, of course, be a category (<code>Theories.Category</code>). It can also be a schema (<code>Theories.Schema</code>). In this case, the schema&#39;s objects and attribute types are regarded as the category&#39;s objects and the schema&#39;s morphisms, attributes, and attribute types as the category&#39;s morphisms (where the attribute types are identity morphisms). When the schema is formalized as a profunctor whose codomain category is discrete, this amounts to taking the collage of the profunctor.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatSize" href="#Catlab.CategoricalAlgebra.FinCats.FinCatSize"><code>Catlab.CategoricalAlgebra.FinCats.FinCatSize</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Size of a finitely presented category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinDomFunctor" href="#Catlab.CategoricalAlgebra.FinCats.FinDomFunctor"><code>Catlab.CategoricalAlgebra.FinCats.FinDomFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A functor out of a finitely presented category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap" href="#Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap"><code>Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Functor out of a finitely presented category given by explicit mappings.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinFunctor" href="#Catlab.CategoricalAlgebra.FinCats.FinFunctor"><code>Catlab.CategoricalAlgebra.FinCats.FinFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A functor between finitely presented categories.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinTransformation" href="#Catlab.CategoricalAlgebra.FinCats.FinTransformation"><code>Catlab.CategoricalAlgebra.FinCats.FinTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A natural transformation whose domain category is finitely generated.</p><p>This type is for natural transformations <span>$α: F ⇒ G: C → D$</span> such that the domain category <span>$C$</span> is finitely generated. Such a natural transformation is given by a finite amount of data (one morphism in <span>$D$</span> for each generating object of <span>$C$</span>) and its naturality is verified by finitely many equations (one equation for each generating morphism of <span>$C$</span>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinTransformationMap" href="#Catlab.CategoricalAlgebra.FinCats.FinTransformationMap"><code>Catlab.CategoricalAlgebra.FinCats.FinTransformationMap</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Natural transformation with components given by explicit mapping.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FreeCatGraph" href="#Catlab.CategoricalAlgebra.FinCats.FreeCatGraph"><code>Catlab.CategoricalAlgebra.FinCats.FreeCatGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Free category generated by a finite graph.</p><p>The objects of the free category are vertices in the graph and the morphisms are (possibly empty) paths.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.Path" href="#Catlab.CategoricalAlgebra.FinCats.Path"><code>Catlab.CategoricalAlgebra.FinCats.Path</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Path in a graph.</p><p>The path is allowed to be empty but always has definite start and end points (source and target vertices).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.collect_hom-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}" href="#Catlab.CategoricalAlgebra.FinCats.collect_hom-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>Catlab.CategoricalAlgebra.FinCats.collect_hom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Collect assignments of functor&#39;s morphism map as a vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.collect_ob-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}" href="#Catlab.CategoricalAlgebra.FinCats.collect_ob-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>Catlab.CategoricalAlgebra.FinCats.collect_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Collect assignments of functor&#39;s object map as a vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.components-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}" href="#Catlab.CategoricalAlgebra.FinCats.components-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}"><code>Catlab.CategoricalAlgebra.FinCats.components</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Components of a natural transformation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.force" href="#Catlab.CategoricalAlgebra.FinCats.force"><code>Catlab.CategoricalAlgebra.FinCats.force</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Force evaluation of lazily defined function or functor.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.graph-Tuple{FinCatGraph}" href="#Catlab.CategoricalAlgebra.FinCats.graph-Tuple{FinCatGraph}"><code>Catlab.CategoricalAlgebra.FinCats.graph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generating graph for a finitely presented category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.hom_generator" href="#Catlab.CategoricalAlgebra.FinCats.hom_generator"><code>Catlab.CategoricalAlgebra.FinCats.hom_generator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Coerce or look up morphism generator in a finitely presented category.</p><p>Since morphism generators often have a different data type than morphisms (e.g., in a free category on a graph, the morphism generators are edges and the morphisms are paths), the return type of this function is generally different than that of <a href="#Catlab.Schemas.hom"><code>hom</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.hom_generator_name" href="#Catlab.CategoricalAlgebra.FinCats.hom_generator_name"><code>Catlab.CategoricalAlgebra.FinCats.hom_generator_name</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Name of morphism generator, if any.</p><p>When morphism generators have names, this function is a one-sided inverse to <a href="#Catlab.CategoricalAlgebra.FinCats.hom_generator"><code>hom_generator</code></a>. See also: <a href="#Catlab.CategoricalAlgebra.FinCats.ob_generator_name"><code>ob_generator_name</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.hom_generators" href="#Catlab.CategoricalAlgebra.FinCats.hom_generators"><code>Catlab.CategoricalAlgebra.FinCats.hom_generators</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Morphism generators of finitely presented category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_discrete-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.FinCats.is_discrete-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.FinCats.is_discrete</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the category discrete?</p><p>A category is <em>discrete</em> if it is has no non-identity morphisms.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_free-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.FinCats.is_free-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.FinCats.is_free</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the category freely generated?</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_functorial-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}" href="#Catlab.CategoricalAlgebra.FinCats.is_functorial-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>Catlab.CategoricalAlgebra.FinCats.is_functorial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the purported functor on a presented category functorial?</p><p>This function checks that functor preserves domains and codomains. When <code>check_equations</code> is <code>true</code> (the default), it also checks that the functor preserves all equations in the domain category. Note that in some cases this may not be possible.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}"><code>is_natural</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_initial-Tuple{Functor{Dom, Codom} where {Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}}" href="#Catlab.CategoricalAlgebra.FinCats.is_initial-Tuple{Functor{Dom, Codom} where {Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}}"><code>Catlab.CategoricalAlgebra.FinCats.is_initial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Dual to a <a href="https://ncatlab.org/nlab/show/final+functor">final functor</a>, an <em>initial functor</em> is one for which pulling back diagrams along it does not change the limits of these diagrams.</p><p>This amounts to checking, for a functor C-&gt;D, that, for every object d in Ob(D), the comma category (F/d) is connected.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}" href="#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}"><code>Catlab.CategoricalAlgebra.FinCats.is_natural</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the transformation between <code>FinDomFunctors</code> a natural transformation?</p><p>This function uses the fact that to check whether a transformation is natural, it suffices to check the naturality equations on a generating set of morphisms of the domain category. In some cases, checking the equations may be expensive or impossible. When the keyword argument <code>check_equations</code> is <code>false</code>, only the domains and codomains of the components are checked.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FinCats.is_functorial-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>is_functorial</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.ob_generator" href="#Catlab.CategoricalAlgebra.FinCats.ob_generator"><code>Catlab.CategoricalAlgebra.FinCats.ob_generator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Coerce or look up object generator in a finitely presented category.</p><p>Because object generators usually coincide with objects, the default method for <a href="#Catlab.Schemas.ob"><code>ob</code></a> in finitely presented categories simply calls this function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.ob_generator_name" href="#Catlab.CategoricalAlgebra.FinCats.ob_generator_name"><code>Catlab.CategoricalAlgebra.FinCats.ob_generator_name</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Name of object generator, if any.</p><p>When object generators have names, this function is a one-sided inverse to <a href="#Catlab.CategoricalAlgebra.FinCats.ob_generator"><code>ob_generator</code></a> in that <code>ob_generator(C, ob_generator_name(C, x)) == x</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.ob_generators" href="#Catlab.CategoricalAlgebra.FinCats.ob_generators"><code>Catlab.CategoricalAlgebra.FinCats.ob_generators</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Object generators of finitely presented category.</p><p>The object generators of finite presented category are almost always the same as the objects. In principle, however, it is possible to have equations between objects, so that there are fewer objects than object generators.</p></div></section></article><h2 id="Acsets"><a class="docs-heading-anchor" href="#Acsets">Acsets</a><a id="Acsets-1"></a><a class="docs-heading-anchor-permalink" href="#Acsets" title="Permalink"></a></h2><h3 id="Overview-and-Theory"><a class="docs-heading-anchor" href="#Overview-and-Theory">Overview and Theory</a><a id="Overview-and-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-and-Theory" title="Permalink"></a></h3><p>For an in depth look into the theory behind acsets, we refer the reader to <a href="https://arxiv.org/abs/2106.04703">our paper</a> on the subject, which also gives some sense as to how the implementation works. Here, we give a brief tutorial before the the API documentation.</p><p>The most essential part of the acset machinery is the schema. The schema <em>parameterizes</em> the acset: each schema corresponds to a different type of acset. Schemas consist of four parts.</p><ul><li>Objects <span>$X,Y$</span> (<code>(X,Y,Z)::Ob</code>)</li><li>Homomorphisms <span>$f \colon X \to Y$</span> (<code>f :: Hom(X,Y)</code>), which go from objects to objects</li><li>Attribute types <span>$\mathtt{T}$</span> (<code>T :: AttrType</code>)</li><li>Attributes <span>$a \colon X \to \mathtt{T}$</span> (<code>a :: Attr(X,T)</code>), which go from objects to data types</li></ul><p>For those with a categorical background, a schema is a presentation of a category <span>$|S|$</span> along with a functor <span>$S$</span> from <span>$|S|$</span> to the arrow category <span>$0 \to 1$</span>, such that <span>$S^{-1}(1)$</span> is discrete.</p><p>An acset <span>$F$</span> on a schema consists of...</p><ul><li>a set <span>$F(X)$</span> of &quot;primary keys&quot; for each object</li><li>a function <span>$F(f) \colon F(X) \to F(Y)$</span> for each morphism</li><li>a Julia data type <span>$F(\mathtt{T})$</span> for each data type <span>$\mathtt{T}$</span></li><li>a function <span>$F(a) \colon F(X) \to F(\mathtt{T})$</span> for each attribute <span>$a$</span>.</li></ul><p>For those with a categorical background, an acset on a schema <span>$S$</span> consists of a functor from <span>$S$</span> to <span>$\mathsf{Set}$</span>, such that objects in <span>$S^{-1}(0)$</span> map to finite sets, and objects in <span>$S^{-1}(1)$</span> map to sets that represent types. For any particular functor <span>$K \colon S^{-1}(1) \to \mathsf{Set}$</span>, we can also take the category of acsets that restrict to this map on <span>$S^{-1}$</span>.</p><p>We can also add equations to this presentation, but we currently do nothing with those equations in the implementation; they mostly serve as documentation.</p><p>We will now give an example of how this all works in practice.</p><pre><code class="language-julia hljs">using Catlab, Catlab.CategoricalAlgebra

# Write down the schema for a weighted graph
@present SchWeightedGraph(FreeSchema) begin
  V::Ob
  E::Ob
  src::Hom(E,V)
  tgt::Hom(E,V)
  T::AttrType
  weight::Attr(E,T)
end

# Construct the type used to store acsets on the previous schema
# We *index* src and tgt, which means that we store not only
# the forwards map, but also the backwards map.
@acset_type WeightedGraph(SchWeightedGraph, index=[:src,:tgt])

# Construct a weighted graph, with floats as edge weights
g = @acset WeightedGraph{Float64} begin
  V = 4
  E = 5
  src = [1,1,1,2,3]
  tgt = [2,3,4,4,4]
  weight = [7.2, 9.3, 9.4, 0.1, 42.0]
end</code></pre><div class="c-set">
<span class="c-set-summary">Main.__atexample__356.WeightedGraph{Float64} with elements V = 1:4, E = 1:5</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowNumber" style = "font-weight: bold; text-align: right;">E</th>
      <th style = "text-align: right;">src</th>
      <th style = "text-align: right;">tgt</th>
      <th style = "text-align: right;">weight</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">7.2</td>
    </tr>
    <tr>
      <td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">9.3</td>
    </tr>
    <tr>
      <td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">9.4</td>
    </tr>
    <tr>
      <td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">0.1</td>
    </tr>
    <tr>
      <td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">42.0</td>
    </tr>
  </tbody>
</table>
</div>
<h3 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h3><p>The mathematical abstraction of an acset can of course be implemented in many different ways. Currently, there are three implementations of acsets in Catlab, which share a great deal of code.</p><p>These implementations can be split into two categories.</p><p>The first category is <strong>static acset types</strong>. In this implementation, different schemas correspond to different Julia types. Methods on these Julia types are then custom-generated for the schema, using <a href="https://github.com/AlgebraicJulia/CompTime.jl">CompTime.jl</a>.</p><p>Under this category, there are two classes of static acset types. The first class is acset types that are generated using the <code>@acset_type</code> macro. These acset types are custom-derived structs. The advantage of this is that the structs have names like <code>Graph</code> or <code>WiringDiagram</code> that are printed out in error messages. The disadvantage is that if you are taking in schemas at runtime, you have to <code>eval</code> code in order to use them.</p><p>Here is an example of using <code>@acset_type</code></p><pre><code class="language-julia hljs">@acset_type WeightedGraph(SchWeightedGraph, index=[:src,:tgt])
g = WeightedGraph()</code></pre><p>The second class is <code>AnonACSet</code>s. Like acset types derived from <code>@acset_type</code>, these contain the schema in their type. However, they also contain the type of their fields in their types, so the types printed out in error messages are long and ugly. The advantage of these is that they can be used in situations where the schema is passed in at runtime, and they don&#39;t require using <code>eval</code> to create a new acset type.</p><p>Here is an example of using <code>AnonACSet</code></p><pre><code class="language-julia hljs">const WeightedGraph = AnonACSetType(SchWeightedGraph, index=[:src,:tgt])
g = WeightedGraph()</code></pre><p>The second category is <strong>dynamic acset types</strong>. Currently, there is just one type that falls under this category: <code>DynamicACSet</code>. This type has a <strong>field</strong> for the schema, and no code-generation is done for operations on acsets of this type. This means that if the schema is large compared to the data, this type will often be faster than the static acsets.</p><p>However, dynamics acsets are a new addition to Catlab, and much of the machinery of limits, colimits, and other high-level acset constructions assumes that the schema of an acset can be derived from the type. Thus, more work will have to be done before dynamic acsets become a drop-in replacement for static acsets.</p><p>Here is an example of using a dynamic acset</p><pre><code class="language-julia hljs">g = DynamicACSet(&quot;WeightedGraph&quot;, SchWeightedGraph; index=[:src,:tgt])</code></pre><pre><code class="language- hljs">Modules = [
  CategoricalAlgebra.CSets,
  CategoricalAlgebra.StructuredCospans,
  CategoricalAlgebra.ACSetInterface,
  CategoricalAlgebra.ACSetColumns,
  CategoricalAlgebra.CSetDataStructures
]
Private = false</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theories/">« Standard library of theories</a><a class="docs-footer-nextpage" href="../graphs/">Graphs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 10 October 2022 22:15">Monday 10 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
