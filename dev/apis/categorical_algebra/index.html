<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Categorical algebra · Catlab.jl</title><meta name="title" content="Categorical algebra · Catlab.jl"/><meta property="og:title" content="Categorical algebra · Catlab.jl"/><meta property="twitter:title" content="Categorical algebra · Catlab.jl"/><meta name="description" content="Documentation for Catlab.jl."/><meta property="og:description" content="Documentation for Catlab.jl."/><meta property="twitter:description" content="Documentation for Catlab.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catlab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Seven Sketches in Compositionality</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/sketches/partitions/">Partitions</a></li><li><a class="tocitem" href="../../generated/sketches/preorders/">Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/meets/">Meets in Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/smc/">Symmetric Monoidal Categories</a></li><li><a class="tocitem" href="../../generated/sketches/cat_elements/">The Category of Elements</a></li><li><a class="tocitem" href="../../generated/sketches/sheaves/">Basic Sheaf Constructions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphs/graphs/">The Category of Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/graphs_label/">Labeled Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/subgraphs/">Algebra of subgraphs</a></li></ul></li><li><span class="tocitem">Categorical Algebra</span></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Wiring Diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/wd_cset/">Wiring Diagrams as Attributed C-Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/graphviz_graphs/">Drawing graphs in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li class="is-active"><a class="tocitem" href>Categorical algebra</a><ul class="internal"><li><a class="tocitem" href="#Sets-and-Relations"><span>Sets and Relations</span></a></li><li><a class="tocitem" href="#Free-Diagrams,-Limits,-and-Colimits"><span>Free Diagrams, Limits, and Colimits</span></a></li><li><a class="tocitem" href="#Categories"><span>Categories</span></a></li><li><a class="tocitem" href="#Acsets"><span>Acsets</span></a></li></ul></li><li><a class="tocitem" href="../graphs/">Graphs</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li><a class="tocitem" href="../programs/">Programs</a></li><li><a class="tocitem" href="../sheaves/">Sheaves</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../devdocs/release/">Release Notes</a></li><li><a class="tocitem" href="../../devdocs/style/">Style Guide for AlgebraicJulia</a></li><li><a class="tocitem" href="../../generated/peg-parser/dsl_peg_tutorial/">Domain Specific Parsing Expression Grammars</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Categorical algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Categorical algebra</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/Catlab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/main/docs/src/apis/categorical_algebra.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="categorical_algebra"><a class="docs-heading-anchor" href="#categorical_algebra">Categorical algebra</a><a id="categorical_algebra-1"></a><a class="docs-heading-anchor-permalink" href="#categorical_algebra" title="Permalink"></a></h1><h2 id="Sets-and-Relations"><a class="docs-heading-anchor" href="#Sets-and-Relations">Sets and Relations</a><a id="Sets-and-Relations-1"></a><a class="docs-heading-anchor-permalink" href="#Sets-and-Relations" title="Permalink"></a></h2><p>The following APIs implement FinSet, the category of Finite Sets (actually the skeleton of FinSet). The objects of this category are natural numbers where <code>n</code> represents a set with <code>n</code> elements. The morphisms are functions between such sets. We use the skeleton of FinSet in order to ensure that all sets are finite and morphisms can be stored using lists of integers. Finite relations are built out of FinSet and can be used to do some relational algebra.</p><h2 id="Free-Diagrams,-Limits,-and-Colimits"><a class="docs-heading-anchor" href="#Free-Diagrams,-Limits,-and-Colimits">Free Diagrams, Limits, and Colimits</a><a id="Free-Diagrams,-Limits,-and-Colimits-1"></a><a class="docs-heading-anchor-permalink" href="#Free-Diagrams,-Limits,-and-Colimits" title="Permalink"></a></h2><p>The following modules define free diagrams in an arbitrary category and specify limit and colimit cones over said diagrams. Thes constructions enjoy the fullest support for FinSet and are used below to define presheaf categories as C-Sets. The general idea of these functions is that you set up a limit computation by specifying a diagram and asking for a limit or colimit cone, which is returned as a struct containing the apex object and the leg morphisms. This cone structure can be queried using the functions <a href="@ref"><code>apex</code></a> and <a href="@ref"><code>legs</code></a>. Julia&#39;s multiple dispatch feature is heavily used to specialize limit and colimit computations for various diagram shapes like product/coproduct and equalizer/coequalizer. As a consumer of this API, it is highly recommended that you use multiple dispatch to specialize your code on the diagram shape whenever possible.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FreeDiagrams.FreeDiagram" href="#Catlab.CategoricalAlgebra.Cats.FreeDiagrams.FreeDiagram"><code>Catlab.CategoricalAlgebra.Cats.FreeDiagrams.FreeDiagram</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">A collection of objects and morphisms</code></pre><p>Some diagrams can be interpreted as (co)limit diagrams. These ought implement a (co)cone_objects method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/v0.2.1/src/syntax/TheoryInterface.jl#L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cocone_objects" href="#Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cocone_objects"><code>Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cocone_objects</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Not every FreeDiagram can be thought of as having cocone_objects </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/freediagrams/FreeDiagrams.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cone_objects" href="#Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cone_objects"><code>Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cone_objects</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Not every FreeDiagram can be thought of as having cone_objects </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/freediagrams/FreeDiagrams.jl#L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Functors.fmap-Tuple{FreeDiagram, Any, Any, Type, Type}" href="#Catlab.CategoricalAlgebra.Cats.Functors.fmap-Tuple{FreeDiagram, Any, Any, Type, Type}"><code>Catlab.CategoricalAlgebra.Cats.Functors.fmap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Informal requirement of FreeDiagram implementations:  <code>fmap</code> takes an function on objects and a function on homs and replaces the  obs and homs of FreeDiagram while preserving the edges and vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/freediagrams/FreeDiagrams.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.LimitsColimits.bundle_legs-Tuple{Multispan, Any, Any}" href="#Catlab.CategoricalAlgebra.Cats.LimitsColimits.bundle_legs-Tuple{Multispan, Any, Any}"><code>Catlab.CategoricalAlgebra.Cats.LimitsColimits.bundle_legs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Bundle together legs of a multi(co)span.</p><p>For example, calling <code>bundle_legs(span, SVector((1,2),(3,4)))</code> on a multispan with four legs gives a span whose left leg bundles legs 1 and 2 and whose right leg bundles legs 3 and 4. Note that in addition to bundling, this function can also permute legs and discard them.</p><p>The bundling is performed using the universal property of (co)products, which assumes that these (co)limits exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/limits_colimits/LimitsColimits.jl#L22-L32">source</a></section></article><h2 id="Categories"><a class="docs-heading-anchor" href="#Categories">Categories</a><a id="Categories-1"></a><a class="docs-heading-anchor-permalink" href="#Categories" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories.##1176" href="#Catlab.CategoricalAlgebra.Cats.Categories.##1176"><code>Catlab.CategoricalAlgebra.Cats.Categories.##1176</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A category may have ob and hom sets more specific than Julia types, so we  extend the interface to require explicitly providing these sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/categories/Categories.jl#L16-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories.##1177" href="#Catlab.CategoricalAlgebra.Cats.Categories.##1177"><code>Catlab.CategoricalAlgebra.Cats.Categories.##1177</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A (possibly) large category with ob/hom given by SetObs with element types Ob/Hom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/categories/Categories.jl#L26-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories.##1181" href="#Catlab.CategoricalAlgebra.Cats.Categories.##1181"><code>Catlab.CategoricalAlgebra.Cats.Categories.##1181</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A category with a decision procedure for telling whether a given morphism is a  monic and/or an epic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/categories/Categories.jl#L72-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories.##1188" href="#Catlab.CategoricalAlgebra.Cats.Categories.##1188"><code>Catlab.CategoricalAlgebra.Cats.Categories.##1188</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A concrete category is a category with a faithful functor into Set.</p><p>Faithfulness means is a unique Hom (if any) lying over a given function in Set, given a choice of domain and codomain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/categories/Categories.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories.Cat" href="#Catlab.CategoricalAlgebra.Cats.Categories.Cat"><code>Catlab.CategoricalAlgebra.Cats.Categories.Cat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Alias for <a href="#Catlab.CategoricalAlgebra.Cats.Categories.Category"><code>Category</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/categories/Categories.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories.Category" href="#Catlab.CategoricalAlgebra.Cats.Categories.Category"><code>Catlab.CategoricalAlgebra.Cats.Categories.Category</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A (possibly) large category with ob/hom given by SetObs with element types Ob/Hom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/v0.2.1/src/syntax/TheoryInterface.jl#L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories.Category-Tuple{Category}" href="#Catlab.CategoricalAlgebra.Cats.Categories.Category-Tuple{Category}"><code>Catlab.CategoricalAlgebra.Cats.Categories.Category</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Coerce something to a category, no-op on actual categories </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/categories/Categories.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories.ConcreteCategory" href="#Catlab.CategoricalAlgebra.Cats.Categories.ConcreteCategory"><code>Catlab.CategoricalAlgebra.Cats.Categories.ConcreteCategory</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/v0.2.1/src/syntax/TheoryInterface.jl#L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats" href="#Catlab.CategoricalAlgebra.Cats.FinCats"><code>Catlab.CategoricalAlgebra.Cats.FinCats</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>2-category of finitely presented categories.</p><p>This module is for the 2-category <strong>Cat</strong> what the module <a href="@ref"><code>FinSets</code></a> is for the category <strong>Set</strong>: a finitary, combinatorial setting where explicit calculations can be carried out. We emphasize that the prefix <code>Fin</code> means &quot;finitely presented,&quot; not &quot;finite,&quot; as finite categories are too restrictive a notion for many purposes. For example, the free category on a graph is finite if and only if the graph is DAG, which is a fairly special condition. This usage of <code>Fin</code> is also consistent with <code>FinSet</code> because for sets, being finite and being finitely presented are equivalent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/fincats/module.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.##1292" href="#Catlab.CategoricalAlgebra.Cats.FinCats.##1292"><code>Catlab.CategoricalAlgebra.Cats.FinCats.##1292</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A FinCat extends a category by having a finite set of Hom generators. Each one  can be interpreted as a Hom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/fincats/FinCats.jl#L24-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.AbsCat" href="#Catlab.CategoricalAlgebra.Cats.FinCats.AbsCat"><code>Catlab.CategoricalAlgebra.Cats.FinCats.AbsCat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Common type for Categories and FinCats to be used by methods which only use  their common interface. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/fincats/FinCats.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.FinCat" href="#Catlab.CategoricalAlgebra.Cats.FinCats.FinCat"><code>Catlab.CategoricalAlgebra.Cats.FinCats.FinCat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/v0.2.1/src/syntax/TheoryInterface.jl#L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Paths.Path" href="#Catlab.CategoricalAlgebra.Cats.Paths.Path"><code>Catlab.CategoricalAlgebra.Cats.Paths.Path</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create path from a vector of generators. If no s/t provided, then the list  must not be empty </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/fincats/FinCats.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Graphs.NamedGraphs.NamedGraph-Tuple{FinCat}" href="#Catlab.Graphs.NamedGraphs.NamedGraph-Tuple{FinCat}"><code>Catlab.Graphs.NamedGraphs.NamedGraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Graph underlying a finitely presented category whose object and hom generators  are indexable, other than one explicitly generated by a graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/fincats/FinCats.jl#L93-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.decompose" href="#Catlab.CategoricalAlgebra.Cats.FinCats.decompose"><code>Catlab.CategoricalAlgebra.Cats.FinCats.decompose</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>To be implemented on a case-by-case basis </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/fincats/FinCats.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.hom_generators-Tuple{FinCat}" href="#Catlab.CategoricalAlgebra.Cats.FinCats.hom_generators-Tuple{FinCat}"><code>Catlab.CategoricalAlgebra.Cats.FinCats.hom_generators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>synonym for <code>gen_set</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/fincats/FinCats.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.is_discrete-Tuple{FinCat}" href="#Catlab.CategoricalAlgebra.Cats.FinCats.is_discrete-Tuple{FinCat}"><code>Catlab.CategoricalAlgebra.Cats.FinCats.is_discrete</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Is the category discrete?</p><p>A category is <em>discrete</em> if it is has no non-identity morphisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/fincats/FinCats.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.is_free-Tuple{FinCat}" href="#Catlab.CategoricalAlgebra.Cats.FinCats.is_free-Tuple{FinCat}"><code>Catlab.CategoricalAlgebra.Cats.FinCats.is_free</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Is the category freely generated?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/fincats/FinCats.jl#L85-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.ob_generators-Tuple{FinCat}" href="#Catlab.CategoricalAlgebra.Cats.FinCats.ob_generators-Tuple{FinCat}"><code>Catlab.CategoricalAlgebra.Cats.FinCats.ob_generators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>synonym for <code>ob_set</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/cats/fincats/FinCats.jl#L49">source</a></section></article><h2 id="Acsets"><a class="docs-heading-anchor" href="#Acsets">Acsets</a><a id="Acsets-1"></a><a class="docs-heading-anchor-permalink" href="#Acsets" title="Permalink"></a></h2><h3 id="Overview-and-Theory"><a class="docs-heading-anchor" href="#Overview-and-Theory">Overview and Theory</a><a id="Overview-and-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-and-Theory" title="Permalink"></a></h3><p>For an in depth look into the theory behind acsets, we refer the reader to <a href="https://arxiv.org/abs/2106.04703">our paper</a> on the subject, which also gives some sense as to how the implementation works. Here, we give a brief tutorial before the the API documentation.</p><p>The most essential part of the acset machinery is the schema. The schema <em>parameterizes</em> the acset: each schema corresponds to a different type of acset. Schemas consist of four parts.</p><ul><li>Objects <span>$X,Y$</span> (<code>(X,Y,Z)::Ob</code>)</li><li>Homomorphisms <span>$f \colon X \to Y$</span> (<code>f :: Hom(X,Y)</code>), which go from objects to objects</li><li>Attribute types <span>$\mathtt{T}$</span> (<code>T :: AttrType</code>)</li><li>Attributes <span>$a \colon X \to \mathtt{T}$</span> (<code>a :: Attr(X,T)</code>), which go from objects to data types</li></ul><p>For those with a categorical background, a schema is a presentation of a category <span>$|S|$</span> along with a functor <span>$S$</span> from <span>$|S|$</span> to the arrow category <span>$0 \to 1$</span>, such that <span>$S^{-1}(1)$</span> is discrete.</p><p>An acset <span>$F$</span> on a schema consists of...</p><ul><li>a set <span>$F(X)$</span> of &quot;primary keys&quot; for each object</li><li>a function <span>$F(f) \colon F(X) \to F(Y)$</span> for each morphism</li><li>a Julia data type <span>$F(\mathtt{T})$</span> for each data type <span>$\mathtt{T}$</span></li><li>a function <span>$F(a) \colon F(X) \to F(\mathtt{T})$</span> for each attribute <span>$a$</span>.</li></ul><p>For those with a categorical background, an acset on a schema <span>$S$</span> consists of a functor from <span>$S$</span> to <span>$\mathsf{Set}$</span>, such that objects in <span>$S^{-1}(0)$</span> map to finite sets, and objects in <span>$S^{-1}(1)$</span> map to sets that represent types. For any particular functor <span>$K \colon S^{-1}(1) \to \mathsf{Set}$</span>, we can also take the category of acsets that restrict to this map on <span>$S^{-1}$</span>.</p><p>We can also add equations to this presentation, but we currently do nothing with those equations in the implementation; they mostly serve as documentation.</p><p>We will now give an example of how this all works in practice.</p><pre><code class="language-julia hljs">using GATlab, Catlab.CategoricalAlgebra

# Write down the schema for a weighted graph
@present SchWeightedGraph(FreeSchema) begin
  V::Ob
  E::Ob
  src::Hom(E,V)
  tgt::Hom(E,V)
  T::AttrType
  weight::Attr(E,T)
end

# Construct the type used to store acsets on the previous schema
# We *index* src and tgt, which means that we store not only
# the forwards map, but also the backwards map.
@acset_type WeightedGraph(SchWeightedGraph, index=[:src,:tgt])

# Construct a weighted graph, with floats as edge weights
g = @acset WeightedGraph{Float64} begin
  V = 4
  E = 5
  src = [1,1,1,2,3]
  tgt = [2,3,4,4,4]
  weight = [7.2, 9.3, 9.4, 0.1, 42.0]
end</code></pre><div class="c-set">
<span class="c-set-summary">Main.__atexample__317.WeightedGraph{Float64} {V:4, E:5, T:0}</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">E</th>
      <th style = "text-align: right;">src</th>
      <th style = "text-align: right;">tgt</th>
      <th style = "text-align: right;">weight</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">7.2</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">9.3</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">9.4</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">0.1</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">42.0</td>
    </tr>
  </tbody>
</table>
</div>
<h3 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h3><p>The mathematical abstraction of an acset can of course be implemented in many different ways. Currently, there are three implementations of acsets in Catlab, which share a great deal of code.</p><p>These implementations can be split into two categories.</p><p>The first category is <strong>static acset types</strong>. In this implementation, different schemas correspond to different Julia types. Methods on these Julia types are then custom-generated for the schema, using <a href="https://github.com/AlgebraicJulia/CompTime.jl">CompTime.jl</a>.</p><p>Under this category, there are two classes of static acset types. The first class is acset types that are generated using the <code>@acset_type</code> macro. These acset types are custom-derived structs. The advantage of this is that the structs have names like <code>Graph</code> or <code>WiringDiagram</code> that are printed out in error messages. The disadvantage is that if you are taking in schemas at runtime, you have to <code>eval</code> code in order to use them.</p><p>Here is an example of using <code>@acset_type</code></p><pre><code class="language-julia hljs">@acset_type WeightedGraph(SchWeightedGraph, index=[:src,:tgt])
g = WeightedGraph()</code></pre><p>The second class is <code>AnonACSet</code>s. Like acset types derived from <code>@acset_type</code>, these contain the schema in their type. However, they also contain the type of their fields in their types, so the types printed out in error messages are long and ugly. The advantage of these is that they can be used in situations where the schema is passed in at runtime, and they don&#39;t require using <code>eval</code> to create a new acset type.</p><p>Here is an example of using <code>AnonACSet</code></p><pre><code class="language-julia hljs">const WeightedGraph = AnonACSetType(SchWeightedGraph, index=[:src,:tgt])
g = WeightedGraph()</code></pre><p>The second category is <strong>dynamic acset types</strong>. Currently, there is just one type that falls under this category: <code>DynamicACSet</code>. This type has a <strong>field</strong> for the schema, and no code-generation is done for operations on acsets of this type. This means that if the schema is large compared to the data, this type will often be faster than the static acsets.</p><p>However, dynamics acsets are a new addition to Catlab, and much of the machinery of limits, colimits, and other high-level acset constructions assumes that the schema of an acset can be derived from the type. Thus, more work will have to be done before dynamic acsets become a drop-in replacement for static acsets.</p><p>Here is an example of using a dynamic acset</p><pre><code class="language-julia hljs">g = DynamicACSet(&quot;WeightedGraph&quot;, SchWeightedGraph; index=[:src,:tgt])</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.CSets" href="#Catlab.CategoricalAlgebra.Pointwise.CSets"><code>Catlab.CategoricalAlgebra.Pointwise.CSets</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Categories of C-sets and attributed C-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/csets/module.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.CSets.ACSetCategory" href="#Catlab.CategoricalAlgebra.Pointwise.CSets.ACSetCategory"><code>Catlab.CategoricalAlgebra.Pointwise.CSets.ACSetCategory</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/v0.2.1/src/syntax/TheoryInterface.jl#L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Transformations.is_natural-Tuple{ACSetTransformation}" href="#Catlab.CategoricalAlgebra.Cats.Transformations.is_natural-Tuple{ACSetTransformation}"><code>Catlab.CategoricalAlgebra.Cats.Transformations.is_natural</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check naturality condition for a purported ACSetTransformation, α: X→Y.  For each hom in the schema, e.g. h: m → n, the following square must commute:</p><pre><code class="language-text hljs">     αₘ
  Xₘ --&gt; Yₘ
Xₕ ↓  ✓  ↓ Yₕ
  Xₙ --&gt; Yₙ
     αₙ</code></pre><p>You&#39;re allowed to run this on a named tuple partly specifying an ACSetTransformation, though at this time the domain and codomain must be fully specified ACSets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/csets/CSets.jl#L193-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Transformations.naturality_failures-Tuple{ACSet, ACSet, Any}" href="#Catlab.CategoricalAlgebra.Cats.Transformations.naturality_failures-Tuple{ACSet, ACSet, Any}"><code>Catlab.CategoricalAlgebra.Cats.Transformations.naturality_failures</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns a dictionary whose keys are contained in the names in <code>arrows(S)</code> and whose value at <code>:f</code>, for an arrow <code>(f,c,d)</code>, is a lazy iterator over the elements of X(c) on which α&#39;s naturality square for f does not commute. Components should be a NamedTuple or Dictionary with keys contained in the names of S&#39;s morphisms and values vectors or dicts defining partial functions from X(c) to Y(c).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/csets/CSets.jl#L214-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.CSets.coerce-Tuple{ACSetTransformation}" href="#Catlab.CategoricalAlgebra.Pointwise.CSets.coerce-Tuple{ACSetTransformation}"><code>Catlab.CategoricalAlgebra.Pointwise.CSets.coerce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Apply coerce<em>ob and coerce</em>attr to the components of an ACSetTransformation. Any keys not present will be interpreted as <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/csets/CSets.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.CSets.coerce_components-Tuple{ACSetTransformation}" href="#Catlab.CategoricalAlgebra.Pointwise.CSets.coerce_components-Tuple{ACSetTransformation}"><code>Catlab.CategoricalAlgebra.Pointwise.CSets.coerce_components</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Apply coerce<em>ob and coerce</em>attr to the components of an ACSetTransformation.</p><p>Does not require that all schema ob and attrtypes are present in <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/csets/CSets.jl#L146-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.CSets.entity_attr_cat-Tuple{ACSetCategory, Symbol}" href="#Catlab.CategoricalAlgebra.Pointwise.CSets.entity_attr_cat-Tuple{ACSetCategory, Symbol}"><code>Catlab.CategoricalAlgebra.Pointwise.CSets.entity_attr_cat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>When we don&#39;t know whether <code>o</code> is an Ob or an AttrType in the schema </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/csets/CSets.jl#L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.CSets.is_cartesian" href="#Catlab.CategoricalAlgebra.Pointwise.CSets.is_cartesian"><code>Catlab.CategoricalAlgebra.Pointwise.CSets.is_cartesian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_cartesian(f,hs)</code></pre><p>Checks if an acset transformation <code>f</code> is cartesian at the homs in the list <code>hs</code>. Expects the homs to be given as a list of <code>Symbol</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/csets/CSets.jl#L314-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.CSets.sets-Tuple{ACSet}" href="#Catlab.CategoricalAlgebra.Pointwise.CSets.sets-Tuple{ACSet}"><code>Catlab.CategoricalAlgebra.Pointwise.CSets.sets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>C-set → named tuple of sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/csets/CSets.jl#L183-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.CSets.show_naturality_failures-Tuple{IO, AbstractDict}" href="#Catlab.CategoricalAlgebra.Pointwise.CSets.show_naturality_failures-Tuple{IO, AbstractDict}"><code>Catlab.CategoricalAlgebra.Pointwise.CSets.show_naturality_failures</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Pretty-print failures of transformation to be natural.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Cats.Transformations.naturality_failures-Tuple{ACSet, ACSet, Any}"><code>naturality_failures</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/csets/CSets.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations" href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations"><code>Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Functorial data migration for attributed C-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/datamigrations/module.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.DataMigrationFunctor" href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.DataMigrationFunctor"><code>Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.DataMigrationFunctor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Data migration functor given contravariantly. Stores a contravariant migration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/datamigrations/FunctorialDataMigrations.jl#L153-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate!-Tuple{ACSet, ACSet, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.AbstractDataMigration}" href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate!-Tuple{ACSet, ACSet, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.AbstractDataMigration}"><code>Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Contravariantly migrate data from the acset <code>Y</code> to the acset <code>X</code>.</p><p>This is the mutating variant of <a href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate!-Tuple{ACSet, ACSet, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.AbstractDataMigration}"><code>migrate!</code></a>. When the functor on schemas is the identity, this operation is equivalent to <a href="@ref"><code>copy_parts!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/datamigrations/FunctorialDataMigrations.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate-Tuple{FunctorFinDom, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.ContravariantMigration}" href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate-Tuple{FunctorFinDom, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.ContravariantMigration}"><code>Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Apply a <span>$Δ$</span> migration by simple precomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/datamigrations/FunctorialDataMigrations.jl#L87-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate-Union{Tuple{T}, Tuple{Type{T}, ACSet, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.AbstractDataMigration}} where T&lt;:ACSet" href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate-Union{Tuple{T}, Tuple{Type{T}, ACSet, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.AbstractDataMigration}} where T&lt;:ACSet"><code>Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Contravariantly migrate data from the acset <code>Y</code> to a new acset of type <code>T</code>.</p><p>The mutating variant of this function is <a href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate!-Tuple{ACSet, ACSet, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.AbstractDataMigration}"><code>migrate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/datamigrations/FunctorialDataMigrations.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.functor-Tuple{DataMigrationFunctor}" href="#GATlab.Models.SymbolicModels.functor-Tuple{DataMigrationFunctor}"><code>GATlab.Models.SymbolicModels.functor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gives the underlying schema functor of a data migration  seen as a functor of acset categories.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/datamigrations/FunctorialDataMigrations.jl#L165-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.Chase" href="#Catlab.CategoricalAlgebra.Pointwise.Chase"><code>Catlab.CategoricalAlgebra.Pointwise.Chase</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The chase is an algorithm which subjects a C-Set instance to constraints  expressed in the language of regular logic, called embedded dependencies  (EDs, or &#39;triggers&#39;). </p><p>A morphism S-&gt;T, encodes an embedded dependency. If the pattern  S is matched (via a homomorphism S-&gt;I), we demand there exist a morphism T-&gt;I  (for some database instance I) that makes the triangle commute in order to  satisfy the dependency (if this is not the case, then the trigger is &#39;active&#39;).</p><p>Homomorphisms can merge elements and introduce new ones. The former kind are called &quot;equality generating dependencies&quot; (EGDs) and the latter &quot;tuple generating dependencies&quot; (TGDs). Any homomorphism can be factored into EGD and TGD components by, respectively, restricting the codomain to the image or restricting the domain to the coimage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/Chase.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.Chase.chase-Tuple{ACSet, AbstractDict, Int64}" href="#Catlab.CategoricalAlgebra.Pointwise.Chase.chase-Tuple{ACSet, AbstractDict, Int64}"><code>Catlab.CategoricalAlgebra.Pointwise.Chase.chase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chase(I::ACSet, Σ::AbstractDict, n::Int)</code></pre><p>Chase a C-Set or C-Rel instance given a list of embedded dependencies. This may not terminate, so a bound <code>n</code> on the number of iterations is required.</p><pre><code class="nohighlight hljs">[,]</code></pre><p>ΣS  ⟶ Iₙ ⊕↓      ⋮  (resulting morphism)  ΣT ... Iₙ₊₁</p><p>There is a copy of S and T for each active trigger. A trigger is a map from S into the current instance. What makes it &#39;active&#39; is that there is no morphism from T to I that makes the triangle commute.</p><p>Each iteration constructs the above pushout square. The result is a morphism, so that one can keep track of the provenance of elements in the original CSet instance within the chased result.</p><p>Whether or not the result is due to success or timeout is returned as a boolean flag.</p><p>TODO: this algorithm could be made more efficient by homomorphism caching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/Chase.jl#L269-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Structured cospans.</p><p>This module provides a generic interface for structured cospans with a concrete implementation for attributed C-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/StructuredCospans.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetLeg" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetLeg"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetLeg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Leg of a structured (multi)cospan of acsets in R-form.</p><p>A convenience type that contains the data of an acset transformation, except for the codomain, since that data is already given by the decoration of the R-form structured cospan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/StructuredCospans.jl#L295-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Structured cospan.</p><p>The first type parameter <code>L</code> encodes a functor L: A → X from the base category <code>A</code>, often FinSet, to a category <code>X</code> with &quot;extra structure.&quot; An L-structured cospan is then a cospan in X whose feet are images under L of objects in A. The category X is assumed to have pushouts.</p><p>Structured cospans form a double category with no further assumptions on the functor L. To obtain a symmetric monoidal double category, L must preserve finite coproducts. In practice, L usually has a right adjoint R: X → A, which implies that L preserves all finite colimits. It also allows structured cospans to be constructed more conveniently from an object x in X plus a cospan in A with apex R(x).</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan"><code>StructuredMulticospan</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/StructuredCospans.jl#L65-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Any, Multicospan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}}} where L" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Any, Multicospan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}}} where L"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Construct structured cospan in R-form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/StructuredCospans.jl#L89-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Multicospan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}, StaticArraysCore.StaticArray{Tuple{2}, T, 1} where T}} where L" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Multicospan{Ob, Hom, Foot, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Foot, 1}} where {Ob, Hom, Foot}, StaticArraysCore.StaticArray{Tuple{2}, T, 1} where T}} where L"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Construct structured cospan in L-form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/StructuredCospans.jl#L84-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Object in the category of L-structured cospans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/StructuredCospans.jl#L117-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Structured multicospan.</p><p>A structured multicospan is like a structured cospan except that it may have a number of legs different than two.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan"><code>StructuredCospan</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/StructuredCospans.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan-Union{Tuple{L}, Tuple{Any, Multicospan}} where L" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan-Union{Tuple{L}, Tuple{Any, Multicospan}} where L"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Construct structured multicospan in R-form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/StructuredCospans.jl#L53-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S, X&lt;:(StructACSet{S})}" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S, X&lt;:(StructACSet{S})}"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetTypes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create types for open attributed C-sets from an attributed C-set type.</p><p>The type parameters of the given acset type should <em>not</em> be instantiated with specific Julia types. This function returns a pair of types, one for objects, a subtype of <a href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb"><code>StructuredCospanOb</code></a>, and one for morphisms, a subtype of <a href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan"><code>StructuredMulticospan</code></a>. Both types will have the same type parameters for attribute types as the given acset type.</p><p>Mathematically speaking, this function sets up structured (multi)cospans with a functor <span>$L: A → X$</span> between categories of acsets that creates &quot;discrete acsets.&quot; Such a &quot;discrete acset functor&quot; is a functor that is left adjoint to a certain kind of forgetful functor between categories of acsets, namely one that is a pullback along an inclusion of schemas such that the image of inclusion has no outgoing arrows. For example, the schema inclusion <span>${V} ↪ {E ⇉ V}$</span> has this property but <span>${E} ↪ {E ⇉ V}$</span> does not.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{Type{X}, Vararg{Any}}} where X&lt;:(StructCSet)"><code>OpenCSetTypes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/StructuredCospans.jl#L250-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{Type{X}, Vararg{Any}}} where X&lt;:(StructCSet)" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{Type{X}, Vararg{Any}}} where X&lt;:(StructCSet)"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenCSetTypes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create types for open C-sets from a C-set type.</p><p>A special case of <a href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S, X&lt;:(StructACSet{S})}"><code>OpenACSetTypes</code></a>. See there for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/5e73d02adc1007d9f301bc3e8d501e513a6c5079/src/categorical_algebra/pointwise/StructuredCospans.jl#L242-L246">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theories/">« Standard library of theories</a><a class="docs-footer-nextpage" href="../graphs/">Graphs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 1 August 2025 07:10">Friday 1 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
