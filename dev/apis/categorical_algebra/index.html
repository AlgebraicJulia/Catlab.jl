<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Categorical algebra · Catlab.jl</title><meta name="title" content="Categorical algebra · Catlab.jl"/><meta property="og:title" content="Categorical algebra · Catlab.jl"/><meta property="twitter:title" content="Categorical algebra · Catlab.jl"/><meta name="description" content="Documentation for Catlab.jl."/><meta property="og:description" content="Documentation for Catlab.jl."/><meta property="twitter:description" content="Documentation for Catlab.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catlab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Seven Sketches in Compositionality</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/sketches/partitions/">Partitions</a></li><li><a class="tocitem" href="../../generated/sketches/preorders/">Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/meets/">Meets in Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/smc/">Symmetric Monoidal Categories</a></li><li><a class="tocitem" href="../../generated/sketches/cat_elements/">The Category of Elements</a></li><li><a class="tocitem" href="../../generated/sketches/sheaves/">Basic Sheaf Constructions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphs/graphs/">The Category of Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/graphs_label/">Labeled Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/subgraphs/">Algebra of subgraphs</a></li></ul></li><li><span class="tocitem">Categorical Algebra</span></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Wiring Diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/wd_cset/">Wiring Diagrams as Attributed C-Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/graphviz_graphs/">Drawing graphs in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li class="is-active"><a class="tocitem" href>Categorical algebra</a><ul class="internal"><li><a class="tocitem" href="#Sets-and-Relations"><span>Sets and Relations</span></a></li><li><a class="tocitem" href="#Free-Diagrams,-Limits,-and-Colimits"><span>Free Diagrams, Limits, and Colimits</span></a></li><li><a class="tocitem" href="#Categories"><span>Categories</span></a></li><li><a class="tocitem" href="#Acsets"><span>Acsets</span></a></li></ul></li><li><a class="tocitem" href="../graphs/">Graphs</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li><a class="tocitem" href="../programs/">Programs</a></li><li><a class="tocitem" href="../sheaves/">Sheaves</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../devdocs/style/">Style Guide for AlgebraicJulia</a></li><li><a class="tocitem" href="../../generated/peg-parser/dsl_peg_tutorial/">Domain Specific Parsing Expression Grammars</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Categorical algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Categorical algebra</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/Catlab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/main/docs/src/apis/categorical_algebra.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="categorical_algebra"><a class="docs-heading-anchor" href="#categorical_algebra">Categorical algebra</a><a id="categorical_algebra-1"></a><a class="docs-heading-anchor-permalink" href="#categorical_algebra" title="Permalink"></a></h1><h2 id="Sets-and-Relations"><a class="docs-heading-anchor" href="#Sets-and-Relations">Sets and Relations</a><a id="Sets-and-Relations-1"></a><a class="docs-heading-anchor-permalink" href="#Sets-and-Relations" title="Permalink"></a></h2><p>The following APIs implement FinSet, the category of Finite Sets (actually the skeleton of FinSet). The objects of this category are natural numbers where <code>n</code> represents a set with <code>n</code> elements. The morphisms are functions between such sets. We use the skeleton of FinSet in order to ensure that all sets are finite and morphisms can be stored using lists of integers. Finite relations are built out of FinSet and can be used to do some relational algebra.</p><pre><code class="language- hljs">Modules = [
  BasicSets.Sets,
  BasicSets.FinSets,
  CategoricalAlgebra.FinRelations,
  ]
Private = false</code></pre><h2 id="Free-Diagrams,-Limits,-and-Colimits"><a class="docs-heading-anchor" href="#Free-Diagrams,-Limits,-and-Colimits">Free Diagrams, Limits, and Colimits</a><a id="Free-Diagrams,-Limits,-and-Colimits-1"></a><a class="docs-heading-anchor-permalink" href="#Free-Diagrams,-Limits,-and-Colimits" title="Permalink"></a></h2><p>The following modules define free diagrams in an arbitrary category and specify limit and colimit cones over said diagrams. Thes constructions enjoy the fullest support for FinSet and are used below to define presheaf categories as C-Sets. The general idea of these functions is that you set up a limit computation by specifying a diagram and asking for a limit or colimit cone, which is returned as a struct containing the apex object and the leg morphisms. This cone structure can be queried using the functions <a href="@ref"><code>apex</code></a> and <a href="@ref"><code>legs</code></a>. Julia&#39;s multiple dispatch feature is heavily used to specialize limit and colimit computations for various diagram shapes like product/coproduct and equalizer/coequalizer. As a consumer of this API, it is highly recommended that you use multiple dispatch to specialize your code on the diagram shape whenever possible.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FreeDiagrams" href="#Catlab.CategoricalAlgebra.Cats.FreeDiagrams"><code>Catlab.CategoricalAlgebra.Cats.FreeDiagrams</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Free diagrams in a category.</p><p>A <a href="https://ncatlab.org/nlab/show/free+diagram">free diagram</a> in a category is a diagram whose shape is a free category. Examples include the empty diagram, pairs of objects, discrete diagrams, parallel pairs, composable pairs, and spans and cospans. Limits and colimits are most commonly taken over free diagrams.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/freediagrams/module.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FreeDiagrams.FixedShapeFreeDiagram" href="#Catlab.CategoricalAlgebra.Cats.FreeDiagrams.FixedShapeFreeDiagram"><code>Catlab.CategoricalAlgebra.Cats.FreeDiagrams.FixedShapeFreeDiagram</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract type for free diagram of fixed shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/freediagrams/FreeDiagrams.jl#L38-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cocone_objects-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cocone_objects-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cocone_objects</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Objects in diagram that will have explicit legs in colimit cocone.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cone_objects-Tuple{Any}"><code>cone_objects</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/freediagrams/FreeDiagrams.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cone_objects-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cone_objects-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cone_objects</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Objects in diagram that will have explicit legs in limit cone.</p><p>In category theory, it is common practice to elide legs of limit cones that can be computed from other legs, especially for diagrams of certain fixed shapes. For example, when it taking a pullback (the limit of a cospan), the limit object is often treated as having two projections, rather than three. This function encodes such conventions by listing the objects in the diagram that will have corresponding legs in the limit object created by Catlab.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Cats.FreeDiagrams.cocone_objects-Tuple{Any}"><code>cocone_objects</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/freediagrams/FreeDiagrams.jl#L16-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FreeDiagrams.diagram_type" href="#Catlab.CategoricalAlgebra.Cats.FreeDiagrams.diagram_type"><code>Catlab.CategoricalAlgebra.Cats.FreeDiagrams.diagram_type</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a diagram in a category <span>$C$</span>, return Julia type of objects and morphisms in <span>$C$</span> as a tuple type of form <span>$Tuple{Ob,Hom}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/freediagrams/FreeDiagrams.jl#L11-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.AbstractLimit" href="#Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.AbstractLimit"><code>Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.AbstractLimit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract type for limit in a category.</p><p>The standard concrete subtype is <a href="#Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.Limit"><code>Limit</code></a>, although for computational reasons certain categories may use different subtypes to include extra data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/limits_colimits/Limits.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.Limit" href="#Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.Limit"><code>Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.Limit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Limit in a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/limits_colimits/Limits.jl#L32-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.LimitAlgorithm" href="#Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.LimitAlgorithm"><code>Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.LimitAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Algorithm for computing limits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/limits_colimits/Limits.jl#L41-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.SpecializeLimit" href="#Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.SpecializeLimit"><code>Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.SpecializeLimit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Meta-algorithm that reduces general limits to common special cases.</p><p>Reduces limits of free diagrams that happen to be discrete to products. If this fails, fall back to the given algorithm (if any).</p><p>TODO: Reduce free diagrams that are (multi)cospans to (wide) pullbacks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/limits_colimits/Limits.jl#L60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.limit-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.limit-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Cats.LimitsColimits.Limits.limit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Limit of a diagram.</p><p>To define limits in a category with objects <code>Ob</code>, override the method <code>limit(::FreeDiagram{Ob})</code> for general limits or <code>limit(::D)</code> with suitable type <code>D &lt;: FixedShapeFreeDiagram{Ob}</code> for limits of specific shape, such as products or equalizers.</p><p>See also: <a href="@ref"><code>colimit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/limits_colimits/Limits.jl#L46-L55">source</a></section></article><h2 id="Categories"><a class="docs-heading-anchor" href="#Categories">Categories</a><a id="Categories-1"></a><a class="docs-heading-anchor-permalink" href="#Categories" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories" href="#Catlab.CategoricalAlgebra.Cats.Categories"><code>Catlab.CategoricalAlgebra.Cats.Categories</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>2-category of categories, functors, and natural transformations.</p><p>Categories in mathematics appear in the large, often as categories of sets with extra structure, and in the small, as algebraic structures that generalize groups, monoids, preorders, and graphs. This division manifests in Catlab as well. Large categories (in spirit, if not in the <a href="https://ncatlab.org/nlab/show/large+category">technical sense</a>) occur throughout Catlab as <code>@instance</code>s of the theory of categories. For computational reasons, small categories are usually presented by generators and relations.</p><p>This module provides a minimal interface to accomodate both situations. Category instances are supported through the wrapper type <a href="@ref"><code>TypeCat</code></a>. Finitely presented categories are provided by another module, <a href="@ref"><code>FinCats</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/categories/module.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories.Cat" href="#Catlab.CategoricalAlgebra.Cats.Categories.Cat"><code>Catlab.CategoricalAlgebra.Cats.Categories.Cat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Alias for <a href="#Catlab.CategoricalAlgebra.Cats.Categories.Category"><code>Category</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/categories/Categories.jl#L42-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories.CatSize" href="#Catlab.CategoricalAlgebra.Cats.Categories.CatSize"><code>Catlab.CategoricalAlgebra.Cats.Categories.CatSize</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Size of a category, used for dispatch and subtyping purposes.</p><p>A <a href="#Catlab.CategoricalAlgebra.Cats.Categories.Category"><code>Category</code></a> type having a particular <code>CatSize</code> means that categories of that type are <em>at most</em> that large.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/categories/Categories.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories.Category" href="#Catlab.CategoricalAlgebra.Cats.Categories.Category"><code>Catlab.CategoricalAlgebra.Cats.Categories.Category</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract base type for a category.</p><p>The objects and morphisms in the category have Julia types <code>Ob</code> and <code>Hom</code>, respectively. Note that these types do <em>not</em> necessarily form an <code>@instance</code> of the theory of categories, as they may not meaningfully form a category outside the context of this object. For example, a finite category regarded as a reflexive graph with a composition operation might have type <code>Cat{Int,Int}</code>, where the objects and morphisms are numerical identifiers for vertices and edges in the graph.</p><p>The basic operations available in any category are: <a href="#AlgebraicInterfaces.dom-Tuple{Category, Any}"><code>dom</code></a>, <a href="#AlgebraicInterfaces.codom-Tuple{Category, Any}"><code>codom</code></a>, <a href="#AlgebraicInterfaces.id-Tuple{Category, Any}"><code>id</code></a>, <a href="#AlgebraicInterfaces.compose-Tuple{Category, Vararg{Any}}"><code>compose</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/categories/Categories.jl#L27-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories.LargeCatSize" href="#Catlab.CategoricalAlgebra.Cats.Categories.LargeCatSize"><code>Catlab.CategoricalAlgebra.Cats.Categories.LargeCatSize</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Size of a large category, such as Set.</p><p>To the extent that they form a category, we regard Julia types and functions (<a href="@ref"><code>TypeCat</code></a>) as forming a large category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/categories/Categories.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.codom-Tuple{Category, Any}" href="#AlgebraicInterfaces.codom-Tuple{Category, Any}"><code>AlgebraicInterfaces.codom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Codomain of morphism in category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/categories/Categories.jl#L67-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.compose-Tuple{Category, Vararg{Any}}" href="#AlgebraicInterfaces.compose-Tuple{Category, Vararg{Any}}"><code>AlgebraicInterfaces.compose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Compose morphisms in a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/categories/Categories.jl#L75-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.dom-Tuple{Category, Any}" href="#AlgebraicInterfaces.dom-Tuple{Category, Any}"><code>AlgebraicInterfaces.dom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Domain of morphism in category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/categories/Categories.jl#L63-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.hom" href="#AlgebraicInterfaces.hom"><code>AlgebraicInterfaces.hom</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Coerce or look up morphism in category.</p><p>See also: <a href="#AlgebraicInterfaces.ob"><code>ob</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/categories/Categories.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.id-Tuple{Category, Any}" href="#AlgebraicInterfaces.id-Tuple{Category, Any}"><code>AlgebraicInterfaces.id</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Identity morphism on object in category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/categories/Categories.jl#L71-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.ob" href="#AlgebraicInterfaces.ob"><code>AlgebraicInterfaces.ob</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Coerce or look up object in category.</p><p>Converts the input to an object in the category, which should be of type <code>Ob</code> in a category of type <code>Cat{Ob,Hom}</code>. How this works depends on the category, but a common case is to look up objects, which might be integers or GAT expressions, by their human-readable name, usually a symbol.</p><p>See also: <a href="#AlgebraicInterfaces.hom"><code>hom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/categories/Categories.jl#L46-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.Categories.is_hom_equal-Tuple{Category, Any, Any}" href="#Catlab.CategoricalAlgebra.Cats.Categories.is_hom_equal-Tuple{Category, Any, Any}"><code>Catlab.CategoricalAlgebra.Cats.Categories.is_hom_equal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Are two morphisms in a category equal?</p><p>By default, just checks for equality of Julia objects using <span>$==$</span>. In some categories, checking equality of morphisms may involve nontrivial reasoning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/categories/Categories.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats" href="#Catlab.CategoricalAlgebra.Cats.FinCats"><code>Catlab.CategoricalAlgebra.Cats.FinCats</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>2-category of finitely presented categories.</p><p>This module is for the 2-category <strong>Cat</strong> what the module <a href="@ref"><code>FinSets</code></a> is for the category <strong>Set</strong>: a finitary, combinatorial setting where explicit calculations can be carried out. We emphasize that the prefix <code>Fin</code> means &quot;finitely presented,&quot; not &quot;finite,&quot; as finite categories are too restrictive a notion for many purposes. For example, the free category on a graph is finite if and only if the graph is DAG, which is a fairly special condition. This usage of <code>Fin</code> is also consistent with <code>FinSet</code> because for sets, being finite and being finitely presented are equivalent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/fincats/module.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.FinCat" href="#Catlab.CategoricalAlgebra.Cats.FinCats.FinCat"><code>Catlab.CategoricalAlgebra.Cats.FinCats.FinCat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A finitely presented (but not necessarily finite!) category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/fincats/FinCats.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.FinCatSize" href="#Catlab.CategoricalAlgebra.Cats.FinCats.FinCatSize"><code>Catlab.CategoricalAlgebra.Cats.FinCats.FinCatSize</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Size of a finitely presented category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/fincats/FinCats.jl#L22-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.graph-Tuple{Category{Ob, Hom, FinCatSize} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.Cats.FinCats.graph-Tuple{Category{Ob, Hom, FinCatSize} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.Cats.FinCats.graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Graph underlying a finitely presented category whose  object and hom generators are indexable, other than one explicitly generated by a graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/fincats/FinCats.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.hom_generator" href="#Catlab.CategoricalAlgebra.Cats.FinCats.hom_generator"><code>Catlab.CategoricalAlgebra.Cats.FinCats.hom_generator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Coerce or look up morphism generator in a finitely presented category.</p><p>Since morphism generators often have a different data type than morphisms (e.g., in a free category on a graph, the morphism generators are edges and the morphisms are paths), the return type of this function is generally different than that of <a href="#AlgebraicInterfaces.hom"><code>hom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/fincats/FinCats.jl#L51-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.hom_generator_name" href="#Catlab.CategoricalAlgebra.Cats.FinCats.hom_generator_name"><code>Catlab.CategoricalAlgebra.Cats.FinCats.hom_generator_name</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Name of morphism generator, if any.</p><p>When morphism generators have names, this function is a one-sided inverse to <a href="#Catlab.CategoricalAlgebra.Cats.FinCats.hom_generator"><code>hom_generator</code></a>. See also: <a href="#Catlab.CategoricalAlgebra.Cats.FinCats.ob_generator_name"><code>ob_generator_name</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/fincats/FinCats.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.hom_generators" href="#Catlab.CategoricalAlgebra.Cats.FinCats.hom_generators"><code>Catlab.CategoricalAlgebra.Cats.FinCats.hom_generators</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Morphism generators of finitely presented category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/fincats/FinCats.jl#L38-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.is_discrete-Tuple{Category{Ob, Hom, FinCatSize} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.Cats.FinCats.is_discrete-Tuple{Category{Ob, Hom, FinCatSize} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.Cats.FinCats.is_discrete</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Is the category discrete?</p><p>A category is <em>discrete</em> if it is has no non-identity morphisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/fincats/FinCats.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.is_free-Tuple{Category{Ob, Hom, FinCatSize} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.Cats.FinCats.is_free-Tuple{Category{Ob, Hom, FinCatSize} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.Cats.FinCats.is_free</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Is the category freely generated?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/fincats/FinCats.jl#L83-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.ob_generator" href="#Catlab.CategoricalAlgebra.Cats.FinCats.ob_generator"><code>Catlab.CategoricalAlgebra.Cats.FinCats.ob_generator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Coerce or look up object generator in a finitely presented category.</p><p>Because object generators usually coincide with objects, the default method for <a href="#AlgebraicInterfaces.ob"><code>ob</code></a> in finitely presented categories simply calls this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/fincats/FinCats.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.ob_generator_name" href="#Catlab.CategoricalAlgebra.Cats.FinCats.ob_generator_name"><code>Catlab.CategoricalAlgebra.Cats.FinCats.ob_generator_name</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Name of object generator, if any.</p><p>When object generators have names, this function is a one-sided inverse to <a href="#Catlab.CategoricalAlgebra.Cats.FinCats.ob_generator"><code>ob_generator</code></a> in that <code>ob_generator(C, ob_generator_name(C, x)) == x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/fincats/FinCats.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Cats.FinCats.ob_generators" href="#Catlab.CategoricalAlgebra.Cats.FinCats.ob_generators"><code>Catlab.CategoricalAlgebra.Cats.FinCats.ob_generators</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Object generators of finitely presented category.</p><p>The object generators of finite presented category are almost always the same as the objects. In principle, however, it is possible to have equations between objects, so that there are fewer objects than object generators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Cats/fincats/FinCats.jl#L30-L36">source</a></section></article><h2 id="Acsets"><a class="docs-heading-anchor" href="#Acsets">Acsets</a><a id="Acsets-1"></a><a class="docs-heading-anchor-permalink" href="#Acsets" title="Permalink"></a></h2><h3 id="Overview-and-Theory"><a class="docs-heading-anchor" href="#Overview-and-Theory">Overview and Theory</a><a id="Overview-and-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-and-Theory" title="Permalink"></a></h3><p>For an in depth look into the theory behind acsets, we refer the reader to <a href="https://arxiv.org/abs/2106.04703">our paper</a> on the subject, which also gives some sense as to how the implementation works. Here, we give a brief tutorial before the the API documentation.</p><p>The most essential part of the acset machinery is the schema. The schema <em>parameterizes</em> the acset: each schema corresponds to a different type of acset. Schemas consist of four parts.</p><ul><li>Objects <span>$X,Y$</span> (<code>(X,Y,Z)::Ob</code>)</li><li>Homomorphisms <span>$f \colon X \to Y$</span> (<code>f :: Hom(X,Y)</code>), which go from objects to objects</li><li>Attribute types <span>$\mathtt{T}$</span> (<code>T :: AttrType</code>)</li><li>Attributes <span>$a \colon X \to \mathtt{T}$</span> (<code>a :: Attr(X,T)</code>), which go from objects to data types</li></ul><p>For those with a categorical background, a schema is a presentation of a category <span>$|S|$</span> along with a functor <span>$S$</span> from <span>$|S|$</span> to the arrow category <span>$0 \to 1$</span>, such that <span>$S^{-1}(1)$</span> is discrete.</p><p>An acset <span>$F$</span> on a schema consists of...</p><ul><li>a set <span>$F(X)$</span> of &quot;primary keys&quot; for each object</li><li>a function <span>$F(f) \colon F(X) \to F(Y)$</span> for each morphism</li><li>a Julia data type <span>$F(\mathtt{T})$</span> for each data type <span>$\mathtt{T}$</span></li><li>a function <span>$F(a) \colon F(X) \to F(\mathtt{T})$</span> for each attribute <span>$a$</span>.</li></ul><p>For those with a categorical background, an acset on a schema <span>$S$</span> consists of a functor from <span>$S$</span> to <span>$\mathsf{Set}$</span>, such that objects in <span>$S^{-1}(0)$</span> map to finite sets, and objects in <span>$S^{-1}(1)$</span> map to sets that represent types. For any particular functor <span>$K \colon S^{-1}(1) \to \mathsf{Set}$</span>, we can also take the category of acsets that restrict to this map on <span>$S^{-1}$</span>.</p><p>We can also add equations to this presentation, but we currently do nothing with those equations in the implementation; they mostly serve as documentation.</p><p>We will now give an example of how this all works in practice.</p><pre><code class="language-julia hljs">using GATlab, Catlab.CategoricalAlgebra

# Write down the schema for a weighted graph
@present SchWeightedGraph(FreeSchema) begin
  V::Ob
  E::Ob
  src::Hom(E,V)
  tgt::Hom(E,V)
  T::AttrType
  weight::Attr(E,T)
end

# Construct the type used to store acsets on the previous schema
# We *index* src and tgt, which means that we store not only
# the forwards map, but also the backwards map.
@acset_type WeightedGraph(SchWeightedGraph, index=[:src,:tgt])

# Construct a weighted graph, with floats as edge weights
g = @acset WeightedGraph{Float64} begin
  V = 4
  E = 5
  src = [1,1,1,2,3]
  tgt = [2,3,4,4,4]
  weight = [7.2, 9.3, 9.4, 0.1, 42.0]
end</code></pre><div class="c-set">
<span class="c-set-summary">Main.__atexample__296.WeightedGraph{Float64} {V:4, E:5, T:0}</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">E</th>
      <th style = "text-align: right;">src</th>
      <th style = "text-align: right;">tgt</th>
      <th style = "text-align: right;">weight</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">7.2</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">9.3</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">9.4</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">0.1</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">42.0</td>
    </tr>
  </tbody>
</table>
</div>
<h3 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h3><p>The mathematical abstraction of an acset can of course be implemented in many different ways. Currently, there are three implementations of acsets in Catlab, which share a great deal of code.</p><p>These implementations can be split into two categories.</p><p>The first category is <strong>static acset types</strong>. In this implementation, different schemas correspond to different Julia types. Methods on these Julia types are then custom-generated for the schema, using <a href="https://github.com/AlgebraicJulia/CompTime.jl">CompTime.jl</a>.</p><p>Under this category, there are two classes of static acset types. The first class is acset types that are generated using the <code>@acset_type</code> macro. These acset types are custom-derived structs. The advantage of this is that the structs have names like <code>Graph</code> or <code>WiringDiagram</code> that are printed out in error messages. The disadvantage is that if you are taking in schemas at runtime, you have to <code>eval</code> code in order to use them.</p><p>Here is an example of using <code>@acset_type</code></p><pre><code class="language-julia hljs">@acset_type WeightedGraph(SchWeightedGraph, index=[:src,:tgt])
g = WeightedGraph()</code></pre><p>The second class is <code>AnonACSet</code>s. Like acset types derived from <code>@acset_type</code>, these contain the schema in their type. However, they also contain the type of their fields in their types, so the types printed out in error messages are long and ugly. The advantage of these is that they can be used in situations where the schema is passed in at runtime, and they don&#39;t require using <code>eval</code> to create a new acset type.</p><p>Here is an example of using <code>AnonACSet</code></p><pre><code class="language-julia hljs">const WeightedGraph = AnonACSetType(SchWeightedGraph, index=[:src,:tgt])
g = WeightedGraph()</code></pre><p>The second category is <strong>dynamic acset types</strong>. Currently, there is just one type that falls under this category: <code>DynamicACSet</code>. This type has a <strong>field</strong> for the schema, and no code-generation is done for operations on acsets of this type. This means that if the schema is large compared to the data, this type will often be faster than the static acsets.</p><p>However, dynamics acsets are a new addition to Catlab, and much of the machinery of limits, colimits, and other high-level acset constructions assumes that the schema of an acset can be derived from the type. Thus, more work will have to be done before dynamic acsets become a drop-in replacement for static acsets.</p><p>Here is an example of using a dynamic acset</p><pre><code class="language-julia hljs">g = DynamicACSet(&quot;WeightedGraph&quot;, SchWeightedGraph; index=[:src,:tgt])</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.CSets" href="#Catlab.CategoricalAlgebra.Pointwise.CSets"><code>Catlab.CategoricalAlgebra.Pointwise.CSets</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Categories of C-sets and attributed C-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/csets/module.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACSets.ACSetInterface.copy_parts!-Tuple{ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, FinCatSize} where {Ob, Hom})}" href="#ACSets.ACSetInterface.copy_parts!-Tuple{ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, FinCatSize} where {Ob, Hom})}"><code>ACSets.ACSetInterface.copy_parts!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Copy parts from a set-valued <code>FinDomFunctor</code> to an <code>ACSet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/csets/ACSetFunctors.jl#L68-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.CSets.is_cartesian" href="#Catlab.CategoricalAlgebra.Pointwise.CSets.is_cartesian"><code>Catlab.CategoricalAlgebra.Pointwise.CSets.is_cartesian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_cartesian(f,hs)</code></pre><p>Checks if an acset transformation <code>f</code> is cartesian at the homs in the list <code>hs</code>. Expects the homs to be given as a list of <code>Symbol</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/csets/CSets.jl#L221-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.DataMigrationFunctor" href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.DataMigrationFunctor"><code>Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.DataMigrationFunctor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Data migration functor given contravariantly. Stores a contravariant migration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/datamigrations/FunctorialDataMigrations.jl#L149-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.internal_hom-Union{Tuple{T}, Tuple{T, T}} where T&lt;:ACSet" href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.internal_hom-Union{Tuple{T}, Tuple{T, T}} where T&lt;:ACSet"><code>Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.internal_hom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Objects: Fᴳ(c) = C-Set(C × G, F)    where C is the representable c</p><p>Given a map f: a-&gt;b, we compute that f(Aᵢ) = Bⱼ by constructing the following:           Aᵢ     A × G → F   f*↑ ↑ ↑ ↗ Bⱼ       find the hom Bⱼ that makes this commute     B × G </p><p>where f* is given by <code>yoneda</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/datamigrations/Yoneda.jl#L75-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate!-Tuple{ACSet, ACSet, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.AbstractDataMigration}" href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate!-Tuple{ACSet, ACSet, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.AbstractDataMigration}"><code>Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Contravariantly migrate data from the acset <code>Y</code> to the acset <code>X</code>.</p><p>This is the mutating variant of <a href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate!-Tuple{ACSet, ACSet, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.AbstractDataMigration}"><code>migrate!</code></a>. When the functor on schemas is the identity, this operation is equivalent to <a href="#ACSets.ACSetInterface.copy_parts!-Tuple{ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, FinCatSize} where {Ob, Hom})}"><code>copy_parts!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/datamigrations/FunctorialDataMigrations.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, FinCatSize} where {Ob, Hom}), Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.ContravariantMigration{F} where F&lt;:(Functor{Dom, Codom} where {Dom&lt;:(Category{Ob, Hom, FinCatSize} where {Ob, Hom}), Codom&lt;:(Category{Ob, Hom, FinCatSize} where {Ob, Hom})})}" href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, FinCatSize} where {Ob, Hom}), Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.ContravariantMigration{F} where F&lt;:(Functor{Dom, Codom} where {Dom&lt;:(Category{Ob, Hom, FinCatSize} where {Ob, Hom}), Codom&lt;:(Category{Ob, Hom, FinCatSize} where {Ob, Hom})})}"><code>Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Apply a <span>$Δ$</span> migration by simple precomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/datamigrations/FunctorialDataMigrations.jl#L85-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate-Union{Tuple{T}, Tuple{Type{T}, ACSet, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.AbstractDataMigration}} where T&lt;:ACSet" href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate-Union{Tuple{T}, Tuple{Type{T}, ACSet, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.AbstractDataMigration}} where T&lt;:ACSet"><code>Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Contravariantly migrate data from the acset <code>Y</code> to a new acset of type <code>T</code>.</p><p>The mutating variant of this function is <a href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.migrate!-Tuple{ACSet, ACSet, Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.AbstractDataMigration}"><code>migrate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/datamigrations/FunctorialDataMigrations.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.representable-Tuple{Any, Symbol}" href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.representable-Tuple{Any, Symbol}"><code>Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.representable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Construct a representable C-set.</p><p>Recall that a <em>representable</em> C-set is one of form <span>$C(c,-): C → Set$</span> for some object <span>$c ∈ C$</span>.</p><p>This function computes the <span>$c$</span> representable as the left pushforward data migration of the singleton <span>${c}$</span>-set along the inclusion functor <span>${c} ↪ C$</span>, which works because left Kan extensions take representables to representables (Mac Lane 1978, Exercise X.3.2). Besides the intrinsic difficulties with representables (they can be infinite), this function thus inherits any limitations of our implementation of left pushforward data migrations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/datamigrations/Yoneda.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.subobject_classifier-Tuple{Type}" href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.subobject_classifier-Tuple{Type}"><code>Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.subobject_classifier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The subobject classifier Ω in a presheaf topos is the presheaf that sends each  object A to the set of sieves on it (equivalently, the set of subobjects of the  representable presheaf for A). Counting subobjects gives us the <em>number</em> of A  parts; the hom data for f:A-&gt;B for subobject Aᵢ is determined via:</p><p>Aᵢ ↪ A  ↑    ↑ f*   PB⌝↪ B          (PB picks out a subobject of B, up to isomorphism.)</p><p>(where A and B are the representables for objects A and B and f* is the unique  map from B into the A which sends the point of B to f applied to the point of A)</p><p>Returns the classifier as well as a dictionary of subobjects corresponding to  the parts of the classifier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/datamigrations/Yoneda.jl#L32-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.yoneda-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.yoneda-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Pointwise.FunctorialDataMigrations.yoneda</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Compute the Yoneda embedding of a category C in the category of C-sets.</p><p>Because Catlab privileges copresheaves (C-sets) over presheaves, this is the <em>contravariant</em> Yoneda embedding, i.e., the embedding functor C^op → C-Set.</p><p>The first argument <code>cons</code> is a constructor for the ACSet, such as a struct acset type. If representables have already been computed (which can be expensive), they can be supplied via the <code>cache</code> keyword argument.</p><p>Returns a <code>FinDomFunctor</code> with domain <code>op(C)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/datamigrations/Yoneda.jl#L110-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.functor-Tuple{DataMigrationFunctor}" href="#GATlab.Models.SymbolicModels.functor-Tuple{DataMigrationFunctor}"><code>GATlab.Models.SymbolicModels.functor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gives the underlying schema functor of a data migration  seen as a functor of acset categories.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/datamigrations/FunctorialDataMigrations.jl#L156-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.Chase" href="#Catlab.CategoricalAlgebra.Pointwise.Chase"><code>Catlab.CategoricalAlgebra.Pointwise.Chase</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The chase is an algorithm which subjects a C-Set instance to constraints  expressed in the language of regular logic, called embedded dependencies  (EDs, or &#39;triggers&#39;). </p><p>A morphism S-&gt;T, encodes an embedded dependency. If the pattern  S is matched (via a homomorphism S-&gt;I), we demand there exist a morphism T-&gt;I  (for some database instance I) that makes the triangle commute in order to  satisfy the dependency (if this is not the case, then the trigger is &#39;active&#39;).</p><p>Homomorphisms can merge elements and introduce new ones. The former kind are called &quot;equality generating dependencies&quot; (EGDs) and the latter &quot;tuple generating dependencies&quot; (TGDs). Any homomorphism can be factored into EGD and TGD components by, respectively, restricting the codomain to the image or restricting the domain to the coimage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/Chase.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.Chase.chase-Tuple{ACSet, AbstractDict, Int64}" href="#Catlab.CategoricalAlgebra.Pointwise.Chase.chase-Tuple{ACSet, AbstractDict, Int64}"><code>Catlab.CategoricalAlgebra.Pointwise.Chase.chase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chase(I::ACSet, Σ::AbstractDict, n::Int)</code></pre><p>Chase a C-Set or C-Rel instance given a list of embedded dependencies. This may not terminate, so a bound <code>n</code> on the number of iterations is required.</p><pre><code class="nohighlight hljs">[,]</code></pre><p>ΣS  ⟶ Iₙ ⊕↓      ⋮  (resulting morphism)  ΣT ... Iₙ₊₁</p><p>There is a copy of S and T for each active trigger. A trigger is a map from S into the current instance. What makes it &#39;active&#39; is that there is no morphism from T to I that makes the triangle commute.</p><p>Each iteration constructs the above pushout square. The result is a morphism, so that one can keep track of the provenance of elements in the original CSet instance within the chased result.</p><p>Whether or not the result is due to success or timeout is returned as a boolean flag.</p><p>TODO: this algorithm could be made more efficient by homomorphism caching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/Chase.jl#L252-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Structured cospans.</p><p>This module provides a generic interface for structured cospans with a concrete implementation for attributed C-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/StructuredCospans.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetLeg" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetLeg"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetLeg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Leg of a structured (multi)cospan of acsets in R-form.</p><p>A convenience type that contains the data of an acset transformation, except for the codomain, since that data is already given by the decoration of the R-form structured cospan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/StructuredCospans.jl#L240-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Structured cospan.</p><p>The first type parameter <code>L</code> encodes a functor L: A → X from the base category <code>A</code>, often FinSet, to a category <code>X</code> with &quot;extra structure.&quot; An L-structured cospan is then a cospan in X whose feet are images under L of objects in A. The category X is assumed to have pushouts.</p><p>Structured cospans form a double category with no further assumptions on the functor L. To obtain a symmetric monoidal double category, L must preserve finite coproducts. In practice, L usually has a right adjoint R: X → A, which implies that L preserves all finite colimits. It also allows structured cospans to be constructed more conveniently from an object x in X plus a cospan in A with apex R(x).</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan"><code>StructuredMulticospan</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/StructuredCospans.jl#L58-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Any, Multicospan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}} where L" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Any, Multicospan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}} where L"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Construct structured cospan in R-form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/StructuredCospans.jl#L82-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Multicospan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}, StaticArraysCore.StaticArray{Tuple{2}, T, 1} where T}} where L" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Multicospan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}, StaticArraysCore.StaticArray{Tuple{2}, T, 1} where T}} where L"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Construct structured cospan in L-form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/StructuredCospans.jl#L77-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Object in the category of L-structured cospans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/StructuredCospans.jl#L101-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Structured multicospan.</p><p>A structured multicospan is like a structured cospan except that it may have a number of legs different than two.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospan"><code>StructuredCospan</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/StructuredCospans.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan-Union{Tuple{L}, Tuple{Any, Multicospan}} where L" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan-Union{Tuple{L}, Tuple{Any, Multicospan}} where L"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Construct structured multicospan in R-form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/StructuredCospans.jl#L46-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S, X&lt;:(StructACSet{S})}" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S, X&lt;:(StructACSet{S})}"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetTypes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create types for open attributed C-sets from an attributed C-set type.</p><p>The type parameters of the given acset type should <em>not</em> be instantiated with specific Julia types. This function returns a pair of types, one for objects, a subtype of <a href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredCospanOb"><code>StructuredCospanOb</code></a>, and one for morphisms, a subtype of <a href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.StructuredMulticospan"><code>StructuredMulticospan</code></a>. Both types will have the same type parameters for attribute types as the given acset type.</p><p>Mathematically speaking, this function sets up structured (multi)cospans with a functor <span>$L: A → X$</span> between categories of acsets that creates &quot;discrete acsets.&quot; Such a &quot;discrete acset functor&quot; is a functor that is left adjoint to a certain kind of forgetful functor between categories of acsets, namely one that is a pullback along an inclusion of schemas such that the image of inclusion has no outgoing arrows. For example, the schema inclusion <span>${V} ↪ {E ⇉ V}$</span> has this property but <span>${E} ↪ {E ⇉ V}$</span> does not.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{Type{X}, Vararg{Any}}} where X&lt;:(StructCSet)"><code>OpenCSetTypes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/StructuredCospans.jl#L195-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{Type{X}, Vararg{Any}}} where X&lt;:(StructCSet)" href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{Type{X}, Vararg{Any}}} where X&lt;:(StructCSet)"><code>Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenCSetTypes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create types for open C-sets from a C-set type.</p><p>A special case of <a href="#Catlab.CategoricalAlgebra.Pointwise.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S, X&lt;:(StructACSet{S})}"><code>OpenACSetTypes</code></a>. See there for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/49021371e0329e87f504b8e3359d8ef4ab2adb36/src/categorical_algebra/Pointwise/StructuredCospans.jl#L187-L191">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theories/">« Standard library of theories</a><a class="docs-footer-nextpage" href="../graphs/">Graphs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 30 July 2025 23:05">Wednesday 30 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
