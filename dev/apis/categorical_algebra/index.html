<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Categorical algebra · Catlab.jl</title><meta name="title" content="Categorical algebra · Catlab.jl"/><meta property="og:title" content="Categorical algebra · Catlab.jl"/><meta property="twitter:title" content="Categorical algebra · Catlab.jl"/><meta name="description" content="Documentation for Catlab.jl."/><meta property="og:description" content="Documentation for Catlab.jl."/><meta property="twitter:description" content="Documentation for Catlab.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catlab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Seven Sketches in Compositionality</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/sketches/partitions/">Partitions</a></li><li><a class="tocitem" href="../../generated/sketches/preorders/">Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/meets/">Meets in Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/smc/">Symmetric Monoidal Categories</a></li><li><a class="tocitem" href="../../generated/sketches/cat_elements/">The Category of Elements</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphs/graphs/">The Category of Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/graphs_label/">Labeled Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/subgraphs/">Algebra of subgraphs</a></li></ul></li><li><span class="tocitem">Categorical Algebra</span></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Wiring Diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/wd_cset/">Wiring Diagrams as Attributed C-Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/graphviz_graphs/">Drawing graphs in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li class="is-active"><a class="tocitem" href>Categorical algebra</a><ul class="internal"><li><a class="tocitem" href="#Sets-and-Relations"><span>Sets and Relations</span></a></li><li><a class="tocitem" href="#Free-Diagrams,-Limits,-and-Colimits"><span>Free Diagrams, Limits, and Colimits</span></a></li><li><a class="tocitem" href="#Categories"><span>Categories</span></a></li><li><a class="tocitem" href="#Acsets"><span>Acsets</span></a></li></ul></li><li><a class="tocitem" href="../graphs/">Graphs</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li><a class="tocitem" href="../programs/">Programs</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../../devdocs/style/">Style Guide for AlgebraicJulia</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Categorical algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Categorical algebra</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/Catlab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/main/docs/src/apis/categorical_algebra.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="categorical_algebra"><a class="docs-heading-anchor" href="#categorical_algebra">Categorical algebra</a><a id="categorical_algebra-1"></a><a class="docs-heading-anchor-permalink" href="#categorical_algebra" title="Permalink"></a></h1><h2 id="Sets-and-Relations"><a class="docs-heading-anchor" href="#Sets-and-Relations">Sets and Relations</a><a id="Sets-and-Relations-1"></a><a class="docs-heading-anchor-permalink" href="#Sets-and-Relations" title="Permalink"></a></h2><p>The following APIs implement FinSet, the category of Finite Sets (actually the skeleton of FinSet). The objects of this category are natural numbers where <code>n</code> represents a set with <code>n</code> elements. The morphisms are functions between such sets. We use the skeleton of FinSet in order to ensure that all sets are finite and morphisms can be stored using lists of integers. Finite relations are built out of FinSet and can be used to do some relational algebra.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets" href="#Catlab.CategoricalAlgebra.Sets"><code>Catlab.CategoricalAlgebra.Sets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Category of (possibly infinite) sets and functions.</p><p>This module defines generic types for the category of sets (<a href="#Catlab.CategoricalAlgebra.Sets.SetOb"><code>SetOb</code></a>, <a href="#Catlab.CategoricalAlgebra.Sets.SetFunction"><code>SetFunction</code></a>), as well as a few basic concrete types, such as a wrapper type to view Julia types as sets (<a href="#Catlab.CategoricalAlgebra.Sets.TypeSet"><code>TypeSet</code></a>). Extensive support for finite sets is provided by another module, <a href="@ref"><code>FinSets</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Sets.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.ConstantFunction" href="#Catlab.CategoricalAlgebra.Sets.ConstantFunction"><code>Catlab.CategoricalAlgebra.Sets.ConstantFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function in <strong>Set</strong> taking a constant value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Sets.jl#L132-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.PredicatedSet" href="#Catlab.CategoricalAlgebra.Sets.PredicatedSet"><code>Catlab.CategoricalAlgebra.Sets.PredicatedSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Set defined by a predicate (boolean-valued function) on a Julia data type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Sets.jl#L149-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.SetFunction" href="#Catlab.CategoricalAlgebra.Sets.SetFunction"><code>Catlab.CategoricalAlgebra.Sets.SetFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for morphism in the category <strong>Set</strong>.</p><p>Every instance of <code>SetFunction{&lt;:SetOb{T},&lt;:SetOb{T′}}</code> is callable with elements of type <code>T</code>, returning an element of type <code>T′</code>.</p><p>Note: This type would be better called simply <code>Function</code> but that name is already taken by the base Julia type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Sets.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.SetOb" href="#Catlab.CategoricalAlgebra.Sets.SetOb"><code>Catlab.CategoricalAlgebra.Sets.SetOb</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for object in the category <strong>Set</strong>.</p><p>The type parameter <code>T</code> is the element type of the set.</p><p>Note: This type is more abstract than the built-in Julia types <code>AbstractSet</code> and <code>Set</code>, which are intended for data structures for finite sets. Those are encompassed by the subtype <a href="@ref"><code>FinSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Sets.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.TypeSet" href="#Catlab.CategoricalAlgebra.Sets.TypeSet"><code>Catlab.CategoricalAlgebra.Sets.TypeSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Julia data type regarded as a set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Sets.jl#L35-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.Ob-Union{Tuple{TypeCat{T}}, Tuple{T}} where T" href="#AlgebraicInterfaces.Ob-Union{Tuple{TypeCat{T}}, Tuple{T}} where T"><code>AlgebraicInterfaces.Ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Forgetful functor Ob: Cat → Set.</p><p>Sends a category to its set of objects and a functor to its object map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Sets.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets" href="#Catlab.CategoricalAlgebra.FinSets"><code>Catlab.CategoricalAlgebra.FinSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The category of finite sets and functions, and its skeleton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinDomFunction" href="#Catlab.CategoricalAlgebra.FinSets.FinDomFunction"><code>Catlab.CategoricalAlgebra.FinSets.FinDomFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function out of a finite set.</p><p>This class of functions is convenient because it is exactly the class that can be represented explicitly by a vector of values from the codomain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L212-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinFunction" href="#Catlab.CategoricalAlgebra.FinSets.FinFunction"><code>Catlab.CategoricalAlgebra.FinSets.FinFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function between finite sets.</p><p>The function can be defined implicitly by an arbitrary Julia function, in which case it is evaluated lazily, or explictly by a vector of integers. In the vector representation, the function (1↦1, 2↦3, 3↦2, 4↦3), for example, is represented by the vector [1,3,2,3].</p><p>FinFunctions can be constructed with or without an explicitly provided codomain. If a codomain is provided, by default the constructor checks it is valid.</p><p>This type is mildly generalized by <a href="#Catlab.CategoricalAlgebra.FinSets.FinDomFunction"><code>FinDomFunction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L168-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinSet" href="#Catlab.CategoricalAlgebra.FinSets.FinSet"><code>Catlab.CategoricalAlgebra.FinSets.FinSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Finite set.</p><p>A finite set has abstract type <code>FinSet{S,T}</code>. The second type parameter <code>T</code> is the element type of the set and the first parameter <code>S</code> is the collection type, which can be a subtype of <code>AbstractSet</code> or another Julia collection type. In addition, the skeleton of the category <strong>FinSet</strong> is the important special case <code>S = Int</code>. The set <span>${1,…,n}$</span> is represented by the object <code>FinSet(n)</code> of type <code>FinSet{Int,Int}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.HashJoin" href="#Catlab.CategoricalAlgebra.FinSets.HashJoin"><code>Catlab.CategoricalAlgebra.FinSets.HashJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Hash_join">Hash join</a> algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L785-L787">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm" href="#Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm"><code>Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for limit of cospan or multicospan with feet being finite sets.</p><p>In the context of relational databases, such limits are called <em>joins</em>. The trivial join algorithm is <a href="#Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin"><code>NestedLoopJoin</code></a>, which is algorithmically equivalent to the generic algorithm <code>ComposeProductEqualizer</code>. The algorithms <a href="#Catlab.CategoricalAlgebra.FinSets.HashJoin"><code>HashJoin</code></a> and <a href="#Catlab.CategoricalAlgebra.FinSets.SortMergeJoin"><code>SortMergeJoin</code></a> are usually much faster. If you are unsure what algorithm to pick, use <a href="#Catlab.CategoricalAlgebra.FinSets.SmartJoin"><code>SmartJoin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L654-L662">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin" href="#Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin"><code>Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Nested_loop_join">Nested-loop join</a> algorithm.</p><p>This is the naive algorithm for computing joins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L707-L711">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SmartJoin" href="#Catlab.CategoricalAlgebra.FinSets.SmartJoin"><code>Catlab.CategoricalAlgebra.FinSets.SmartJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-algorithm for joins that attempts to pick an appropriate algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L664-L666">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SortMergeJoin" href="#Catlab.CategoricalAlgebra.FinSets.SortMergeJoin"><code>Catlab.CategoricalAlgebra.FinSets.SortMergeJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Sort-merge_join">Sort-merge join</a> algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L732-L734">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SubFinSet" href="#Catlab.CategoricalAlgebra.FinSets.SubFinSet"><code>Catlab.CategoricalAlgebra.FinSets.SubFinSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Subset of a finite set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L1402-L1404">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SubOpBoolean" href="#Catlab.CategoricalAlgebra.FinSets.SubOpBoolean"><code>Catlab.CategoricalAlgebra.FinSets.SubOpBoolean</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm to compute subobject operations using elementwise boolean logic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L1455-L1457">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.TabularLimit" href="#Catlab.CategoricalAlgebra.FinSets.TabularLimit"><code>Catlab.CategoricalAlgebra.FinSets.TabularLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Limit of finite sets viewed as a table.</p><p>Any limit of finite sets can be canonically viewed as a table (<a href="#Catlab.CategoricalAlgebra.FinSets.TabularSet"><code>TabularSet</code></a>) whose columns are the legs of the limit cone and whose rows correspond to elements of the limit object. To construct this table from an already computed limit, call <code>TabularLimit(::AbstractLimit; ...)</code>. The column names of the table are given by the optional argument <code>names</code>.</p><p>In this tabular form, applying the universal property of the limit is trivial since it is just tupling. Thus, this representation can be useful when the original limit algorithm does not support efficient application of the universal property. On the other hand, this representation has the disadvantage of generally making the element type of the limit set more complicated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L1041-L1055">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.TabularSet" href="#Catlab.CategoricalAlgebra.FinSets.TabularSet"><code>Catlab.CategoricalAlgebra.FinSets.TabularSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Finite set whose elements are rows of a table.</p><p>The underlying table should be compliant with Tables.jl. For the sake of uniformity, the rows are provided as named tuples, which assumes that the table is not &quot;extremely wide&quot;. This should not be a major limitation in practice but see the Tables.jl documentation for further discussion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L85-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.VarFunction" href="#Catlab.CategoricalAlgebra.FinSets.VarFunction"><code>Catlab.CategoricalAlgebra.FinSets.VarFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Data type of a map out of a set of attribute variables</p><p>Currently, domains are FinSet{Int} and codomains are expected to be FinSet{Int}. This could be generalized to being FinSet{Symbol} to allow for symbolic attributes. (Likewise, AttrVars will have to wrap Any rather than Int)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L313-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.is_indexed-Tuple{SetFunction}" href="#Catlab.CategoricalAlgebra.FinSets.is_indexed-Tuple{SetFunction}"><code>Catlab.CategoricalAlgebra.FinSets.is_indexed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Whether the given function is indexed, i.e., supports efficient preimages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L440-L442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.preimage-Tuple{Catlab.CategoricalAlgebra.Sets.IdentityFunction, Any}" href="#Catlab.CategoricalAlgebra.FinSets.preimage-Tuple{Catlab.CategoricalAlgebra.Sets.IdentityFunction, Any}"><code>Catlab.CategoricalAlgebra.FinSets.preimage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The preimage (inverse image) of the value y in the codomain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinSets.jl#L447-L449">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations" href="#Catlab.CategoricalAlgebra.FinRelations"><code>Catlab.CategoricalAlgebra.FinRelations</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The category of finite sets and relations, and its skeleton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinRelations.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.BoolRig" href="#Catlab.CategoricalAlgebra.FinRelations.BoolRig"><code>Catlab.CategoricalAlgebra.FinRelations.BoolRig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The rig of booleans.</p><p>This struct is needed because in base Julia, the product of booleans is another boolean, but the sum of booleans is coerced to an integer: <code>true + true == 2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinRelations.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRel" href="#Catlab.CategoricalAlgebra.FinRelations.FinRel"><code>Catlab.CategoricalAlgebra.FinRelations.FinRel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object in the category of finite sets and relations.</p><p>See also: <a href="@ref"><code>FinSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinRelations.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelation" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelation"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Binary relation between finite sets.</p><p>A morphism in the category of finite sets and relations. The relation can be represented implicitly by an arbitrary Julia function mapping pairs of elements to booleans or explicitly by a matrix (dense or sparse) taking values in the rig of booleans (<a href="#Catlab.CategoricalAlgebra.FinRelations.BoolRig"><code>BoolRig</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinRelations.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Relation in FinRel defined by a callable Julia object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinRelations.jl#L73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Relation in FinRel represented by a boolean matrix.</p><p>Boolean matrices are also known as logical matrices or relation matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinRelations.jl#L90-L94">source</a></section></article><h2 id="Free-Diagrams,-Limits,-and-Colimits"><a class="docs-heading-anchor" href="#Free-Diagrams,-Limits,-and-Colimits">Free Diagrams, Limits, and Colimits</a><a id="Free-Diagrams,-Limits,-and-Colimits-1"></a><a class="docs-heading-anchor-permalink" href="#Free-Diagrams,-Limits,-and-Colimits" title="Permalink"></a></h2><p>The following modules define free diagrams in an arbitrary category and specify limit and colimit cones over said diagrams. Thes constructions enjoy the fullest support for FinSet and are used below to define presheaf categories as C-Sets. The general idea of these functions is that you set up a limit computation by specifying a diagram and asking for a limit or colimit cone, which is returned as a struct containing the apex object and the leg morphisms. This cone structure can be queried using the functions <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}"><code>apex</code></a> and <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>legs</code></a>. Julia&#39;s multiple dispatch feature is heavily used to specialize limit and colimit computations for various diagram shapes like product/coproduct and equalizer/coequalizer. As a consumer of this API, it is highly recommended that you use multiple dispatch to specialize your code on the diagram shape whenever possible.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams" href="#Catlab.CategoricalAlgebra.FreeDiagrams"><code>Catlab.CategoricalAlgebra.FreeDiagrams</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Free diagrams in a category.</p><p>A <a href="https://ncatlab.org/nlab/show/free+diagram">free diagram</a> in a category is a diagram whose shape is a free category. Examples include the empty diagram, pairs of objects, discrete diagrams, parallel pairs, composable pairs, and spans and cospans. Limits and colimits are most commonly taken over free diagrams.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A free diagram with a bipartite structure.</p><p>Such diagrams include most of the fixed shapes, such as spans, cospans, and parallel morphisms. They are also the generic shape of diagrams for limits and colimits arising from undirected wiring diagrams. For limits, the boxes correspond to vertices in <span>$V₁$</span> and the junctions to vertices in <span>$V₂$</span>. Colimits are dual.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L330-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram-Union{Tuple{Functor{&lt;:Category{Int64, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where Hom}}, Tuple{Hom}, Tuple{Ob}} where {Ob, Hom}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram-Union{Tuple{Functor{&lt;:Category{Int64, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where Hom}}, Tuple{Hom}, Tuple{Ob}} where {Ob, Hom}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert a free diagram to a bipartite free diagram.</p><p>Reduce a free diagram to a free bipartite diagram with the same limit (the default, <code>colimit=false</code>) or the same colimit (<code>colimit=true</code>). The reduction is essentially the same in both cases, except for the choice of where to put isolated vertices, where we follow the conventions described at <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}"><code>cone_objects</code></a> and <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}"><code>cocone_objects</code></a>. The resulting object is a bipartite free diagram equipped with maps from the vertices of the bipartite diagram to the vertices of the original diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L430-L440">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Composable morphisms in a category.</p><p>Composable morphisms are a sequence of morphisms in a category that form a path in the underlying graph of the category.</p><p>For the common special case of two morphisms, see <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair"><code>ComposablePair</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L283-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of composable morphisms in a category.</p><p><a href="https://ncatlab.org/nlab/show/composable+pair">Composable pairs</a> are a common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms"><code>ComposableMorphisms</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L302-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Cospan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Cospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Cospan of morphisms in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan"><code>Multicospan</code></a>. See also <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Span</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L188-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Discrete diagram: a diagram with no non-identity morphisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L69-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for free diagram of fixed shape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L60-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multicospan of morphisms in a category.</p><p>A multicospan is like a <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Cospan</code></a> except that it may have a number of legs different than two. A limit of this shape is a pullback.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L164-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Multispan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multispan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Multispan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multispan of morphisms in a category.</p><p>A <a href="https://ncatlab.org/nlab/show/multispan">multispan</a> is like a <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Span</code></a> except that it may have a number of legs different than two. A colimit of this shape is a pushout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parallel morphims in a category.</p><p><a href="https://ncatlab.org/nlab/show/parallel+morphisms">Parallel morphisms</a> are just morphisms with the same domain and codomain. A (co)limit of this shape is a (co)equalizer.</p><p>For the common special case of two morphisms, see <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair"><code>ParallelPair</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L229-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of parallel morphisms in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms"><code>ParallelMorphisms</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L249-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Span" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Span</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Span of morphims in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multispan"><code>Multispan</code></a>. See also <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Cospan</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.apex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apex of multispan or multicospan.</p><p>The apex of a multi(co)span is the object that is the (co)domain of all the <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>legs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L131-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs-Tuple{Multispan, Any}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs-Tuple{Multispan, Any}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bundle together legs of a multi(co)span.</p><p>For example, calling <code>bundle_legs(span, SVector((1,2),(3,4)))</code> on a multispan with four legs gives a span whose left leg bundles legs 1 and 2 and whose right leg bundles legs 3 and 4. Note that in addition to bundling, this function can also permute legs and discard them.</p><p>The bundling is performed using the universal property of (co)products, which assumes that these (co)limits exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L206-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Objects in diagram that will have explicit legs in colimit cocone.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}"><code>cone_objects</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Objects in diagram that will have explicit legs in limit cone.</p><p>In category theory, it is common practice to elide legs of limit cones that can be computed from other legs, especially for diagrams of certain fixed shapes. For example, when it taking a pullback (the limit of a cospan), the limit object is often treated as having two projections, rather than three. This function encodes such conventions by listing the objects in the diagram that will have corresponding legs in the limit object created by Catlab.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}"><code>cocone_objects</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L38-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type" href="#Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type"><code>Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given a diagram in a category <span>$C$</span>, return Julia type of objects and morphisms in <span>$C$</span> as a tuple type of form <span>$Tuple{Ob,Hom}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.feet-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.feet-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.feet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Feet of multispan or multicospan.</p><p>The feet of a multispan are the codomains of the <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>legs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.left-Tuple{Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.left-Tuple{Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.left</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Left leg of span or cospan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L150-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.legs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Legs of multispan or multicospan.</p><p>The legs are the morphisms comprising the multi(co)span.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.right-Tuple{Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.right-Tuple{Multispan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.right</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Right leg of span or cospan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FreeDiagrams.jl#L154-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits" href="#Catlab.CategoricalAlgebra.Limits"><code>Catlab.CategoricalAlgebra.Limits</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Limits and colimits in a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.AbstractColimit" href="#Catlab.CategoricalAlgebra.Limits.AbstractColimit"><code>Catlab.CategoricalAlgebra.Limits.AbstractColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for colimit in a category.</p><p>The standard concrete subtype is <a href="#Catlab.CategoricalAlgebra.Limits.Colimit"><code>Colimit</code></a>, although for computational reasons certain categories may use different subtypes to include extra data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.AbstractLimit" href="#Catlab.CategoricalAlgebra.Limits.AbstractLimit"><code>Catlab.CategoricalAlgebra.Limits.AbstractLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for limit in a category.</p><p>The standard concrete subtype is <a href="#Catlab.CategoricalAlgebra.Limits.Limit"><code>Limit</code></a>, although for computational reasons certain categories may use different subtypes to include extra data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.Colimit" href="#Catlab.CategoricalAlgebra.Limits.Colimit"><code>Catlab.CategoricalAlgebra.Limits.Colimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Colimit in a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L93-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm" href="#Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm"><code>Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for computing colimits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L113-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer" href="#Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer"><code>Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute pushout by composing a coproduct with a coequalizer.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer"><code>ComposeProductEqualizer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L525-L529">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer" href="#Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer"><code>Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute pullback by composing a product with an equalizer.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer"><code>ComposeCoproductCoequalizer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L491-L495">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.Limit" href="#Catlab.CategoricalAlgebra.Limits.Limit"><code>Catlab.CategoricalAlgebra.Limits.Limit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Limit in a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L50-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.LimitAlgorithm" href="#Catlab.CategoricalAlgebra.Limits.LimitAlgorithm"><code>Catlab.CategoricalAlgebra.Limits.LimitAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for computing limits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L70-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.SpecializeColimit" href="#Catlab.CategoricalAlgebra.Limits.SpecializeColimit"><code>Catlab.CategoricalAlgebra.Limits.SpecializeColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-algorithm that reduces general colimits to common special cases.</p><p>Dual to <a href="#Catlab.CategoricalAlgebra.Limits.SpecializeLimit"><code>SpecializeLimit</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L431-L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.SpecializeLimit" href="#Catlab.CategoricalAlgebra.Limits.SpecializeLimit"><code>Catlab.CategoricalAlgebra.Limits.SpecializeLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-algorithm that reduces general limits to common special cases.</p><p>Reduces limits of free diagrams that happen to be discrete to products. If this fails, fall back to the given algorithm (if any).</p><p>TODO: Reduce free diagrams that are (multi)cospans to (wide) pullbacks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L398-L405">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit" href="#Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit"><code>Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute a colimit by reducing the diagram to a free bipartite diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L593-L595">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit" href="#Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit"><code>Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute a limit by reducing the diagram to a free bipartite diagram.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L557-L559">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.coimage-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.coimage-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.coimage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>https://en.wikipedia.org/wiki/Coimage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.colimit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Colimit of a diagram.</p><p>To define colimits in a category with objects <code>Ob</code>, override the method <code>colimit(::FreeDiagram{Ob})</code> for general colimits or <code>colimit(::D)</code> with suitable type <code>D &lt;: FixedShapeFreeDiagram{Ob}</code> for colimits of specific shape, such as coproducts or coequalizers.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}"><code>limit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L132-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.epi_mono-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.epi_mono-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.epi_mono</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The image and coimage are isomorphic. We get this isomorphism using univeral properties.</p><pre><code class="nohighlight hljs">  CoIm′ ╌╌&gt; I ↠ CoIm
    ┆ ⌟     |
    v       v
    I   ⟶  R ↩ Im
    |       ┆
    v    ⌜  v
    R ╌╌&gt; Im′</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L275-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.image-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.image-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.image</code></a> — <span class="docstring-category">Method</span></header><section><div><p>https://en.wikipedia.org/wiki/Image<em>(category</em>theory)#Second_definition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.limit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Limit of a diagram.</p><p>To define limits in a category with objects <code>Ob</code>, override the method <code>limit(::FreeDiagram{Ob})</code> for general limits or <code>limit(::D)</code> with suitable type <code>D &lt;: FixedShapeFreeDiagram{Ob}</code> for limits of specific shape, such as products or equalizers.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}"><code>colimit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L120-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.pullback-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.pullback-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.pullback</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pullback of a pair of morphisms with common codomain.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::Cospan{T})</code> and/or <code>limit(::Multicospan{T})</code> or, if you have already implemented products and equalizers, rely on the default implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L216-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.pushout-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.pushout-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.pushout</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pushout of a pair of morphisms with common domain.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::Span{T})</code> and/or <code>colimit(::Multispan{T})</code> or, if you have already implemented coproducts and coequalizers, rely on the default implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L225-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.coequalizer-Tuple{Any, Any}" href="#Catlab.Theories.coequalizer-Tuple{Any, Any}"><code>Catlab.Theories.coequalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coequalizer of morphisms with common domain and codomain.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::ParallelPair{T})</code> or <code>colimit(::ParallelMorphisms{T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L208-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.copair-Tuple{Any, Any}" href="#Catlab.Theories.copair-Tuple{Any, Any}"><code>Catlab.Theories.copair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Copairing of morphisms: universal property of coproducts/pushouts.</p><p>To implement for coproducts of type <code>T</code>, define the method <code>universal(::BinaryCoproduct{T}, ::Cospan{T})</code> and/or <code>universal(::Coproduct{T}, ::Multicospan{T})</code> and similarly for pushouts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L247-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.coproduct-Tuple{Any, Any}" href="#Catlab.Theories.coproduct-Tuple{Any, Any}"><code>Catlab.Theories.coproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coproduct of objects.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::ObjectPair{T})</code> and/or <code>colimit(::DiscreteDiagram{T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L192-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.create-Tuple{T} where T" href="#Catlab.Theories.create-Tuple{T} where T"><code>Catlab.Theories.create</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unique morphism out of an initial object.</p><p>To implement for a type <code>T</code>, define the method <code>universal(::Initial{T}, ::SMulticospan{0,T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.delete-Tuple{T} where T" href="#Catlab.Theories.delete-Tuple{T} where T"><code>Catlab.Theories.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unique morphism into a terminal object.</p><p>To implement for a type <code>T</code>, define the method <code>universal(::Terminal{T}, ::SMultispan{0,T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.equalizer-Tuple{Any, Any}" href="#Catlab.Theories.equalizer-Tuple{Any, Any}"><code>Catlab.Theories.equalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Equalizer of morphisms with common domain and codomain.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::ParallelPair{T})</code> and/or <code>limit(::ParallelMorphisms{T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L200-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.factorize-Tuple{Equalizer, Any}" href="#Catlab.Theories.factorize-Tuple{Equalizer, Any}"><code>Catlab.Theories.factorize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Factor morphism through (co)equalizer, via the universal property.</p><p>To implement for equalizers of type <code>T</code>, define the method <code>universal(::Equalizer{T}, ::SMultispan{1,T})</code>. For coequalizers of type <code>T</code>, define the method <code>universal(::Coequalizer{T}, ::SMulticospan{1,T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L260-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.initial-Tuple{Type}" href="#Catlab.Theories.initial-Tuple{Type}"><code>Catlab.Theories.initial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initial object.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::EmptyDiagram{T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.pair-Tuple{Any, Any}" href="#Catlab.Theories.pair-Tuple{Any, Any}"><code>Catlab.Theories.pair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pairing of morphisms: universal property of products/pullbacks.</p><p>To implement for products of type <code>T</code>, define the method <code>universal(::BinaryProduct{T}, ::Span{T})</code> and/or <code>universal(::Product{T}, ::Multispan{T})</code> and similarly for pullbacks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L234-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.product-Tuple{Any, Any}" href="#Catlab.Theories.product-Tuple{Any, Any}"><code>Catlab.Theories.product</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Product of objects.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::ObjectPair{T})</code> and/or <code>limit(::DiscreteDiagram{T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.terminal-Tuple{Type}" href="#Catlab.Theories.terminal-Tuple{Type}"><code>Catlab.Theories.terminal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Terminal object.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::EmptyDiagram{T})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.Theories.universal" href="#Catlab.Theories.universal"><code>Catlab.Theories.universal</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Universal property of (co)limits.</p><p>Compute the morphism whose existence and uniqueness is guaranteed by the universal property of (co)limits.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}"><code>limit</code></a>, <a href="#Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}"><code>colimit</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L144-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define cartesian monoidal structure using limits.</p><p>Implements an instance of <a href="@ref"><code>ThCartesianCategory</code></a> assuming that finite products have been implemented following the limits interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L296-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define cocartesian monoidal structure using colimits.</p><p>Implements an instance of <a href="@ref"><code>ThCocartesianCategory</code></a> assuming that finite coproducts have been implemented following the colimits interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Limits.jl#L350-L355">source</a></section></article><h2 id="Categories"><a class="docs-heading-anchor" href="#Categories">Categories</a><a id="Categories-1"></a><a class="docs-heading-anchor-permalink" href="#Categories" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories" href="#Catlab.CategoricalAlgebra.Categories"><code>Catlab.CategoricalAlgebra.Categories</code></a> — <span class="docstring-category">Module</span></header><section><div><p>2-category of categories, functors, and natural transformations.</p><p>Categories in mathematics appear in the large, often as categories of sets with extra structure, and in the small, as algebraic structures that generalize groups, monoids, preorders, and graphs. This division manifests in Catlab as well. Large categories (in spirit, if not in the <a href="https://ncatlab.org/nlab/show/large+category">technical sense</a>) occur throughout Catlab as <code>@instance</code>s of the theory of categories. For computational reasons, small categories are usually presented by generators and relations.</p><p>This module provides a minimal interface to accomodate both situations. Category instances are supported through the wrapper type <a href="#Catlab.CategoricalAlgebra.Categories.TypeCat"><code>TypeCat</code></a>. Finitely presented categories are provided by another module, <a href="@ref"><code>FinCats</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Cat" href="#Catlab.CategoricalAlgebra.Categories.Cat"><code>Catlab.CategoricalAlgebra.Categories.Cat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Alias for <a href="#Catlab.CategoricalAlgebra.Categories.Category"><code>Category</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L59-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.CatSize" href="#Catlab.CategoricalAlgebra.Categories.CatSize"><code>Catlab.CategoricalAlgebra.Categories.CatSize</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Size of a category, used for dispatch and subtyping purposes.</p><p>A <a href="#Catlab.CategoricalAlgebra.Categories.Category"><code>Category</code></a> type having a particular <code>CatSize</code> means that categories of that type are <em>at most</em> that large.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Category" href="#Catlab.CategoricalAlgebra.Categories.Category"><code>Catlab.CategoricalAlgebra.Categories.Category</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for a category.</p><p>The objects and morphisms in the category have Julia types <code>Ob</code> and <code>Hom</code>, respectively. Note that these types do <em>not</em> necessarily form an <code>@instance</code> of the theory of categories, as they may not meaningfully form a category outside the context of this object. For example, a finite category regarded as a reflexive graph with a composition operation might have type <code>Cat{Int,Int}</code>, where the objects and morphisms are numerical identifiers for vertices and edges in the graph.</p><p>The basic operations available in any category are: <a href="#AlgebraicInterfaces.dom-Tuple{Category, Any}"><code>dom</code></a>, <a href="#AlgebraicInterfaces.codom-Tuple{Category, Any}"><code>codom</code></a>, <a href="#AlgebraicInterfaces.id-Tuple{Category, Any}"><code>id</code></a>, <a href="#AlgebraicInterfaces.compose-Tuple{Category, Vararg{Any}}"><code>compose</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L44-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.CompositeFunctor" href="#Catlab.CategoricalAlgebra.Categories.CompositeFunctor"><code>Catlab.CategoricalAlgebra.Categories.CompositeFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Composite of functors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L164-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Functor" href="#Catlab.CategoricalAlgebra.Categories.Functor"><code>Catlab.CategoricalAlgebra.Categories.Functor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for a functor between categories.</p><p>A functor has a domain and a codomain (<a href="#AlgebraicInterfaces.dom-Tuple{Category, Any}"><code>dom</code></a> and <a href="#AlgebraicInterfaces.codom-Tuple{Category, Any}"><code>codom</code></a>), which are categories, and object and morphism maps, which can be evaluated using <a href="#Catlab.CategoricalAlgebra.Categories.ob_map-Tuple{Functor, Any}"><code>ob_map</code></a> and <a href="#Catlab.CategoricalAlgebra.Categories.hom_map-Tuple{Functor, Any}"><code>hom_map</code></a>. The functor object can also be called directly when the objects and morphisms have distinct Julia types. This is sometimes but not always the case (see <a href="#Catlab.CategoricalAlgebra.Categories.Category"><code>Category</code></a>), so when writing generic code one should prefer the <code>ob_map</code> and <code>hom_map</code> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L128-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.FunctorCallable" href="#Catlab.CategoricalAlgebra.Categories.FunctorCallable"><code>Catlab.CategoricalAlgebra.Categories.FunctorCallable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Functor defined by two Julia callables, an object map and a morphism map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L210-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.IdentityFunctor" href="#Catlab.CategoricalAlgebra.Categories.IdentityFunctor"><code>Catlab.CategoricalAlgebra.Categories.IdentityFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Identity functor on a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L147-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.LargeCatSize" href="#Catlab.CategoricalAlgebra.Categories.LargeCatSize"><code>Catlab.CategoricalAlgebra.Categories.LargeCatSize</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Size of a large category, such as Set.</p><p>To the extent that they form a category, we regard Julia types and functions (<a href="#Catlab.CategoricalAlgebra.Categories.TypeCat"><code>TypeCat</code></a>) as forming a large category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.OppositeCat" href="#Catlab.CategoricalAlgebra.Categories.OppositeCat"><code>Catlab.CategoricalAlgebra.Categories.OppositeCat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Opposite category, where morphism are reversed.</p><p>Call <code>op(::Cat)</code> instead of directly instantiating this type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L356-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.OppositeFunctor" href="#Catlab.CategoricalAlgebra.Categories.OppositeFunctor"><code>Catlab.CategoricalAlgebra.Categories.OppositeFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Opposite functor, given by the same mapping between opposite categories.</p><p>Call <code>op(::Functor)</code> instead of directly instantiating this type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L373-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Transformation" href="#Catlab.CategoricalAlgebra.Categories.Transformation"><code>Catlab.CategoricalAlgebra.Categories.Transformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for a natural transformation between functors.</p><p>A natural transformation <span>$α: F ⇒ G$</span> has a domain <span>$F$</span> and codomain <span>$G$</span> (<a href="#AlgebraicInterfaces.dom-Tuple{Category, Any}"><code>dom</code></a> and <a href="#AlgebraicInterfaces.codom-Tuple{Category, Any}"><code>codom</code></a>), which are functors <span>$F,G: C → D$</span> having the same domain <span>$C$</span> and codomain <span>$D$</span>. The transformation consists of a component <span>$αₓ: Fx → Gx$</span> in <span>$D$</span> for each object <span>$x ∈ C$</span>, accessible using <a href="#Catlab.CategoricalAlgebra.Categories.component"><code>component</code></a> or indexing notation (<code>Base.getindex</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L235-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.TypeCat" href="#Catlab.CategoricalAlgebra.Categories.TypeCat"><code>Catlab.CategoricalAlgebra.Categories.TypeCat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of Julia types regarded as a category.</p><p>The Julia types should form an <code>@instance</code> of the theory of categories (<code>Theories.Category</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.codom-Tuple{Category, Any}" href="#AlgebraicInterfaces.codom-Tuple{Category, Any}"><code>AlgebraicInterfaces.codom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Codomain of morphism in category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L84-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.compose-Tuple{Category, Vararg{Any}}" href="#AlgebraicInterfaces.compose-Tuple{Category, Vararg{Any}}"><code>AlgebraicInterfaces.compose</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compose morphisms in a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L92-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.dom-Tuple{Category, Any}" href="#AlgebraicInterfaces.dom-Tuple{Category, Any}"><code>AlgebraicInterfaces.dom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Domain of morphism in category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L80-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.hom" href="#AlgebraicInterfaces.hom"><code>AlgebraicInterfaces.hom</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Coerce or look up morphism in category.</p><p>See also: <a href="#AlgebraicInterfaces.ob"><code>ob</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.id-Tuple{Category, Any}" href="#AlgebraicInterfaces.id-Tuple{Category, Any}"><code>AlgebraicInterfaces.id</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Identity morphism on object in category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L88-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.ob" href="#AlgebraicInterfaces.ob"><code>AlgebraicInterfaces.ob</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Coerce or look up object in category.</p><p>Converts the input to an object in the category, which should be of type <code>Ob</code> in a category of type <code>Cat{Ob,Hom}</code>. How this works depends on the category, but a common case is to look up objects, which might be integers or GAT expressions, by their human-readable name, usually a symbol.</p><p>See also: <a href="#AlgebraicInterfaces.hom"><code>hom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L63-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.co" href="#Catlab.CategoricalAlgebra.Categories.co"><code>Catlab.CategoricalAlgebra.Categories.co</code></a> — <span class="docstring-category">Function</span></header><section><div><p>2-cell dual of a 2-category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L434-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.codom_ob-Tuple{Transformation}" href="#Catlab.CategoricalAlgebra.Categories.codom_ob-Tuple{Transformation}"><code>Catlab.CategoricalAlgebra.Categories.codom_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Codomain object of natural transformation.</p><p>Given <span>$α: F ⇒ G: C → D$</span>, this function returns <span>$D$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L257-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.component" href="#Catlab.CategoricalAlgebra.Categories.component"><code>Catlab.CategoricalAlgebra.Categories.component</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Component of natural transformation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L245-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.dom_ob-Tuple{Transformation}" href="#Catlab.CategoricalAlgebra.Categories.dom_ob-Tuple{Transformation}"><code>Catlab.CategoricalAlgebra.Categories.dom_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Domain object of natural transformation.</p><p>Given <span>$α: F ⇒ G: C → D$</span>, this function returns <span>$C$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L251-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.hom_map-Tuple{Functor, Any}" href="#Catlab.CategoricalAlgebra.Categories.hom_map-Tuple{Functor, Any}"><code>Catlab.CategoricalAlgebra.Categories.hom_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate functor on morphism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L143-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.is_hom_equal-Tuple{Category, Any, Any}" href="#Catlab.CategoricalAlgebra.Categories.is_hom_equal-Tuple{Category, Any, Any}"><code>Catlab.CategoricalAlgebra.Categories.is_hom_equal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Are two morphisms in a category equal?</p><p>By default, just checks for equality of Julia objects using <span>$==$</span>. In some categories, checking equality of morphisms may involve nontrivial reasoning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.ob_map-Tuple{Functor, Any}" href="#Catlab.CategoricalAlgebra.Categories.ob_map-Tuple{Functor, Any}"><code>Catlab.CategoricalAlgebra.Categories.ob_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate functor on object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L139-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Stdlib.StdModels.op-Tuple{Category}" href="#GATlab.Stdlib.StdModels.op-Tuple{Category}"><code>GATlab.Stdlib.StdModels.op</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Oppositization 2-functor.</p><p>The oppositization endo-2-functor on Cat, sending a category to its opposite, is covariant on objects and morphisms and contravariant on 2-morphisms, i.e., is a 2-functor <span>$op: Catᶜᵒ → Cat$</span>. For more explanation, see the <a href="https://ncatlab.org/nlab/show/opposite+category">nLab</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Categories.jl#L420-L427">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats" href="#Catlab.CategoricalAlgebra.FinCats"><code>Catlab.CategoricalAlgebra.FinCats</code></a> — <span class="docstring-category">Module</span></header><section><div><p>2-category of finitely presented categories.</p><p>This module is for the 2-category <strong>Cat</strong> what the module <a href="@ref"><code>FinSets</code></a> is for the category <strong>Set</strong>: a finitary, combinatorial setting where explicit calculations can be carried out. We emphasize that the prefix <code>Fin</code> means &quot;finitely presented,&quot; not &quot;finite,&quot; as finite categories are too restrictive a notion for many purposes. For example, the free category on a graph is finite if and only if the graph is DAG, which is a fairly special condition. This usage of <code>Fin</code> is also consistent with <code>FinSet</code> because for sets, being finite and being finitely presented are equivalent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCat" href="#Catlab.CategoricalAlgebra.FinCats.FinCat"><code>Catlab.CategoricalAlgebra.FinCats.FinCat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A finitely presented (but not necessarily finite!) category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L42-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatGraph" href="#Catlab.CategoricalAlgebra.FinCats.FinCatGraph"><code>Catlab.CategoricalAlgebra.FinCats.FinCatGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for category backed by finite generating graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L135-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq" href="#Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq"><code>Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Category presented by a finite graph together with path equations.</p><p>The objects of the category are vertices in the graph and the morphisms are paths, quotiented by the congruence relation generated by the path equations. See (Spivak, 2014, <em>Category theory for the sciences</em>, §4.5).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L261-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph" href="#Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph"><code>Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for category whose morphisms are paths in a graph.</p><p>(Or equivalence classes of paths in a graph, but we compute with</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L215-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatPresentation" href="#Catlab.CategoricalAlgebra.FinCats.FinCatPresentation"><code>Catlab.CategoricalAlgebra.FinCats.FinCatPresentation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Category defined by a <code>Presentation</code> object.</p><p>The presentation type can, of course, be a category (<code>Theories.Category</code>). It can also be a schema (<code>Theories.Schema</code>). In this case, the schema&#39;s objects and attribute types are regarded as the category&#39;s objects and the schema&#39;s morphisms, attributes, and attribute types as the category&#39;s morphisms (where the attribute types are identity morphisms). When the schema is formalized as a profunctor whose codomain category is discrete, this amounts to taking the collage of the profunctor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L289-L299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatSize" href="#Catlab.CategoricalAlgebra.FinCats.FinCatSize"><code>Catlab.CategoricalAlgebra.FinCats.FinCatSize</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Size of a finitely presented category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L38-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinDomFunctor" href="#Catlab.CategoricalAlgebra.FinCats.FinDomFunctor"><code>Catlab.CategoricalAlgebra.FinCats.FinDomFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A functor out of a finitely presented category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L376-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap" href="#Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap"><code>Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Functor out of a finitely presented category given by explicit mappings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L484-L486">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinFunctor" href="#Catlab.CategoricalAlgebra.FinCats.FinFunctor"><code>Catlab.CategoricalAlgebra.FinCats.FinFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A functor between finitely presented categories.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L468-L470">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinTransformation" href="#Catlab.CategoricalAlgebra.FinCats.FinTransformation"><code>Catlab.CategoricalAlgebra.FinCats.FinTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A natural transformation whose domain category is finitely generated.</p><p>This type is for natural transformations <span>$α: F ⇒ G: C → D$</span> such that the domain category <span>$C$</span> is finitely generated. Such a natural transformation is given by a finite amount of data (one morphism in <span>$D$</span> for each generating object of <span>$C$</span>) and its naturality is verified by finitely many equations (one equation for each generating morphism of <span>$C$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L584-L592">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinTransformationMap" href="#Catlab.CategoricalAlgebra.FinCats.FinTransformationMap"><code>Catlab.CategoricalAlgebra.FinCats.FinTransformationMap</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Natural transformation with components given by explicit mapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L646-L648">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FreeCatGraph" href="#Catlab.CategoricalAlgebra.FinCats.FreeCatGraph"><code>Catlab.CategoricalAlgebra.FinCats.FreeCatGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Free category generated by a finite graph.</p><p>The objects of the free category are vertices in the graph and the morphisms are (possibly empty) paths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L238-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.Path" href="#Catlab.CategoricalAlgebra.FinCats.Path"><code>Catlab.CategoricalAlgebra.FinCats.Path</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Path in a graph.</p><p>The path is allowed to be empty but always has definite start and end points (source and target vertices).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L171-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.collect_hom-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}" href="#Catlab.CategoricalAlgebra.FinCats.collect_hom-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>Catlab.CategoricalAlgebra.FinCats.collect_hom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Collect assignments of functor&#39;s morphism map as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L421-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.collect_ob-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}" href="#Catlab.CategoricalAlgebra.FinCats.collect_ob-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>Catlab.CategoricalAlgebra.FinCats.collect_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Collect assignments of functor&#39;s object map as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L417-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.components-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}" href="#Catlab.CategoricalAlgebra.FinCats.components-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}"><code>Catlab.CategoricalAlgebra.FinCats.components</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Components of a natural transformation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L597-L599">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.dom_to_graph-Union{Tuple{Functor{&lt;:Catlab.CategoricalAlgebra.FinCats.FinCatPresentation, &lt;:Category{Ob, Hom}}}, Tuple{Hom}, Tuple{Ob}} where {Ob, Hom}" href="#Catlab.CategoricalAlgebra.FinCats.dom_to_graph-Union{Tuple{Functor{&lt;:Catlab.CategoricalAlgebra.FinCats.FinCatPresentation, &lt;:Category{Ob, Hom}}}, Tuple{Hom}, Tuple{Ob}} where {Ob, Hom}"><code>Catlab.CategoricalAlgebra.FinCats.dom_to_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reinterpret a functor on a finitely presented category as a functor on the equivalent category (ignoring equations) free on a graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L559-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.force" href="#Catlab.CategoricalAlgebra.FinCats.force"><code>Catlab.CategoricalAlgebra.FinCats.force</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Force evaluation of lazily defined function or functor. The resulting ob<em>map and hom</em>map are guaranteed to have  valtype or eltype, as appropriate, equal to Ob and Hom, respectively. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L541-L546">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.functoriality_failures-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}" href="#Catlab.CategoricalAlgebra.FinCats.functoriality_failures-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>Catlab.CategoricalAlgebra.FinCats.functoriality_failures</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Failures of the purported functor on a presented category to be functorial.</p><p>Similar to <a href="#Catlab.CategoricalAlgebra.FinCats.is_functorial-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>is_functorial</code></a> (and with the same caveats) but returns iterators of functoriality failures: one for domain incompatibilities, one for codomain incompatibilities, and one for equations that are not satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L439-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.graph-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.FinCats.graph-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.FinCats.graph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Graph underlying a finitely presented category whose  object and hom generators are indexable, other than one explicitly generated by a graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.graph-Tuple{FinCatGraph}" href="#Catlab.CategoricalAlgebra.FinCats.graph-Tuple{FinCatGraph}"><code>Catlab.CategoricalAlgebra.FinCats.graph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generating graph for a finitely presented category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L139-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.hom_generator" href="#Catlab.CategoricalAlgebra.FinCats.hom_generator"><code>Catlab.CategoricalAlgebra.FinCats.hom_generator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Coerce or look up morphism generator in a finitely presented category.</p><p>Since morphism generators often have a different data type than morphisms (e.g., in a free category on a graph, the morphism generators are edges and the morphisms are paths), the return type of this function is generally different than that of <a href="#AlgebraicInterfaces.hom"><code>hom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L71-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.hom_generator_name" href="#Catlab.CategoricalAlgebra.FinCats.hom_generator_name"><code>Catlab.CategoricalAlgebra.FinCats.hom_generator_name</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Name of morphism generator, if any.</p><p>When morphism generators have names, this function is a one-sided inverse to <a href="#Catlab.CategoricalAlgebra.FinCats.hom_generator"><code>hom_generator</code></a>. See also: <a href="#Catlab.CategoricalAlgebra.FinCats.ob_generator_name"><code>ob_generator_name</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.hom_generators" href="#Catlab.CategoricalAlgebra.FinCats.hom_generators"><code>Catlab.CategoricalAlgebra.FinCats.hom_generators</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Morphism generators of finitely presented category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L58-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_discrete-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.FinCats.is_discrete-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.FinCats.is_discrete</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the category discrete?</p><p>A category is <em>discrete</em> if it is has no non-identity morphisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_free-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}" href="#Catlab.CategoricalAlgebra.FinCats.is_free-Tuple{Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}}"><code>Catlab.CategoricalAlgebra.FinCats.is_free</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the category freely generated?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L103-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_functorial-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}" href="#Catlab.CategoricalAlgebra.FinCats.is_functorial-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>Catlab.CategoricalAlgebra.FinCats.is_functorial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the purported functor on a presented category functorial?</p><p>This function checks that functor preserves domains and codomains. When <code>check_equations</code> is <code>true</code> (the default is <code>false</code>), it also purports to check that the functor preserves all equations in the domain category. No nontrivial  checks are currently implemented, so this only functions for identity functors.</p><p>See also: <a href="@ref">`functoriality_failures&#39;</a> and <a href="#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}"><code>is_natural</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L425-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_initial-Tuple{Functor{Dom, Codom} where {Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}}" href="#Catlab.CategoricalAlgebra.FinCats.is_initial-Tuple{Functor{Dom, Codom} where {Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}}"><code>Catlab.CategoricalAlgebra.FinCats.is_initial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Dual to a <a href="https://ncatlab.org/nlab/show/final+functor">final functor</a>, an <em>initial functor</em> is one for which pulling back diagrams along it does not change the limits of these diagrams.</p><p>This amounts to checking, for a functor C-&gt;D, that, for every object d in Ob(D), the comma category (F/d) is connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L703-L710">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}" href="#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}"><code>Catlab.CategoricalAlgebra.FinCats.is_natural</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the transformation between <code>FinDomFunctors</code> a natural transformation?</p><p>This function uses the fact that to check whether a transformation is natural, it suffices to check the naturality equations on a generating set of morphisms of the domain category. In some cases, checking the equations may be expensive or impossible. When the keyword argument <code>check_equations</code> is <code>false</code>, only the domains and codomains of the components are checked.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FinCats.is_functorial-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>is_functorial</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L602-L612">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.make_map-Union{Tuple{T}, Tuple{Any, UnitRange{Int64}, Type{T}}} where T" href="#Catlab.CategoricalAlgebra.FinCats.make_map-Union{Tuple{T}, Tuple{Any, UnitRange{Int64}, Type{T}}} where T"><code>Catlab.CategoricalAlgebra.FinCats.make_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Maps <code>f</code> over a <code>UnitRange</code> to produce a <code>Vector</code>, or else over anything to produce a <code>Dict</code>. The type paramter functions to ensure the return type is as desired even when the input is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L796-L801">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.mappairs-Union{Tuple{T}, Tuple{V}, Tuple{K}, Tuple{Any, Any, T}} where {K, V, T&lt;:AbstractDict{K, V}}" href="#Catlab.CategoricalAlgebra.FinCats.mappairs-Union{Tuple{T}, Tuple{V}, Tuple{K}, Tuple{Any, Any, T}} where {K, V, T&lt;:AbstractDict{K, V}}"><code>Catlab.CategoricalAlgebra.FinCats.mappairs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Map two given functions across the respective keys and values of a dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L758-L760">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.mapvals-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:AbstractDict" href="#Catlab.CategoricalAlgebra.FinCats.mapvals-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:AbstractDict"><code>Catlab.CategoricalAlgebra.FinCats.mapvals</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Map a function, which may depend on the key, across the values of a dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L772-L774">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.ob_generator" href="#Catlab.CategoricalAlgebra.FinCats.ob_generator"><code>Catlab.CategoricalAlgebra.FinCats.ob_generator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Coerce or look up object generator in a finitely presented category.</p><p>Because object generators usually coincide with objects, the default method for <a href="#AlgebraicInterfaces.ob"><code>ob</code></a> in finitely presented categories simply calls this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.ob_generator_name" href="#Catlab.CategoricalAlgebra.FinCats.ob_generator_name"><code>Catlab.CategoricalAlgebra.FinCats.ob_generator_name</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Name of object generator, if any.</p><p>When object generators have names, this function is a one-sided inverse to <a href="#Catlab.CategoricalAlgebra.FinCats.ob_generator"><code>ob_generator</code></a> in that <code>ob_generator(C, ob_generator_name(C, x)) == x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.ob_generators" href="#Catlab.CategoricalAlgebra.FinCats.ob_generators"><code>Catlab.CategoricalAlgebra.FinCats.ob_generators</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Object generators of finitely presented category.</p><p>The object generators of finite presented category are almost always the same as the objects. In principle, however, it is possible to have equations between objects, so that there are fewer objects than object generators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.presentation-Tuple{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation}" href="#Catlab.CategoricalAlgebra.FinCats.presentation-Tuple{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation}"><code>Catlab.CategoricalAlgebra.FinCats.presentation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes the graph generating a finitely presented category. Ignores any attribute side and any equations. Optionally returns the mappings from generators to their indices in the resulting graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FinCats.jl#L320-L326">source</a></section></article><h2 id="Acsets"><a class="docs-heading-anchor" href="#Acsets">Acsets</a><a id="Acsets-1"></a><a class="docs-heading-anchor-permalink" href="#Acsets" title="Permalink"></a></h2><h3 id="Overview-and-Theory"><a class="docs-heading-anchor" href="#Overview-and-Theory">Overview and Theory</a><a id="Overview-and-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-and-Theory" title="Permalink"></a></h3><p>For an in depth look into the theory behind acsets, we refer the reader to <a href="https://arxiv.org/abs/2106.04703">our paper</a> on the subject, which also gives some sense as to how the implementation works. Here, we give a brief tutorial before the the API documentation.</p><p>The most essential part of the acset machinery is the schema. The schema <em>parameterizes</em> the acset: each schema corresponds to a different type of acset. Schemas consist of four parts.</p><ul><li>Objects <span>$X,Y$</span> (<code>(X,Y,Z)::Ob</code>)</li><li>Homomorphisms <span>$f \colon X \to Y$</span> (<code>f :: Hom(X,Y)</code>), which go from objects to objects</li><li>Attribute types <span>$\mathtt{T}$</span> (<code>T :: AttrType</code>)</li><li>Attributes <span>$a \colon X \to \mathtt{T}$</span> (<code>a :: Attr(X,T)</code>), which go from objects to data types</li></ul><p>For those with a categorical background, a schema is a presentation of a category <span>$|S|$</span> along with a functor <span>$S$</span> from <span>$|S|$</span> to the arrow category <span>$0 \to 1$</span>, such that <span>$S^{-1}(1)$</span> is discrete.</p><p>An acset <span>$F$</span> on a schema consists of...</p><ul><li>a set <span>$F(X)$</span> of &quot;primary keys&quot; for each object</li><li>a function <span>$F(f) \colon F(X) \to F(Y)$</span> for each morphism</li><li>a Julia data type <span>$F(\mathtt{T})$</span> for each data type <span>$\mathtt{T}$</span></li><li>a function <span>$F(a) \colon F(X) \to F(\mathtt{T})$</span> for each attribute <span>$a$</span>.</li></ul><p>For those with a categorical background, an acset on a schema <span>$S$</span> consists of a functor from <span>$S$</span> to <span>$\mathsf{Set}$</span>, such that objects in <span>$S^{-1}(0)$</span> map to finite sets, and objects in <span>$S^{-1}(1)$</span> map to sets that represent types. For any particular functor <span>$K \colon S^{-1}(1) \to \mathsf{Set}$</span>, we can also take the category of acsets that restrict to this map on <span>$S^{-1}$</span>.</p><p>We can also add equations to this presentation, but we currently do nothing with those equations in the implementation; they mostly serve as documentation.</p><p>We will now give an example of how this all works in practice.</p><pre><code class="language-julia hljs">using GATlab, Catlab.CategoricalAlgebra

# Write down the schema for a weighted graph
@present SchWeightedGraph(FreeSchema) begin
  V::Ob
  E::Ob
  src::Hom(E,V)
  tgt::Hom(E,V)
  T::AttrType
  weight::Attr(E,T)
end

# Construct the type used to store acsets on the previous schema
# We *index* src and tgt, which means that we store not only
# the forwards map, but also the backwards map.
@acset_type WeightedGraph(SchWeightedGraph, index=[:src,:tgt])

# Construct a weighted graph, with floats as edge weights
g = @acset WeightedGraph{Float64} begin
  V = 4
  E = 5
  src = [1,1,1,2,3]
  tgt = [2,3,4,4,4]
  weight = [7.2, 9.3, 9.4, 0.1, 42.0]
end</code></pre><div class="c-set">
<span class="c-set-summary">Main.__atexample__332.WeightedGraph{Float64} {V:4, E:5, T:0}</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">E</th>
      <th style = "text-align: right;">src</th>
      <th style = "text-align: right;">tgt</th>
      <th style = "text-align: right;">weight</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">7.2</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">9.3</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">9.4</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">0.1</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">42.0</td>
    </tr>
  </tbody>
</table>
</div>
<h3 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h3><p>The mathematical abstraction of an acset can of course be implemented in many different ways. Currently, there are three implementations of acsets in Catlab, which share a great deal of code.</p><p>These implementations can be split into two categories.</p><p>The first category is <strong>static acset types</strong>. In this implementation, different schemas correspond to different Julia types. Methods on these Julia types are then custom-generated for the schema, using <a href="https://github.com/AlgebraicJulia/CompTime.jl">CompTime.jl</a>.</p><p>Under this category, there are two classes of static acset types. The first class is acset types that are generated using the <code>@acset_type</code> macro. These acset types are custom-derived structs. The advantage of this is that the structs have names like <code>Graph</code> or <code>WiringDiagram</code> that are printed out in error messages. The disadvantage is that if you are taking in schemas at runtime, you have to <code>eval</code> code in order to use them.</p><p>Here is an example of using <code>@acset_type</code></p><pre><code class="language-julia hljs">@acset_type WeightedGraph(SchWeightedGraph, index=[:src,:tgt])
g = WeightedGraph()</code></pre><p>The second class is <code>AnonACSet</code>s. Like acset types derived from <code>@acset_type</code>, these contain the schema in their type. However, they also contain the type of their fields in their types, so the types printed out in error messages are long and ugly. The advantage of these is that they can be used in situations where the schema is passed in at runtime, and they don&#39;t require using <code>eval</code> to create a new acset type.</p><p>Here is an example of using <code>AnonACSet</code></p><pre><code class="language-julia hljs">const WeightedGraph = AnonACSetType(SchWeightedGraph, index=[:src,:tgt])
g = WeightedGraph()</code></pre><p>The second category is <strong>dynamic acset types</strong>. Currently, there is just one type that falls under this category: <code>DynamicACSet</code>. This type has a <strong>field</strong> for the schema, and no code-generation is done for operations on acsets of this type. This means that if the schema is large compared to the data, this type will often be faster than the static acsets.</p><p>However, dynamics acsets are a new addition to Catlab, and much of the machinery of limits, colimits, and other high-level acset constructions assumes that the schema of an acset can be derived from the type. Thus, more work will have to be done before dynamic acsets become a drop-in replacement for static acsets.</p><p>Here is an example of using a dynamic acset</p><pre><code class="language-julia hljs">g = DynamicACSet(&quot;WeightedGraph&quot;, SchWeightedGraph; index=[:src,:tgt])</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets" href="#Catlab.CategoricalAlgebra.CSets"><code>Catlab.CategoricalAlgebra.CSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Categories of C-sets and attributed C-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetMorphism" href="#Catlab.CategoricalAlgebra.CSets.ACSetMorphism"><code>Catlab.CategoricalAlgebra.CSets.ACSetMorphism</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Common type for <code>ACSetTransformation</code> and <code>CSetTransformation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L261-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.ACSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.ACSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Transformation between attributed C-sets.</p><p>Homomorphisms of attributed C-sets generalize homomorphisms of C-sets (<a href="#Catlab.CategoricalAlgebra.CSets.CSetTransformation"><code>CSetTransformation</code></a>), which you should understand before reading this.</p><p>A <em>homomorphism</em> of attributed C-sets with schema S: C ↛ A (a profunctor) is a natural transformation between the corresponding functors col(S) → Set, where col(S) is the collage of S. When the components on attribute types, indexed by objects of A, are all identity functions, the morphism is called <em>tight</em>; in general, it is called <em>loose</em>. With this terminology, acsets on a fixed schema are the objects of an ℳ-category (see <code>Catlab.Theories.MCategory</code>). Calling <code>ACSetTransformation</code> will construct a tight or loose morphism as appropriate, depending on which components are specified.</p><p>Since every tight morphism can be considered a loose one, the distinction between tight and loose may seem a minor technicality, but it has important consequences because limits and colimits in a category depend as much on the morphisms as on the objects. In particular, limits and colimits of acsets differ greatly depending on whether they are taken in the category of acsets with tight morphisms or with loose morphisms. Tight morphisms suffice for many purposes, including most applications of colimits. However, when computing limits of acsets, loose morphisms are usually preferable. For more information about limits and colimits in these categories, see <a href="#Catlab.CategoricalAlgebra.CSets.TightACSetTransformation"><code>TightACSetTransformation</code></a> and <a href="#Catlab.CategoricalAlgebra.CSets.LooseACSetTransformation"><code>LooseACSetTransformation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L266-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.ACSetTransformation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Move components as first argument</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L529">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{StructACSet}" href="#Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{StructACSet}"><code>Catlab.CategoricalAlgebra.CSets.ACSetTransformation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A map f (from A to B) as a map from A to a subobject of B</p><p><strong>i.e. get the image of f as a subobject of B</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L1295-L1298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{Subobject{&lt;:StructACSet{S}} where S}" href="#Catlab.CategoricalAlgebra.CSets.ACSetTransformation-Tuple{Subobject{&lt;:StructACSet{S}} where S}"><code>Catlab.CategoricalAlgebra.CSets.ACSetTransformation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A map f (from A to B) as a map of subobjects of A to subjects of B</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L1286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.CSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.CSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.CSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Transformation between C-sets.</p><p>Recall that a C-set homomorphism is a natural transformation: a transformation between functors C → Set satisfying the naturality axiom for every morphism, or equivalently every generating morphism, in C.</p><p>This data type records the data of a C-set transformation. Naturality is not strictly enforced but is expected to be satisfied. It can be checked using the function <a href="#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Category, Dom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}}"><code>is_natural</code></a>.</p><p>If the schema of the dom and codom has attributes, this has the semantics of  being a valid C-set transformation on the combinatorial data alone (including  attribute variables, if any).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L374-L388">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.LooseACSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.LooseACSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.LooseACSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Loose transformation between attributed C-sets.</p><p>Limits and colimits in the category of attributed C-sets and loose homomorphisms are computed pointwise on both objects <em>and</em> attribute types. This implies that (co)limits of Julia types must be computed. Due to limitations in the expressivity of Julia&#39;s type system, only certain simple kinds of (co)limits, such as products, are supported.</p><p>Alternatively, colimits involving loose acset transformations can be constructed with respect to explicitly given attribute type components for the legs of the cocone, via the keyword argument <code>type_components</code> to <code>colimit</code> and related functions. This uses the universal property of the colimit. To see how this works, notice that a diagram of acsets and loose acset transformations can be expressed as a diagram D: J → C-Set (for the C-sets) along with another diagram A: J → C-Set (for the attribute sets) and a natural transformation α: D ⇒ A (assigning attributes). Given a natural transformation τ: A ⇒ ΔB to a constant functor ΔB, with components given by <code>type_components</code>, the composite transformation α⋅τ: D ⇒ ΔB is a cocone under D, hence factors through the colimit cocone of D. This factoring yields an assigment of attributes to the colimit in C-Set.</p><p>For the distinction between tight and loose, see <a href="@ref"><code>ACSetTranformation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L306-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.SubCSet" href="#Catlab.CategoricalAlgebra.CSets.SubCSet"><code>Catlab.CategoricalAlgebra.CSets.SubCSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Sub-C-set of a C-set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L1115-L1117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.TightACSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.TightACSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.TightACSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tight transformation between attributed C-sets.</p><p>The category of attributed C-sets and tight homomorphisms is isomorphic to a slice category of C-Set, as explained in our paper &quot;Categorical Data Structures for Technical Computing&quot;. Colimits in this category thus reduce to colimits of C-sets, by a standard result about slice categories. Limits are more complicated and are currently not supported.</p><p>For the distinction between tight and loose, see <a href="@ref"><code>ACSetTranformation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L293-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ACSets.ACSetInterface.copy_parts!-Tuple{ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}" href="#ACSets.ACSetInterface.copy_parts!-Tuple{ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>ACSets.ACSetInterface.copy_parts!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Copy parts from a set-valued <code>FinDomFunctor</code> to an <code>ACSet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L239-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.abstract_attributes-Tuple{ACSet}" href="#Catlab.CategoricalAlgebra.CSets.abstract_attributes-Tuple{ACSet}"><code>Catlab.CategoricalAlgebra.CSets.abstract_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For any ACSet, X, a canonical map A→X where A has distinct variables for all subparts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L1323-L1326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.naturality_failures-Tuple{Any, Any, Any}" href="#Catlab.CategoricalAlgebra.CSets.naturality_failures-Tuple{Any, Any, Any}"><code>Catlab.CategoricalAlgebra.CSets.naturality_failures</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a dictionary whose keys are contained in the names in <code>arrows(S)</code> and whose value at <code>:f</code>, for an arrow <code>(f,c,d)</code>, is a lazy iterator over the elements of X(c) on which α&#39;s naturality square for f does not commute. Components should be a NamedTuple or Dictionary with keys contained in the names of S&#39;s morphisms and values vectors or dicts defining partial functions from X(c) to Y(c).</p><p><code>only_combinatorial=true</code> means to only look for naturality failures in combinatorial  data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L625-L635">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.show_naturality_failures-Tuple{IO, AbstractDict}" href="#Catlab.CategoricalAlgebra.CSets.show_naturality_failures-Tuple{IO, AbstractDict}"><code>Catlab.CategoricalAlgebra.CSets.show_naturality_failures</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pretty-print failures of transformation to be natural.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.CSets.naturality_failures-Tuple{Any, Any, Any}"><code>naturality_failures</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L670-L674">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{LooseACSetTransformation}" href="#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{LooseACSetTransformation}"><code>Catlab.CategoricalAlgebra.FinCats.is_natural</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check naturality condition for a purported ACSetTransformation, α: X→Y.  For each hom in the schema, e.g. h: m → n, the following square commute must:</p><pre><code class="language-text hljs">     αₘ
  Xₘ --&gt; Yₘ
Xₕ ↓  ✓  ↓ Yₕ
  Xₙ --&gt; Yₙ
     αₙ</code></pre><p>You&#39;re allowed to run this on a named tuple partly specifying an ACSetTransformation, though at this time the domain and codomain must be fully specified ACSets.</p><p><code>only_combinatorial=true</code> means to only test naturality in combinatorial data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/CSets.jl#L595-L611">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FunctorialDataMigrations" href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations"><code>Catlab.CategoricalAlgebra.FunctorialDataMigrations</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Functorial data migration for attributed C-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FunctorialDataMigrations.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FunctorialDataMigrations.DataMigrationFunctor" href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations.DataMigrationFunctor"><code>Catlab.CategoricalAlgebra.FunctorialDataMigrations.DataMigrationFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Data migration functor given contravariantly. Stores a contravariant migration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FunctorialDataMigrations.jl#L152-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FunctorialDataMigrations.internal_hom-Union{Tuple{T}, Tuple{T, T, Presentation{Catlab.Theories.ThSchema.Meta.T}}} where T&lt;:ACSet" href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations.internal_hom-Union{Tuple{T}, Tuple{T, T, Presentation{Catlab.Theories.ThSchema.Meta.T}}} where T&lt;:ACSet"><code>Catlab.CategoricalAlgebra.FunctorialDataMigrations.internal_hom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Objects: Fᴳ(c) = C-Set(C × G, F)    where C is the representable c</p><p>Given a map f: a-&gt;b, we compute that f(Aᵢ) = Bⱼ by constructing the following:           Aᵢ     A × G → F   f*↑ ↑ ↑ ↗ Bⱼ       find the hom Bⱼ that makes this commute     B × G </p><p>where f* is given by <code>yoneda</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FunctorialDataMigrations.jl#L366-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate!-Tuple{ACSet, ACSet, Catlab.CategoricalAlgebra.FunctorialDataMigrations.AbstractDataMigration}" href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate!-Tuple{ACSet, ACSet, Catlab.CategoricalAlgebra.FunctorialDataMigrations.AbstractDataMigration}"><code>Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Contravariantly migrate data from the acset <code>Y</code> to the acset <code>X</code>.</p><p>This is the mutating variant of <a href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate!-Tuple{ACSet, ACSet, Catlab.CategoricalAlgebra.FunctorialDataMigrations.AbstractDataMigration}"><code>migrate!</code></a>. When the functor on schemas is the identity, this operation is equivalent to <a href="#ACSets.ACSetInterface.copy_parts!-Tuple{ACSet, Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}"><code>copy_parts!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FunctorialDataMigrations.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Catlab.CategoricalAlgebra.FunctorialDataMigrations.ContravariantMigration{F} where F&lt;:(Functor{Dom, Codom} where {Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})})}" href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate-Tuple{Functor{Dom} where Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Catlab.CategoricalAlgebra.FunctorialDataMigrations.ContravariantMigration{F} where F&lt;:(Functor{Dom, Codom} where {Dom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom&lt;:(Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})})}"><code>Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a <span>$Δ$</span> migration by simple precomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FunctorialDataMigrations.jl#L88-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate-Union{Tuple{T}, Tuple{Type{T}, ACSet, Catlab.CategoricalAlgebra.FunctorialDataMigrations.AbstractDataMigration}} where T&lt;:ACSet" href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate-Union{Tuple{T}, Tuple{Type{T}, ACSet, Catlab.CategoricalAlgebra.FunctorialDataMigrations.AbstractDataMigration}} where T&lt;:ACSet"><code>Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Contravariantly migrate data from the acset <code>Y</code> to a new acset of type <code>T</code>.</p><p>The mutating variant of this function is <a href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate!-Tuple{ACSet, ACSet, Catlab.CategoricalAlgebra.FunctorialDataMigrations.AbstractDataMigration}"><code>migrate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FunctorialDataMigrations.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FunctorialDataMigrations.representable-Tuple{Any, Presentation{Catlab.Theories.ThSchema.Meta.T}, Symbol}" href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations.representable-Tuple{Any, Presentation{Catlab.Theories.ThSchema.Meta.T}, Symbol}"><code>Catlab.CategoricalAlgebra.FunctorialDataMigrations.representable</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a representable C-set.</p><p>Recall that a <em>representable</em> C-set is one of form <span>$C(c,-): C → Set$</span> for some object <span>$c ∈ C$</span>.</p><p>This function computes the <span>$c$</span> representable as the left pushforward data migration of the singleton <span>${c}$</span>-set along the inclusion functor <span>${c} ↪ C$</span>, which works because left Kan extensions take representables to representables (Mac Lane 1978, Exercise X.3.2). Besides the intrinsic difficulties with representables (they can be infinite), this function thus inherits any limitations of our implementation of left pushforward data migrations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FunctorialDataMigrations.jl#L290-L302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FunctorialDataMigrations.representable-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T&lt;:StructACSet" href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations.representable-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T&lt;:StructACSet"><code>Catlab.CategoricalAlgebra.FunctorialDataMigrations.representable</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ACSet types do not store info about equations, so this info is lost when we try to recover the presentation from the datatype. Thus, this method for  <code>representable</code> should only be used for free schemas</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FunctorialDataMigrations.jl#L317-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FunctorialDataMigrations.subobject_classifier-Tuple{Type, Presentation{Catlab.Theories.ThSchema.Meta.T}}" href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations.subobject_classifier-Tuple{Type, Presentation{Catlab.Theories.ThSchema.Meta.T}}"><code>Catlab.CategoricalAlgebra.FunctorialDataMigrations.subobject_classifier</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The subobject classifier Ω in a presheaf topos is the presheaf that sends each  object A to the set of sieves on it (equivalently, the set of subobjects of the  representable presheaf for A). Counting subobjects gives us the <em>number</em> of A  parts; the hom data for f:A-&gt;B for subobject Aᵢ is determined via:</p><p>Aᵢ ↪ A  ↑    ↑ f*   PB⌝↪ B          (PB picks out a subobject of B, up to isomorphism.)</p><p>(where A and B are the representables for objects A and B and f* is the unique  map from B into the A which sends the point of B to f applied to the point of A)</p><p>Returns the classifier as well as a dictionary of subobjects corresponding to  the parts of the classifier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FunctorialDataMigrations.jl#L326-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FunctorialDataMigrations.yoneda-Tuple{Any, Presentation{Catlab.Theories.ThSchema.Meta.T}}" href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations.yoneda-Tuple{Any, Presentation{Catlab.Theories.ThSchema.Meta.T}}"><code>Catlab.CategoricalAlgebra.FunctorialDataMigrations.yoneda</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the Yoneda embedding of a category C in the category of C-sets.</p><p>Because Catlab privileges copresheaves (C-sets) over presheaves, this is the <em>contravariant</em> Yoneda embedding, i.e., the embedding functor C^op → C-Set.</p><p>The first argument <code>cons</code> is a constructor for the ACSet, such as a struct acset type. If representables have already been computed (which can be expensive), they can be supplied via the <code>cache</code> keyword argument.</p><p>Returns a <code>FinDomFunctor</code> with domain <code>op(C)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FunctorialDataMigrations.jl#L397-L408">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.functor-Tuple{DataMigrationFunctor}" href="#GATlab.Models.SymbolicModels.functor-Tuple{DataMigrationFunctor}"><code>GATlab.Models.SymbolicModels.functor</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gives the underlying schema functor of a data migration  seen as a functor of acset categories.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/FunctorialDataMigrations.jl#L159-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Chase" href="#Catlab.CategoricalAlgebra.Chase"><code>Catlab.CategoricalAlgebra.Chase</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The chase is an algorithm which subjects a C-Set instance to constraints  expressed in the language of regular logic, called embedded dependencies  (EDs, or &#39;triggers&#39;). </p><p>A morphism S-&gt;T, encodes an embedded dependency. If the pattern  S is matched (via a homomorphism S-&gt;I), we demand there exist a morphism T-&gt;I  (for some database instance I) that makes the triangle commute in order to  satisfy the dependency (if this is not the case, then the trigger is &#39;active&#39;).</p><p>Homomorphisms can merge elements and introduce new ones. The former kind are called &quot;equality generating dependencies&quot; (EGDs) and the latter &quot;tuple generating dependencies&quot; (TGDs). Any homomorphism can be factored into EGD and TGD components by, respectively, restricting the codomain to the image or restricting the domain to the coimage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Chase.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Chase.chase-Tuple{ACSet, AbstractDict, Int64}" href="#Catlab.CategoricalAlgebra.Chase.chase-Tuple{ACSet, AbstractDict, Int64}"><code>Catlab.CategoricalAlgebra.Chase.chase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chase(I::ACSet, Σ::AbstractDict, n::Int)</code></pre><p>Chase a C-Set or C-Rel instance given a list of embedded dependencies. This may not terminate, so a bound <code>n</code> on the number of iterations is required.</p><pre><code class="nohighlight hljs">[,]</code></pre><p>ΣS  ⟶ Iₙ ⊕↓      ⋮  (resulting morphism)  ΣT ... Iₙ₊₁</p><p>There is a copy of S and T for each active trigger. A trigger is a map from S into the current instance. What makes it &#39;active&#39; is that there is no morphism from T to I that makes the triangle commute.</p><p>Each iteration constructs the above pushout square. The result is a morphism, so that one can keep track of the provenance of elements in the original CSet instance within the chased result.</p><p>Whether or not the result is due to success or timeout is returned as a boolean flag.</p><p>TODO: this algorithm could be made more efficient by homomorphism caching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/Chase.jl#L254-L278">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans" href="#Catlab.CategoricalAlgebra.StructuredCospans"><code>Catlab.CategoricalAlgebra.StructuredCospans</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Structured cospans.</p><p>This module provides a generic interface for structured cospans with a concrete implementation for attributed C-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/StructuredCospans.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetLeg" href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetLeg"><code>Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetLeg</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Leg of a structured (multi)cospan of acsets in R-form.</p><p>A convenience type that contains the data of an acset transformation, except for the codomain, since that data is already given by the decoration of the R-form structured cospan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/StructuredCospans.jl#L238-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structured cospan.</p><p>The first type parameter <code>L</code> encodes a functor L: A → X from the base category <code>A</code>, often FinSet, to a category <code>X</code> with &quot;extra structure.&quot; An L-structured cospan is then a cospan in X whose feet are images under L of objects in A. The category X is assumed to have pushouts.</p><p>Structured cospans form a double category with no further assumptions on the functor L. To obtain a symmetric monoidal double category, L must preserve finite coproducts. In practice, L usually has a right adjoint R: X → A, which implies that L preserves all finite colimits. It also allows structured cospans to be constructed more conveniently from an object x in X plus a cospan in A with apex R(x).</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan"><code>StructuredMulticospan</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/StructuredCospans.jl#L56-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Any, Multicospan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}} where L" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Any, Multicospan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}}} where L"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct structured cospan in R-form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/StructuredCospans.jl#L80-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Multicospan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}, StaticArraysCore.StaticArray{Tuple{2}, T, 1} where T}} where L" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Multicospan{Ob, Hom, &lt;:StaticArraysCore.StaticArray{Tuple{2}, Hom, 1}} where {Ob, Hom}, StaticArraysCore.StaticArray{Tuple{2}, T, 1} where T}} where L"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct structured cospan in L-form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/StructuredCospans.jl#L75-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object in the category of L-structured cospans.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/StructuredCospans.jl#L99-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structured multicospan.</p><p>A structured multicospan is like a structured cospan except that it may have a number of legs different than two.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan"><code>StructuredCospan</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/StructuredCospans.jl#L25-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan-Union{Tuple{L}, Tuple{Any, Multicospan}} where L" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan-Union{Tuple{L}, Tuple{Any, Multicospan}} where L"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct structured multicospan in R-form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/StructuredCospans.jl#L44-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S, X&lt;:(StructACSet{S})}" href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S, X&lt;:(StructACSet{S})}"><code>Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create types for open attributed C-sets from an attributed C-set type.</p><p>The type parameters of the given acset type should <em>not</em> be instantiated with specific Julia types. This function returns a pair of types, one for objects, a subtype of <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb"><code>StructuredCospanOb</code></a>, and one for morphisms, a subtype of <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan"><code>StructuredMulticospan</code></a>. Both types will have the same type parameters for attribute types as the given acset type.</p><p>Mathematically speaking, this function sets up structured (multi)cospans with a functor <span>$L: A → X$</span> between categories of acsets that creates &quot;discrete acsets.&quot; Such a &quot;discrete acset functor&quot; is a functor that is left adjoint to a certain kind of forgetful functor between categories of acsets, namely one that is a pullback along an inclusion of schemas such that the image of inclusion has no outgoing arrows. For example, the schema inclusion <span>${V} ↪ {E ⇉ V}$</span> has this property but <span>${E} ↪ {E ⇉ V}$</span> does not.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{Type{X}, Vararg{Any}}} where X&lt;:(StructCSet)"><code>OpenCSetTypes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/StructuredCospans.jl#L193-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{Type{X}, Vararg{Any}}} where X&lt;:(StructCSet)" href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{Type{X}, Vararg{Any}}} where X&lt;:(StructCSet)"><code>Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create types for open C-sets from a C-set type.</p><p>A special case of <a href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S, X&lt;:(StructACSet{S})}"><code>OpenACSetTypes</code></a>. See there for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/d21636ca5f5219a09bb0588b6702f640d3aadbe2/src/categorical_algebra/StructuredCospans.jl#L185-L189">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theories/">« Standard library of theories</a><a class="docs-footer-nextpage" href="../graphs/">Graphs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Saturday 16 December 2023 03:49">Saturday 16 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
