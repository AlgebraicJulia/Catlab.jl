<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Categorical algebra · Catlab.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Catlab.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Seven Sketches</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/sketches/partitions/">Partitions</a></li><li><a class="tocitem" href="../../generated/sketches/preorders/">Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/meets/">Meets in Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/smc/">Symmetric Monoidal Categories</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphs/graphs/">The Category of Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/graphs_label/">Labelled Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/subgraphs/">Algebra of subgraphs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/diagrams/diagrams/">Diagrams</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Wiring Diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/wd_cset/">Wiring Diagrams as Attributed C-Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_schema_visualization/">Visualizing Acset Schemas with Graphviz</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../core/">Theories, instances, and expressions</a></li><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li class="is-active"><a class="tocitem" href>Categorical algebra</a><ul class="internal"><li><a class="tocitem" href="#Sets-and-Relations"><span>Sets and Relations</span></a></li><li><a class="tocitem" href="#Free-Diagrams,-Limits,-and-Colimts"><span>Free Diagrams, Limits, and Colimts</span></a></li><li><a class="tocitem" href="#Categories"><span>Categories</span></a></li><li><a class="tocitem" href="#Acsets"><span>Acsets</span></a></li></ul></li><li><a class="tocitem" href="../graphs/">Graphs</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li><a class="tocitem" href="../programs/">Programs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Categorical algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Categorical algebra</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/master/docs/src/apis/categorical_algebra.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="categorical_algebra"><a class="docs-heading-anchor" href="#categorical_algebra">Categorical algebra</a><a id="categorical_algebra-1"></a><a class="docs-heading-anchor-permalink" href="#categorical_algebra" title="Permalink"></a></h1><h2 id="Sets-and-Relations"><a class="docs-heading-anchor" href="#Sets-and-Relations">Sets and Relations</a><a id="Sets-and-Relations-1"></a><a class="docs-heading-anchor-permalink" href="#Sets-and-Relations" title="Permalink"></a></h2><p>The following APIs implement FinSet, the category of Finite Sets (actually the skeleton of FinSet). The objects of this category are natural numbers where <code>n</code> represents a set with <code>n</code> elements. The morphisms are functions between such sets. We use the skeleton of FinSet in order to ensure that all sets are finite and morphisms can be stored using lists of integers. Finite relations are built out of FinSet and can be used to do some relational algebra.</p><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets" href="#Catlab.CategoricalAlgebra.Sets"><code>Catlab.CategoricalAlgebra.Sets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Category of (possibly infinite) sets and functions.</p><p>This module defines generic types for the category of sets (<a href="#Catlab.CategoricalAlgebra.Sets.SetOb"><code>SetOb</code></a>, <a href="#Catlab.CategoricalAlgebra.Sets.SetFunction"><code>SetFunction</code></a>), as well as a few basic concrete types, such as a wrapper type to view Julia types as sets (<a href="#Catlab.CategoricalAlgebra.Sets.TypeSet"><code>TypeSet</code></a>). Extensive support for finite sets is provided by another module, <a href="apis/@ref"><code>FinSets</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.ConstantFunction" href="#Catlab.CategoricalAlgebra.Sets.ConstantFunction"><code>Catlab.CategoricalAlgebra.Sets.ConstantFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function in <strong>Set</strong> taking a constant value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.PredicatedSet" href="#Catlab.CategoricalAlgebra.Sets.PredicatedSet"><code>Catlab.CategoricalAlgebra.Sets.PredicatedSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Set defined by a predicate (boolean-valued function) on a Julia data type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.SetFunction" href="#Catlab.CategoricalAlgebra.Sets.SetFunction"><code>Catlab.CategoricalAlgebra.Sets.SetFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for morphism in the category <strong>Set</strong>.</p><p>Every instance of <code>SetFunction{&lt;:SetOb{T},&lt;:SetOb{T′}}</code> is callable with elements of type <code>T</code>, returning an element of type <code>T′</code>.</p><p>Note: This type would be better called simply <code>Function</code> but that name is already taken by the base Julia type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.SetOb" href="#Catlab.CategoricalAlgebra.Sets.SetOb"><code>Catlab.CategoricalAlgebra.Sets.SetOb</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for object in the category <strong>Set</strong>.</p><p>The type parameter <code>T</code> is the element type of the set.</p><p>Note: This type is more abstract than the built-in Julia types <code>AbstractSet</code> and <code>Set</code>, which are intended for data structures for finite sets. Those are encompassed by the subtype <a href="apis/@ref"><code>FinSet</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Sets.TypeSet" href="#Catlab.CategoricalAlgebra.Sets.TypeSet"><code>Catlab.CategoricalAlgebra.Sets.TypeSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Julia data type regarded as a set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.Ob-Union{Tuple{TypeCat{T}}, Tuple{T}} where T" href="#Catlab.Theories.Ob-Union{Tuple{TypeCat{T}}, Tuple{T}} where T"><code>Catlab.Theories.Ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Forgetful functor Ob: Cat → Set.</p><p>Sends a category to its set of objects and a functor to its object map.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets" href="#Catlab.CategoricalAlgebra.FinSets"><code>Catlab.CategoricalAlgebra.FinSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The category of finite sets and functions, and its skeleton.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinDomFunction" href="#Catlab.CategoricalAlgebra.FinSets.FinDomFunction"><code>Catlab.CategoricalAlgebra.FinSets.FinDomFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function out of a finite set.</p><p>This class of functions is convenient because it is exactly the class that can be represented explicitly by a vector of values from the codomain.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinFunction" href="#Catlab.CategoricalAlgebra.FinSets.FinFunction"><code>Catlab.CategoricalAlgebra.FinSets.FinFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function between finite sets.</p><p>The function can be defined implicitly by an arbitrary Julia function, in which case it is evaluated lazily, or explictly by a vector of integers. In the vector representation, the function (1↦1, 2↦3, 3↦2, 4↦3), for example, is represented by the vector [1,3,2,3].</p><p>This type is mildly generalized by <a href="#Catlab.CategoricalAlgebra.FinSets.FinDomFunction"><code>FinDomFunction</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinSet" href="#Catlab.CategoricalAlgebra.FinSets.FinSet"><code>Catlab.CategoricalAlgebra.FinSets.FinSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Finite set.</p><p>A finite set has abstract type <code>FinSet{S,T}</code>. The second type parameter <code>T</code> is the element type of the set and the first parameter <code>S</code> is the collection type, which can be a subtype of <code>AbstractSet</code> or another Julia collection type. In addition, the skeleton of the category <strong>FinSet</strong> is the important special case <code>S = Int</code>. The set <span>${1,…,n}$</span> is represented by the object <code>FinSet(n)</code> of type <code>FinSet{Int,Int}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.HashJoin" href="#Catlab.CategoricalAlgebra.FinSets.HashJoin"><code>Catlab.CategoricalAlgebra.FinSets.HashJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Hash_join">Hash join</a> algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm" href="#Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm"><code>Catlab.CategoricalAlgebra.FinSets.JoinAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for limit of cospan or multicospan with feet being finite sets.</p><p>In the context of relational databases, such limits are called <em>joins</em>. The trivial join algorithm is <a href="#Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin"><code>NestedLoopJoin</code></a>, which is algorithmically equivalent to the generic algorithm <code>ComposeProductEqualizer</code>. The algorithms <a href="#Catlab.CategoricalAlgebra.FinSets.HashJoin"><code>HashJoin</code></a> and <a href="#Catlab.CategoricalAlgebra.FinSets.SortMergeJoin"><code>SortMergeJoin</code></a> are usually much faster. If you are unsure what algorithm to pick, use <a href="#Catlab.CategoricalAlgebra.FinSets.SmartJoin"><code>SmartJoin</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin" href="#Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin"><code>Catlab.CategoricalAlgebra.FinSets.NestedLoopJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Nested_loop_join">Nested-loop join</a> algorithm.</p><p>This is the naive algorithm for computing joins.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SmartJoin" href="#Catlab.CategoricalAlgebra.FinSets.SmartJoin"><code>Catlab.CategoricalAlgebra.FinSets.SmartJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-algorithm for joins that attempts to pick an appropriate algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SortMergeJoin" href="#Catlab.CategoricalAlgebra.FinSets.SortMergeJoin"><code>Catlab.CategoricalAlgebra.FinSets.SortMergeJoin</code></a> — <span class="docstring-category">Type</span></header><section><div><p><a href="https://en.wikipedia.org/wiki/Sort-merge_join">Sort-merge join</a> algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SubFinSet" href="#Catlab.CategoricalAlgebra.FinSets.SubFinSet"><code>Catlab.CategoricalAlgebra.FinSets.SubFinSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Subset of a finite set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.SubOpBoolean" href="#Catlab.CategoricalAlgebra.FinSets.SubOpBoolean"><code>Catlab.CategoricalAlgebra.FinSets.SubOpBoolean</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm to compute subobject operations using elementwise boolean logic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.TabularLimit" href="#Catlab.CategoricalAlgebra.FinSets.TabularLimit"><code>Catlab.CategoricalAlgebra.FinSets.TabularLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Limit of finite sets viewed as a table.</p><p>Any limit of finite sets can be canonically viewed as a table (<a href="#Catlab.CategoricalAlgebra.FinSets.TabularSet"><code>TabularSet</code></a>) whose columns are the legs of the limit cone and whose rows correspond to elements of the limit object. To construct this table from an already computed limit, call <code>TabularLimit(::AbstractLimit; ...)</code>. The column names of the table are given by the optional argument <code>names</code>.</p><p>In this tabular form, applying the universal property of the limit is trivial since it is just tupling. Thus, this representation can be useful when the original limit algorithm does not support efficient application of the universal property. On the other hand, this representation has the disadvantage of generally making the element type of the limit set more complicated.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.TabularSet" href="#Catlab.CategoricalAlgebra.FinSets.TabularSet"><code>Catlab.CategoricalAlgebra.FinSets.TabularSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Finite set whose elements are rows of a table.</p><p>The underlying table should be compliant with Tables.jl. For the sake of uniformity, the rows are provided as named tuples, which assumes that the table is not &quot;extremely wide&quot;. This should not be a major limitation in practice but see the Tables.jl documentation for further discussion.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.is_indexed-Tuple{SetFunction}" href="#Catlab.CategoricalAlgebra.FinSets.is_indexed-Tuple{SetFunction}"><code>Catlab.CategoricalAlgebra.FinSets.is_indexed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Whether the given function is indexed, i.e., supports efficient preimages.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.preimage-Tuple{Catlab.CategoricalAlgebra.Sets.IdentityFunction, Any}" href="#Catlab.CategoricalAlgebra.FinSets.preimage-Tuple{Catlab.CategoricalAlgebra.Sets.IdentityFunction, Any}"><code>Catlab.CategoricalAlgebra.FinSets.preimage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The preimage (inverse image) of the value y in the codomain.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations" href="#Catlab.CategoricalAlgebra.FinRelations"><code>Catlab.CategoricalAlgebra.FinRelations</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The category of finite sets and relations, and its skeleton.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.BoolRig" href="#Catlab.CategoricalAlgebra.FinRelations.BoolRig"><code>Catlab.CategoricalAlgebra.FinRelations.BoolRig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The rig of booleans.</p><p>This struct is needed because in base Julia, the product of booleans is another boolean, but the sum of booleans is coerced to an integer: <code>true + true == 2</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRel" href="#Catlab.CategoricalAlgebra.FinRelations.FinRel"><code>Catlab.CategoricalAlgebra.FinRelations.FinRel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object in the category of finite sets and relations.</p><p>See also: <a href="apis/@ref"><code>FinSet</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelation" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelation"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Binary relation between finite sets.</p><p>A morphism in the category of finite sets and relations. The relation can be represented implicitly by an arbitrary Julia function mapping pairs of elements to booleans or explicitly by a matrix (dense or sparse) taking values in the rig of booleans (<a href="#Catlab.CategoricalAlgebra.FinRelations.BoolRig"><code>BoolRig</code></a>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Relation in FinRel defined by a callable Julia object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Relation in FinRel represented by a boolean matrix.</p><p>Boolean matrices are also known as logical matrices or relation matrices.</p></div></section></article><h2 id="Free-Diagrams,-Limits,-and-Colimts"><a class="docs-heading-anchor" href="#Free-Diagrams,-Limits,-and-Colimts">Free Diagrams, Limits, and Colimts</a><a id="Free-Diagrams,-Limits,-and-Colimts-1"></a><a class="docs-heading-anchor-permalink" href="#Free-Diagrams,-Limits,-and-Colimts" title="Permalink"></a></h2><p>The following modules define free diagrams in an arbitrary category and specify limit and colimt cones over said diagrams. Thes constructions enjoy the fullest support for FinSet and are used below to define presheaf categories as C-Sets. The general idea of these functions is that you set up a limit computation by specifying a diagram and asking for a limit or colimit cone, which is returned as a struct containing the apex object and the leg morphisms. This cone structure can be queried using the functions <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}"><code>apex</code></a> and <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>legs</code></a>. Julia&#39;s multiple dispatch feature is heavily used to specialize limit and colimit computations for various diagram shapes like product/coproduct and equalizer/coequalizer. As a consumer of this API, it is highly recommended that you use multiple dispatch to specialize your code on the diagram shape whenever possible.</p><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams" href="#Catlab.CategoricalAlgebra.FreeDiagrams"><code>Catlab.CategoricalAlgebra.FreeDiagrams</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Free diagrams in a category.</p><p>A <a href="https://ncatlab.org/nlab/show/free+diagram">free diagram</a> in a category is a diagram whose shape is a free category. Examples include the empty diagram, pairs of objects, discrete diagrams, parallel pairs, composable pairs, and spans and cospans. Limits and colimits are most commonly taken over free diagrams.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A free diagram with a bipartite structure.</p><p>Such diagrams include most of the fixed shapes, such as spans, cospans, and parallel morphisms. They are also the generic shape of diagrams for limits and colimits arising from undirected wiring diagrams. For limits, the boxes correspond to vertices in <span>$V₁$</span> and the junctions to vertices in <span>$V₂$</span>. Colimits are dual.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram-Union{Tuple{Functor{&lt;:FinCat{Int64}}}, Tuple{Hom}, Tuple{Ob}} where {Ob, Hom}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram-Union{Tuple{Functor{&lt;:FinCat{Int64}}}, Tuple{Hom}, Tuple{Ob}} where {Ob, Hom}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.BipartiteFreeDiagram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert a free diagram to a bipartite free diagram.</p><p>Reduce a free diagram to a free bipartite diagram with the same limit (the default, <code>colimit=false</code>) or the same colimit (<code>colimit=true</code>). The reduction is essentially the same in both cases, except for the choice of where to put isolated vertices, where we follow the conventions described at <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}"><code>cone_objects</code></a> and <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}"><code>cocone_objects</code></a>. The resulting object is a bipartite free diagram equipped with maps from the vertices of the bipartite diagram to the vertices of the original diagram.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Composable morphisms in a category.</p><p>Composable morphisms are a sequence of morphisms in a category that form a path in the underlying graph of the category.</p><p>For the common special case of two morphisms, see <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair"><code>ComposablePair</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ComposablePair</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of composable morphisms in a category.</p><p><a href="https://ncatlab.org/nlab/show/composable+pair">Composable pairs</a> are a common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ComposableMorphisms"><code>ComposableMorphisms</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Cospan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Cospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Cospan of morphisms in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan"><code>Multicospan</code></a>. See also <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Span</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Discrete diagram: a diagram with no non-identity morphisms.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for free diagram of fixed shape.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multicospan of morphisms in a category.</p><p>A multicospan is like a <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Cospan</code></a> except that it may have a number of legs different than two. A limit of this shape is a pullback.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Multispan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multispan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Multispan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multispan of morphisms in a category.</p><p>A <a href="https://ncatlab.org/nlab/show/multispan">multispan</a> is like a <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Span</code></a> except that it may have a number of legs different than two. A colimit of this shape is a pushout.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parallel morphims in a category.</p><p><a href="https://ncatlab.org/nlab/show/parallel+morphisms">Parallel morphisms</a> are just morphisms with the same domain and codomain. A (co)limit of this shape is a (co)equalizer.</p><p>For the common special case of two morphisms, see <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair"><code>ParallelPair</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of parallel morphisms in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms"><code>ParallelMorphisms</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Span" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Span</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Span of morphims in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multispan"><code>Multispan</code></a>. See also <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Cospan</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.apex-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.apex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apex of multispan or multicospan.</p><p>The apex of a multi(co)span is the object that is the (co)domain of all the <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>legs</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs-Tuple{Multispan, Any}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs-Tuple{Multispan, Any}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.bundle_legs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bundle together legs of a multi(co)span.</p><p>For example, calling <code>bundle_legs(span, SVector((1,2),(3,4)))</code> on a multispan with four legs gives a span whose left leg bundles legs 1 and 2 and whose right leg bundles legs 3 and 4. Note that in addition to bundling, this function can also permute legs and discard them.</p><p>The bundling is performed using the universal property of (co)products, which assumes that these (co)limits exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Objects in diagram that will have explicit legs in colimit cocone.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}"><code>cone_objects</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects-Tuple{Any}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.cone_objects</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Objects in diagram that will have explicit legs in limit cone.</p><p>In category theory, it is common practice to elide legs of limit cones that can be computed from other legs, especially for diagrams of certain fixed shapes. For example, when it taking a pullback (the limit of a cospan), the limit object is often treated as having two projections, rather than three. This function encodes such conventions by listing the objects in the diagram that will have corresponding legs in the limit object created by Catlab.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.cocone_objects-Tuple{Any}"><code>cocone_objects</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type" href="#Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type"><code>Catlab.CategoricalAlgebra.FreeDiagrams.diagram_type</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given a diagram in a category <span>$C$</span>, return Julia type of objects and morphisms in <span>$C$</span> as a tuple type of form <span>$Tuple{Ob,Hom}$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.feet-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.feet-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.feet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Feet of multispan or multicospan.</p><p>The feet of a multispan are the codomains of the <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>legs</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}" href="#Catlab.CategoricalAlgebra.FreeDiagrams.legs-Tuple{Multispan}"><code>Catlab.CategoricalAlgebra.FreeDiagrams.legs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Legs of multispan or multicospan.</p><p>The legs are the morphisms comprising the multi(co)span.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.left-Tuple{Multispan{Ob, Hom, &lt;:StaticArrays.StaticVector{2, Hom}} where {Ob, Hom}}" href="#Catlab.Theories.left-Tuple{Multispan{Ob, Hom, &lt;:StaticArrays.StaticVector{2, Hom}} where {Ob, Hom}}"><code>Catlab.Theories.left</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Left leg of span or cospan.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.right-Tuple{Multispan{Ob, Hom, &lt;:StaticArrays.StaticVector{2, Hom}} where {Ob, Hom}}" href="#Catlab.Theories.right-Tuple{Multispan{Ob, Hom, &lt;:StaticArrays.StaticVector{2, Hom}} where {Ob, Hom}}"><code>Catlab.Theories.right</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Right leg of span or cospan.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits" href="#Catlab.CategoricalAlgebra.Limits"><code>Catlab.CategoricalAlgebra.Limits</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Limits and colimits in a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.AbstractColimit" href="#Catlab.CategoricalAlgebra.Limits.AbstractColimit"><code>Catlab.CategoricalAlgebra.Limits.AbstractColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for colimit in a category.</p><p>The standard concrete subtype is <a href="#Catlab.CategoricalAlgebra.Limits.Colimit"><code>Colimit</code></a>, although for computational reasons certain categories may use different subtypes to include extra data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.AbstractLimit" href="#Catlab.CategoricalAlgebra.Limits.AbstractLimit"><code>Catlab.CategoricalAlgebra.Limits.AbstractLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for limit in a category.</p><p>The standard concrete subtype is <a href="#Catlab.CategoricalAlgebra.Limits.Limit"><code>Limit</code></a>, although for computational reasons certain categories may use different subtypes to include extra data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.Colimit" href="#Catlab.CategoricalAlgebra.Limits.Colimit"><code>Catlab.CategoricalAlgebra.Limits.Colimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Colimit in a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm" href="#Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm"><code>Catlab.CategoricalAlgebra.Limits.ColimitAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for computing colimits.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer" href="#Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer"><code>Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute pushout by composing a coproduct with a coequalizer.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer"><code>ComposeProductEqualizer</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer" href="#Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer"><code>Catlab.CategoricalAlgebra.Limits.ComposeProductEqualizer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute pullback by composing a product with an equalizer.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.ComposeCoproductCoequalizer"><code>ComposeCoproductCoequalizer</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.Limit" href="#Catlab.CategoricalAlgebra.Limits.Limit"><code>Catlab.CategoricalAlgebra.Limits.Limit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Limit in a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.LimitAlgorithm" href="#Catlab.CategoricalAlgebra.Limits.LimitAlgorithm"><code>Catlab.CategoricalAlgebra.Limits.LimitAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for computing limits.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.SpecializeColimit" href="#Catlab.CategoricalAlgebra.Limits.SpecializeColimit"><code>Catlab.CategoricalAlgebra.Limits.SpecializeColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-algorithm attempting to reduce general colimits to common special cases.</p><p>Dual to <a href="#Catlab.CategoricalAlgebra.Limits.SpecializeLimit"><code>SpecializeLimit</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.SpecializeLimit" href="#Catlab.CategoricalAlgebra.Limits.SpecializeLimit"><code>Catlab.CategoricalAlgebra.Limits.SpecializeLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-algorithm attempting to reduce general limits to common special cases.</p><p>Specifically, reduce limits of free diagrams that happen to be discrete to products. TODO: Handle pullbacks similarly.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit" href="#Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit"><code>Catlab.CategoricalAlgebra.Limits.ToBipartiteColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute a colimit by reducing the diagram to a free bipartite diagram.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit" href="#Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit"><code>Catlab.CategoricalAlgebra.Limits.ToBipartiteLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Compute a limit by reducing the diagram to a free bipartite diagram.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.can_pushout_complement-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.can_pushout_complement-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.can_pushout_complement</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Can a pushout complement be constructed for a composable pair?</p><p>Even in nice categories, this is not generally possible.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.colimit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Colimit of a diagram.</p><p>To define colimits in a category with objects <code>Ob</code>, override the method <code>colimit(::FreeDiagram{Ob})</code> for general colimits or <code>colimit(::D)</code> with suitable type <code>D &lt;: FixedShapeFreeDiagram{Ob}</code> for colimits of specific shape, such as coproducts or coequalizers.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}"><code>limit</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}" href="#Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}"><code>Catlab.CategoricalAlgebra.Limits.limit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Limit of a diagram.</p><p>To define limits in a category with objects <code>Ob</code>, override the method <code>limit(::FreeDiagram{Ob})</code> for general limits or <code>limit(::D)</code> with suitable type <code>D &lt;: FixedShapeFreeDiagram{Ob}</code> for limits of specific shape, such as products or equalizers.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}"><code>colimit</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.pullback-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.pullback-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.pullback</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pullback of a pair of morphisms with common codomain.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::Cospan{T})</code> and/or <code>limit(::Multicospan{T})</code> or, if you have already implemented products and equalizers, rely on the default implementation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.pushout-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.pushout-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.pushout</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pushout of a pair of morphisms with common domain.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::Span{T})</code> and/or <code>colimit(::Multispan{T})</code> or, if you have already implemented coproducts and coequalizers, rely on the default implementation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.pushout_complement-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.pushout_complement-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.pushout_complement</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pushout complement: extend composable pair to a pushout square.</p><p><a href="https://ncatlab.org/nlab/show/pushout+complement">Pushout complements</a> are the essential ingredient for double pushout (DPO) rewriting.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.universal" href="#Catlab.CategoricalAlgebra.Limits.universal"><code>Catlab.CategoricalAlgebra.Limits.universal</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Universal property of (co)limits.</p><p>Compute the morphism whose existence and uniqueness is guaranteed by the universal property of (co)limits.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.limit-Tuple{Any}"><code>limit</code></a>, <a href="#Catlab.CategoricalAlgebra.Limits.colimit-Tuple{Any}"><code>colimit</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.coequalizer-Tuple{Any, Any}" href="#Catlab.Theories.coequalizer-Tuple{Any, Any}"><code>Catlab.Theories.coequalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coequalizer of morphisms with common domain and codomain.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::ParallelPair{T})</code> or <code>colimit(::ParallelMorphisms{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.copair-Tuple{Any, Any}" href="#Catlab.Theories.copair-Tuple{Any, Any}"><code>Catlab.Theories.copair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Copairing of morphisms: universal property of coproducts/pushouts.</p><p>To implement for coproducts of type <code>T</code>, define the method <code>universal(::BinaryCoproduct{T}, ::Cospan{T})</code> and/or <code>universal(::Coproduct{T}, ::Multicospan{T})</code> and similarly for pushouts.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.coproduct-Tuple{Any, Any}" href="#Catlab.Theories.coproduct-Tuple{Any, Any}"><code>Catlab.Theories.coproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coproduct of objects.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::ObjectPair{T})</code> and/or <code>colimit(::DiscreteDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.create-Tuple{T} where T" href="#Catlab.Theories.create-Tuple{T} where T"><code>Catlab.Theories.create</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unique morphism out of an initial object.</p><p>To implement for a type <code>T</code>, define the method <code>universal(::Initial{T}, ::SMulticospan{0,T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.delete-Tuple{T} where T" href="#Catlab.Theories.delete-Tuple{T} where T"><code>Catlab.Theories.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unique morphism into a terminal object.</p><p>To implement for a type <code>T</code>, define the method <code>universal(::Terminal{T}, ::SMultispan{0,T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.equalizer-Tuple{Any, Any}" href="#Catlab.Theories.equalizer-Tuple{Any, Any}"><code>Catlab.Theories.equalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Equalizer of morphisms with common domain and codomain.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::ParallelPair{T})</code> and/or <code>limit(::ParallelMorphisms{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.factorize-Tuple{Equalizer, Any}" href="#Catlab.Theories.factorize-Tuple{Equalizer, Any}"><code>Catlab.Theories.factorize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Factor morphism through (co)equalizer, via the universal property.</p><p>To implement for equalizers of type <code>T</code>, define the method <code>universal(::Equalizer{T}, ::SMultispan{1,T})</code>. For coequalizers of type <code>T</code>, define the method <code>universal(::Coequalizer{T}, ::SMulticospan{1,T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.initial-Tuple{Type}" href="#Catlab.Theories.initial-Tuple{Type}"><code>Catlab.Theories.initial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initial object.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::EmptyDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.pair-Tuple{Any, Any}" href="#Catlab.Theories.pair-Tuple{Any, Any}"><code>Catlab.Theories.pair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pairing of morphisms: universal property of products/pullbacks.</p><p>To implement for products of type <code>T</code>, define the method <code>universal(::BinaryProduct{T}, ::Span{T})</code> and/or <code>universal(::Product{T}, ::Multispan{T})</code> and similarly for pullbacks.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.product-Tuple{Any, Any}" href="#Catlab.Theories.product-Tuple{Any, Any}"><code>Catlab.Theories.product</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Product of objects.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::ObjectPair{T})</code> and/or <code>limit(::DiscreteDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.terminal-Tuple{Type}" href="#Catlab.Theories.terminal-Tuple{Type}"><code>Catlab.Theories.terminal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Terminal object.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::EmptyDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.@cartesian_monoidal_instance</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define cartesian monoidal structure using limits.</p><p>Implements an instance of <a href="../theories/#Catlab.Theories.CartesianCategory"><code>CartesianCategory</code></a> assuming that finite products have been implemented following the limits interface.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance-Tuple{Any, Any}" href="#Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance-Tuple{Any, Any}"><code>Catlab.CategoricalAlgebra.Limits.@cocartesian_monoidal_instance</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define cocartesian monoidal structure using colimits.</p><p>Implements an instance of <a href="../theories/#Catlab.Theories.CocartesianCategory"><code>CocartesianCategory</code></a> assuming that finite coproducts have been implemented following the colimits interface.</p></div></section></article><h2 id="Categories"><a class="docs-heading-anchor" href="#Categories">Categories</a><a id="Categories-1"></a><a class="docs-heading-anchor-permalink" href="#Categories" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories" href="#Catlab.CategoricalAlgebra.Categories"><code>Catlab.CategoricalAlgebra.Categories</code></a> — <span class="docstring-category">Module</span></header><section><div><p>2-category of categories, functors, and natural transformations.</p><p>Categories in mathematics appear in the large, often as categories of sets with extra structure, and in the small, as algebraic structures that generalize groups, monoids, preorders, and graphs. This division manifests in Catlab as well. Large categories (in spirit, if not in the <a href="https://ncatlab.org/nlab/show/large+category">technical sense</a>) occur throughout Catlab as <code>@instance</code>s of the theory of categories. For computational reasons, small categories are usually presented by generators and relations.</p><p>This module provides a minimal interface to accomodate both situations. Category instances are supported through the wrapper type <a href="#Catlab.CategoricalAlgebra.Categories.TypeCat"><code>TypeCat</code></a>. Finitely presented categories are provided by another module, <a href="apis/@ref"><code>FinCats</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Cat" href="#Catlab.CategoricalAlgebra.Categories.Cat"><code>Catlab.CategoricalAlgebra.Categories.Cat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for a category.</p><p>The objects and morphisms in the category have Julia types <code>Ob</code> and <code>Hom</code>, respectively. Note that these types do <em>not</em> necessarily form an <code>@instance</code> of the theory of categories, as they may not meaningfully form a category outside the context of this object. For example, a finite category regarded as a reflexive graph with a composition operation might have type <code>Cat{Int,Int}</code>, where the objects and morphisms are numerical identifiers for vertices and edges in the graph.</p><p>The basic operations available in any category are: <a href="#Catlab.Theories.dom-Tuple{Cat, Any}"><code>dom</code></a>, <a href="#Catlab.Theories.codom-Tuple{Cat, Any}"><code>codom</code></a>, <a href="#Catlab.Theories.id-Tuple{Cat, Any}"><code>id</code></a>, <a href="#Catlab.Theories.compose-Tuple{Cat, Vararg{Any}}"><code>compose</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.CompositeFunctor" href="#Catlab.CategoricalAlgebra.Categories.CompositeFunctor"><code>Catlab.CategoricalAlgebra.Categories.CompositeFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Composite of functors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Functor" href="#Catlab.CategoricalAlgebra.Categories.Functor"><code>Catlab.CategoricalAlgebra.Categories.Functor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for a functor between categories.</p><p>A functor has a domain and a codomain (<a href="#Catlab.Theories.dom-Tuple{Cat, Any}"><code>dom</code></a> and <a href="#Catlab.Theories.codom-Tuple{Cat, Any}"><code>codom</code></a>), which are categories, and object and morphism maps, which can be evaluated using <a href="#Catlab.CategoricalAlgebra.Categories.ob_map-Tuple{Functor, Any}"><code>ob_map</code></a> and <a href="#Catlab.CategoricalAlgebra.Categories.hom_map-Tuple{Functor, Any}"><code>hom_map</code></a>. The functor object can also be called directly when the objects and morphisms have distinct Julia types. This is sometimes but not always the case (see <a href="#Catlab.CategoricalAlgebra.Categories.Cat"><code>Cat</code></a>), so when writing generic code one should prefer the <code>ob_map</code> and <code>hom_map</code> functions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.IdentityFunctor" href="#Catlab.CategoricalAlgebra.Categories.IdentityFunctor"><code>Catlab.CategoricalAlgebra.Categories.IdentityFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Identity functor on a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.Transformation" href="#Catlab.CategoricalAlgebra.Categories.Transformation"><code>Catlab.CategoricalAlgebra.Categories.Transformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for a natural transformation between functors.</p><p>A natural transformation <span>$α: F ⇒ G$</span> has a domain <span>$F$</span> and codomain <span>$G$</span> (<a href="#Catlab.Theories.dom-Tuple{Cat, Any}"><code>dom</code></a> and <a href="#Catlab.Theories.codom-Tuple{Cat, Any}"><code>codom</code></a>), which are functors <span>$F,G: C → D$</span> having the same domain <span>$C$</span> and codomain <span>$D$</span>. The transformation consists of a component <span>$αₓ: Fx → Gx$</span> in <span>$D$</span> for each object <span>$x ∈ C$</span>, accessible using <a href="#Catlab.CategoricalAlgebra.Categories.component"><code>component</code></a> or indexing notation (<code>Base.getindex</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.TypeCat" href="#Catlab.CategoricalAlgebra.Categories.TypeCat"><code>Catlab.CategoricalAlgebra.Categories.TypeCat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of Julia types regarded as a category.</p><p>The Julia types should form an <code>@instance</code> of the theory of categories (<code>Theories.Category</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.codom_ob-Tuple{Transformation}" href="#Catlab.CategoricalAlgebra.Categories.codom_ob-Tuple{Transformation}"><code>Catlab.CategoricalAlgebra.Categories.codom_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Codomain object of natural transformation.</p><p>Given <span>$α: F ⇒ G: C → D$</span>, this function returns <span>$D$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.component" href="#Catlab.CategoricalAlgebra.Categories.component"><code>Catlab.CategoricalAlgebra.Categories.component</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Component of natural transformation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.dom_ob-Tuple{Transformation}" href="#Catlab.CategoricalAlgebra.Categories.dom_ob-Tuple{Transformation}"><code>Catlab.CategoricalAlgebra.Categories.dom_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Domain object of natural transformation.</p><p>Given <span>$α: F ⇒ G: C → D$</span>, this function returns <span>$C$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.hom_map-Tuple{Functor, Any}" href="#Catlab.CategoricalAlgebra.Categories.hom_map-Tuple{Functor, Any}"><code>Catlab.CategoricalAlgebra.Categories.hom_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate functor on morphism.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.is_hom_equal-Tuple{Cat, Any, Any}" href="#Catlab.CategoricalAlgebra.Categories.is_hom_equal-Tuple{Cat, Any, Any}"><code>Catlab.CategoricalAlgebra.Categories.is_hom_equal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Are two morphisms in a category equal?</p><p>By default, just checks for equality of Julia objects using <span>$==$</span>. In some categories, checking equality of morphisms may involve nontrivial reasoning.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Categories.ob_map-Tuple{Functor, Any}" href="#Catlab.CategoricalAlgebra.Categories.ob_map-Tuple{Functor, Any}"><code>Catlab.CategoricalAlgebra.Categories.ob_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate functor on object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.codom-Tuple{Cat, Any}" href="#Catlab.Theories.codom-Tuple{Cat, Any}"><code>Catlab.Theories.codom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Codomain of morphism in category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.compose-Tuple{Cat, Vararg{Any}}" href="#Catlab.Theories.compose-Tuple{Cat, Vararg{Any}}"><code>Catlab.Theories.compose</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compose morphisms in a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.dom-Tuple{Cat, Any}" href="#Catlab.Theories.dom-Tuple{Cat, Any}"><code>Catlab.Theories.dom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Domain of morphism in category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.hom-Tuple{Cat, Any}" href="#Catlab.Theories.hom-Tuple{Cat, Any}"><code>Catlab.Theories.hom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coerce or look up morphism in category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.id-Tuple{Cat, Any}" href="#Catlab.Theories.id-Tuple{Cat, Any}"><code>Catlab.Theories.id</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Identity morphism on object in category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.ob-Tuple{Cat, Any}" href="#Catlab.Theories.ob-Tuple{Cat, Any}"><code>Catlab.Theories.ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coerce or look up object in category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats" href="#Catlab.CategoricalAlgebra.FinCats"><code>Catlab.CategoricalAlgebra.FinCats</code></a> — <span class="docstring-category">Module</span></header><section><div><p>2-category of finitely presented categories.</p><p>This module is for the 2-category <strong>Cat</strong> what the module <a href="apis/@ref">`FinSets</a> is for the category <strong>Set</strong>: a finitary, combinatorial setting where explicit calculations can be carried out. We emphasize that the prefix <code>Fin</code> means &quot;finitely presented,&quot; not &quot;finite,&quot; as finite categories are too restrictive a notion for many purposes. For example, the free category on a graph is finite if and only if the graph is DAG, which is a fairly special condition. This usage of <code>Fin</code> is also consistent with <code>FinSet</code> because for sets, being finite and being finitely presented are equivalent.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCat" href="#Catlab.CategoricalAlgebra.FinCats.FinCat"><code>Catlab.CategoricalAlgebra.FinCats.FinCat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for finitely presented category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatGraph" href="#Catlab.CategoricalAlgebra.FinCats.FinCatGraph"><code>Catlab.CategoricalAlgebra.FinCats.FinCatGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for category backed by finite generating graph.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq" href="#Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq"><code>Catlab.CategoricalAlgebra.FinCats.FinCatGraphEq</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Category presented by a finite graph together with path equations.</p><p>The objects of the category are vertices in the graph and the morphisms are paths, quotiented by the congruence relation generated by the path equations. See (Spivak, 2014, <em>Category theory for the sciences</em>, §4.5).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph" href="#Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph"><code>Catlab.CategoricalAlgebra.FinCats.FinCatPathGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for category whose morphisms are paths in a graph.</p><p>(Or equivalence classes of paths in a graph, but we compute with</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinCatPresentation" href="#Catlab.CategoricalAlgebra.FinCats.FinCatPresentation"><code>Catlab.CategoricalAlgebra.FinCats.FinCatPresentation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Category defined by a <code>Presentation</code> object.</p><p>The presentation type can, of course, be a category (<code>Theories.Category</code>). It can also be a schema (<code>Theories.Schema</code>). In this case, the schema&#39;s objects and attribute types are regarded as the category&#39;s objects and the schema&#39;s morphisms, attributes, and attribute types as the category&#39;s morphisms (where the attribute types are identity morphisms). When the schema is formalized as a profunctor whose codomain category is discrete, this amounts to taking the collage of the profunctor.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinDomFunctor" href="#Catlab.CategoricalAlgebra.FinCats.FinDomFunctor"><code>Catlab.CategoricalAlgebra.FinCats.FinDomFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A functor out of a finitely presented category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap" href="#Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap"><code>Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Functor out of a finitely presented category given by explicit mappings.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinFunctor" href="#Catlab.CategoricalAlgebra.FinCats.FinFunctor"><code>Catlab.CategoricalAlgebra.FinCats.FinFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A functor between finitely presented categories.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinTransformation" href="#Catlab.CategoricalAlgebra.FinCats.FinTransformation"><code>Catlab.CategoricalAlgebra.FinCats.FinTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A natural transformation whose domain category is finitely generated.</p><p>This type is for natural transformations <span>$α: F ⇒ G: C → D$</span> such that the domain category <span>$C$</span> is finitely generated. Such a natural transformation is given by a finite amount of data (one morphism in <span>$D$</span> for each generating object of <span>$C$</span>) and its naturality is verified by finitely many equations (one equation for each generating morphism of <span>$C$</span>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FinTransformationMap" href="#Catlab.CategoricalAlgebra.FinCats.FinTransformationMap"><code>Catlab.CategoricalAlgebra.FinCats.FinTransformationMap</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Natural transformation with components given by explicit mapping.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.FreeCatGraph" href="#Catlab.CategoricalAlgebra.FinCats.FreeCatGraph"><code>Catlab.CategoricalAlgebra.FinCats.FreeCatGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Free category generated by a finite graph.</p><p>The objects of the free category are vertices in the graph and the morphisms are (possibly empty) paths.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.Path" href="#Catlab.CategoricalAlgebra.FinCats.Path"><code>Catlab.CategoricalAlgebra.FinCats.Path</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Path in a graph.</p><p>The path is allowed to be empty but always has definite start and end points (source and target vertices).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.collect_hom-Tuple{Functor{Dom} where Dom&lt;:FinCat}" href="#Catlab.CategoricalAlgebra.FinCats.collect_hom-Tuple{Functor{Dom} where Dom&lt;:FinCat}"><code>Catlab.CategoricalAlgebra.FinCats.collect_hom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Collect assignments of functor&#39;s morphism map as a vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.collect_ob-Tuple{Functor{Dom} where Dom&lt;:FinCat}" href="#Catlab.CategoricalAlgebra.FinCats.collect_ob-Tuple{Functor{Dom} where Dom&lt;:FinCat}"><code>Catlab.CategoricalAlgebra.FinCats.collect_ob</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Collect assignments of functor&#39;s object map as a vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.components-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:FinCat, D&lt;:Cat, Dom&lt;:(Functor{Dom} where Dom&lt;:FinCat), Codom&lt;:(Functor{Dom} where Dom&lt;:FinCat)}}" href="#Catlab.CategoricalAlgebra.FinCats.components-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:FinCat, D&lt;:Cat, Dom&lt;:(Functor{Dom} where Dom&lt;:FinCat), Codom&lt;:(Functor{Dom} where Dom&lt;:FinCat)}}"><code>Catlab.CategoricalAlgebra.FinCats.components</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Components of a natural transformation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.force-Tuple{Functor{Dom} where Dom&lt;:FinCat}" href="#Catlab.CategoricalAlgebra.FinCats.force-Tuple{Functor{Dom} where Dom&lt;:FinCat}"><code>Catlab.CategoricalAlgebra.FinCats.force</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Force evaluation of lazily defined function or functor.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.graph-Tuple{FinCatGraph}" href="#Catlab.CategoricalAlgebra.FinCats.graph-Tuple{FinCatGraph}"><code>Catlab.CategoricalAlgebra.FinCats.graph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generating graph for a finitely presented category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.hom_generators" href="#Catlab.CategoricalAlgebra.FinCats.hom_generators"><code>Catlab.CategoricalAlgebra.FinCats.hom_generators</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Morphism generators of finitely presented category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_discrete-Tuple{FinCat}" href="#Catlab.CategoricalAlgebra.FinCats.is_discrete-Tuple{FinCat}"><code>Catlab.CategoricalAlgebra.FinCats.is_discrete</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the category discrete?</p><p>A category is <em>discrete</em> if it is has no non-identity morphisms.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_free-Tuple{FinCat}" href="#Catlab.CategoricalAlgebra.FinCats.is_free-Tuple{FinCat}"><code>Catlab.CategoricalAlgebra.FinCats.is_free</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the category freely generated?</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_functorial-Tuple{Functor{Dom} where Dom&lt;:FinCat}" href="#Catlab.CategoricalAlgebra.FinCats.is_functorial-Tuple{Functor{Dom} where Dom&lt;:FinCat}"><code>Catlab.CategoricalAlgebra.FinCats.is_functorial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the purported functor on a presented category functorial?</p><p>This function checks that functor preserves domains and codomains. When <code>check_equations</code> is <code>true</code> (the default), it also checks that the functor preserves all equations in the domain category. Note that in some cases this may not be possible.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:FinCat, D&lt;:Cat, Dom&lt;:(Functor{Dom} where Dom&lt;:FinCat), Codom&lt;:(Functor{Dom} where Dom&lt;:FinCat)}}"><code>is_natural</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:FinCat, D&lt;:Cat, Dom&lt;:(Functor{Dom} where Dom&lt;:FinCat), Codom&lt;:(Functor{Dom} where Dom&lt;:FinCat)}}" href="#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:FinCat, D&lt;:Cat, Dom&lt;:(Functor{Dom} where Dom&lt;:FinCat), Codom&lt;:(Functor{Dom} where Dom&lt;:FinCat)}}"><code>Catlab.CategoricalAlgebra.FinCats.is_natural</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the transformation between <code>FinDomFunctors</code> a natural transformation?</p><p>This function uses the fact that to check whether a transformation is natural, it suffices to check the naturality equations on a generating set of morphisms of the domain category. In some cases, checking the equations may be expensive or impossible. When the keyword argument <code>check_equations</code> is <code>false</code>, only the domains and codomains of the components are checked.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.FinCats.is_functorial-Tuple{Functor{Dom} where Dom&lt;:FinCat}"><code>is_functorial</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.ob_generators" href="#Catlab.CategoricalAlgebra.FinCats.ob_generators"><code>Catlab.CategoricalAlgebra.FinCats.ob_generators</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Object generators of finitely presented category.</p><p>The object generators are almost always the same as the objects. In principle, however, it is possible to have equations between objects, so that there are fewer objects than object generators.</p></div></section></article><h2 id="Acsets"><a class="docs-heading-anchor" href="#Acsets">Acsets</a><a id="Acsets-1"></a><a class="docs-heading-anchor-permalink" href="#Acsets" title="Permalink"></a></h2><h3 id="Overview-and-Theory"><a class="docs-heading-anchor" href="#Overview-and-Theory">Overview and Theory</a><a id="Overview-and-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-and-Theory" title="Permalink"></a></h3><p>For an in depth look into the theory behind acsets, we refer the reader to <a href="https://arxiv.org/abs/2106.04703">our paper</a> on the subject, which also gives some sense as to how the implementation works. Here, we give a brief tutorial before the the API documentation.</p><p>The most essential part of the acset machinery is the schema. The schema <em>parameterizes</em> the acset: each schema corresponds to a different type of acset. Schemas consist of four parts.</p><ul><li>Objects <span>$X,Y$</span> (<code>(X,Y,Z)::Ob</code>)</li><li>Homomorphisms <span>$f \colon X \to Y$</span> (<code>f :: Hom(X,Y)</code>), which go from objects to objects</li><li>Attribute types <span>$\mathtt{T}$</span> (<code>T :: AttrType</code>)</li><li>Attributes <span>$a \colon X \to \mathtt{T}$</span> (<code>a :: Attr(X,T)</code>), which go from objects to data types</li></ul><p>For those with a categorical background, a schema is a presentation of a category <span>$|S|$</span> along with a functor <span>$S$</span> from <span>$|S|$</span> to the arrow category <span>$0 \to 1$</span>, such that <span>$S^{-1}(1)$</span> is discrete.</p><p>An acset <span>$F$</span> on a schema consists of...</p><ul><li>a set <span>$F(X)$</span> of &quot;primary keys&quot; for each object</li><li>a function <span>$F(f) \colon F(X) \to F(Y)$</span> for each morphism</li><li>a Julia data type <span>$F(\mathtt{T})$</span> for each data type <span>$\mathtt{T}$</span></li><li>a function <span>$F(a) \colon F(X) \to F(\mathtt{T})$</span> for each attribute <span>$a$</span>.</li></ul><p>For those with a categorical background, an acset on a schema <span>$S$</span> consists of a functor from <span>$S$</span> to <span>$\mathsf{Set}$</span>, such that objects in <span>$S^{-1}(0)$</span> map to finite sets, and objects in <span>$S^{-1}(1)$</span> map to sets that represent types. For any particular functor <span>$K \colon S^{-1}(1) \to \mathsf{Set}$</span>, we can also take the category of acsets that restrict to this map on <span>$S^{-1}$</span>.</p><p>We can also add relations to this presentation, but we currently do nothing with those relations in the implementation; they mostly serve as documentation.</p><p>We will now give an example of how this all works in practice.</p><pre><code class="language-julia">using Catlab, Catlab.CategoricalAlgebra

# Write down the schema for a weighted graph
@present TheoryWeightedGraph(FreeSchema) begin
  V::Ob
  E::Ob
  src::Hom(E,V)
  tgt::Hom(E,V)
  T::AttrType
  weight::Attr(E,T)
end

# Construct the type used to store acsets on the previous schema
# We *index* src and tgt, which means that we store not only
# the forwards map, but also the backwards map.
@acset_type WeightedGraph(TheoryWeightedGraph, index=[:src,:tgt])

# Construct a weighted graph, with floats as edge weights
g = @acset WeightedGraph{Float64} begin
  V = 4
  E = 5
  src = [1,1,1,2,3]
  tgt = [2,3,4,4,4]
  weight = [7.2, 9.3, 9.4, 0.1, 42.0]
end</code></pre><div class="c-set">
<span class="c-set-summary">Main.##ex-#331.WeightedGraph{Float64} with elements V = 1:4, E = 1:5</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowNumber">E</th>
      <th style = "text-align: right;">src</th>
      <th style = "text-align: right;">tgt</th>
      <th style = "text-align: right;">weight</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowNumber">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">7.2</td>
    </tr>
    <tr>
      <td class = "rowNumber">2</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">9.3</td>
    </tr>
    <tr>
      <td class = "rowNumber">3</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">9.4</td>
    </tr>
    <tr>
      <td class = "rowNumber">4</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">0.1</td>
    </tr>
    <tr>
      <td class = "rowNumber">5</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">42.0</td>
    </tr>
  </tbody>
</table>
</div>
<h3 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h3><p>We first give an overview of the data types used in the acset machinery.</p><p><code>FreeSchema</code> A finite presentation of a category that will be used as the schema of a database in the <em>algebraic databases</em> conception of categorical database theory. Functors out of a schema into FinSet are combinatorial structures over the schema. Attributes in a schema allow you to encode numerical (any julia type) into the database. You can find several examples of schemas in <code>Catlab.Graphs</code> where they define categorical versions of graph theory.</p><p><code>CSet/AttributedCSet</code> is a struct/constructors whose values (tables, indices) are parameterized by a CatDesc/AttrDesc. These are in memory databases over the schema equiped with <code>ACSetTranformations</code> as natural transformations that encode relationships between database instances.</p><p><code>CSetType/AttributedCSetType</code>provides a function to construct a julia type for ACSet instances, parameterized by CatDesc/AttrDesc. This function constructs the new type at runtime. In order to have the interactive nature of Julia, and to dynamically construct schemas based on runtime values, we need to define new Julia types at runtime. This function converts the schema spec to the corresponding Julia type.</p><p><code>CatDesc/AttrDesc</code> the encoding of a schema into a Julia type. These exist because Julia only allows certain kinds of data in the parameter of a dependent type. Thus, we have to serialize a schema into those primitive data types so that we can use them to parameterize the ACSet type over the schema. This is an implementation detail subject to complete overhaul.</p><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets" href="#Catlab.CategoricalAlgebra.CSets"><code>Catlab.CategoricalAlgebra.CSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Categories of C-sets and attributed C-sets.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetHomomorphismAlgorithm" href="#Catlab.CategoricalAlgebra.CSets.ACSetHomomorphismAlgorithm"><code>Catlab.CategoricalAlgebra.CSets.ACSetHomomorphismAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for finding homomorphisms between attributed <span>$C$</span>-sets.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.ACSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.ACSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Transformation between attributed C-sets.</p><p>Homomorphisms of attributed C-sets generalize homomorphisms of C-sets (<a href="#Catlab.CategoricalAlgebra.CSets.CSetTransformation"><code>CSetTransformation</code></a>), which the user should understand before reading further.</p><p>A homomorphism of attributed C-sets with schema S: C ↛ A (a profunctor) is a natural transformation between the corresponding functors col(S) → Set, where col(S) is the collage of S. When the components on attribute types, indexed by objects of A, are all identity functions, the morphism is called <em>tight</em>; in general, it is called <em>loose</em>. The terms &quot;tight&quot; and &quot;loose&quot; come from what the nLab calls an <a href="https://ncatlab.org/nlab/show/M-category">&quot;M-category&quot;</a>. The category of acsets on a fixed schema S is an M-category. Calling <code>ACSetTransformation</code> will construct a tight or loose morphism as appropriate, depending on which components are specified.</p><p>Since every tight morphism can be considered a loose one, the distinction between tight and loose may seem an unimportant technicality, but it can have important consequences because choosing one or the other greatly affects limits and colimits of acsets. In practice, the tight morphisms suffice for most purposes, including computing colimits. However, when computing limits of acsets, the loose morphism are usually preferable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.BacktrackingSearch" href="#Catlab.CategoricalAlgebra.CSets.BacktrackingSearch"><code>Catlab.CategoricalAlgebra.CSets.BacktrackingSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Find attributed <span>$C$</span>-set homomorphisms using backtracking search.</p><p>This procedure uses the classic backtracking search algorithm for a combinatorial constraint satisfaction problem (CSP). As is well known, the homomorphism problem for relational databases is reducible to CSP. Since the C-set homomorphism problem is &quot;the same&quot; as the database homomorphism problem (insofar as attributed C-sets are &quot;the same&quot; as relational databases), it is also reducible to CSP. Backtracking search for CSP is described in many computer science textbooks, such as (Russell &amp; Norvig 2010, <em>Artificial Intelligence</em>, Third Ed., Chapter 6: Constraint satisfaction problems, esp. Algorithm 6.5). In our implementation, the search tree is ordered using the popular heuristic of &quot;minimum remaining values&quot; (MRV), also known as &quot;most constrained variable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.CSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.CSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.CSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Transformation between C-sets.</p><p>Recall that a C-set homomorphism is a natural transformation: a transformation between functors C → Set satisfying the naturality axiom for every (generating) morphism in C.</p><p>This data type records the data of a C-set transformation. Naturality is not strictly enforced but is expected to be satisfied. It can be checked using the function <a href="#Catlab.CategoricalAlgebra.FinCats.is_natural-Tuple{Transformation{C, D, Dom, Codom} where {C&lt;:FinCat, D&lt;:Cat, Dom&lt;:(Functor{Dom} where Dom&lt;:FinCat), Codom&lt;:(Functor{Dom} where Dom&lt;:FinCat)}}"><code>is_natural</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.HomomorphismQuery" href="#Catlab.CategoricalAlgebra.CSets.HomomorphismQuery"><code>Catlab.CategoricalAlgebra.CSets.HomomorphismQuery</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Find attributed <span>$C$</span>-set homomorphisms using a conjunctive query.</p><p>This algorithm evaluates a conjunctive query (limit in <code>FinSet</code>) to find all homomorphisms between two <span>$C$</span>-sets. In fact, conjunctive queries are exactly the <em>representable</em> functors from <span>$C$</span>-sets to sets, so every conjunctive query arises in this way, with the caveat that conjunctive queries may correspond to to infinite <span>$C$</span>-sets when <span>$C$</span> is infinite (but possibly finitely presented).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.LooseACSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.LooseACSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.LooseACSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Loose transformation between attributed C-sets.</p><p>See <a href="apis/@ref"><code>ACSetTranformation</code></a> for the distinction between tight and loose.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.SubCSet" href="#Catlab.CategoricalAlgebra.CSets.SubCSet"><code>Catlab.CategoricalAlgebra.CSets.SubCSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Sub-C-set of a C-set.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.TightACSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.TightACSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.TightACSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tight transformation between attributed C-sets.</p><p>See <a href="apis/@ref"><code>ACSetTranformation</code></a> for the distinction between tight and loose.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.copy_parts!-Tuple{ACSet, Functor{Dom} where Dom&lt;:FinCat}" href="#Catlab.ACSetInterface.copy_parts!-Tuple{ACSet, Functor{Dom} where Dom&lt;:FinCat}"><code>Catlab.ACSetInterface.copy_parts!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Copy parts from a set-valued <code>FinDomFunctor</code> to an <code>ACSet</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.generate_json_acset-Tuple{T} where T&lt;:ACSet" href="#Catlab.CategoricalAlgebra.CSets.generate_json_acset-Tuple{T} where T&lt;:ACSet"><code>Catlab.CategoricalAlgebra.CSets.generate_json_acset</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Serialize an ACSet object to a JSON string</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.homomorphism</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find a homomorphism between two attributed <span>$C$</span>-sets.</p><p>Returns <code>nothing</code> if no homomorphism exists. For many categories <span>$C$</span>, the <span>$C$</span>-set homomorphism problem is NP-complete and thus this procedure generally runs in exponential time. It works best when the domain object is small.</p><p>To restrict to <em>monomorphisms</em>, or homomorphisms whose components are all injective functions, set the keyword argument <code>monic=true</code>. To restrict only certain components to be injective or bijective, use <code>monic=[...]</code> or <code>iso=[...]</code>. For example, setting <code>monic=[:V]</code> for a graph homomorphism ensures that the vertex map is injective but imposes no constraints on the edge map.</p><p>To restrict the homomorphism to a given partial assignment, set the keyword argument <code>initial</code>. For example, to fix the first source vertex to the third target vertex in a graph homomorphism, set <code>initial=(V=Dict(1 =&gt; 3),)</code>.</p><p>Use the keyword argument <code>alg</code> to set the homomorphism-finding algorithm. By default, a backtracking search algorithm is used (<a href="#Catlab.CategoricalAlgebra.CSets.BacktrackingSearch"><code>BacktrackingSearch</code></a>).</p><p>See also: <a href="#Catlab.CategoricalAlgebra.CSets.homomorphisms-Tuple{ACSet, ACSet}"><code>homomorphisms</code></a>, <a href="#Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{ACSet, ACSet}"><code>isomorphism</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.homomorphisms-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.homomorphisms-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.homomorphisms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find all homomorphisms between two attributed <span>$C$</span>-sets.</p><p>This function is at least as expensive as <a href="#Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{ACSet, ACSet}"><code>homomorphism</code></a> and when no homomorphisms exist, it is exactly as expensive.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.is_homomorphic-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.is_homomorphic-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.is_homomorphic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the first attributed <span>$C$</span>-set homomorphic to the second?</p><p>This function generally reduces to <a href="#Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{ACSet, ACSet}"><code>homomorphism</code></a> but certain algorithms may have minor optimizations.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.is_isomorphic-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.is_isomorphic-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.is_isomorphic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Are the two attributed <span>$C$</span>-sets isomorphic?</p><p>This function generally reduces to <a href="#Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{ACSet, ACSet}"><code>isomorphism</code></a> but certain algorithms may have minor optimizations.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.isomorphism</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find an isomorphism between two attributed <span>$C$</span>-sets, if one exists.</p><p>See <a href="#Catlab.CategoricalAlgebra.CSets.homomorphism-Tuple{ACSet, ACSet}"><code>homomorphism</code></a> for more information about the algorithms involved.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.isomorphisms-Tuple{ACSet, ACSet}" href="#Catlab.CategoricalAlgebra.CSets.isomorphisms-Tuple{ACSet, ACSet}"><code>Catlab.CategoricalAlgebra.CSets.isomorphisms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find all isomorphisms between two attributed <span>$C$</span>-sets.</p><p>This function is at least as expensive as <a href="#Catlab.CategoricalAlgebra.CSets.isomorphism-Tuple{ACSet, ACSet}"><code>isomorphism</code></a> and when no homomorphisms exist, it is exactly as expensive.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.parse_json_acset-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T&lt;:ACSet" href="#Catlab.CategoricalAlgebra.CSets.parse_json_acset-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T&lt;:ACSet"><code>Catlab.CategoricalAlgebra.CSets.parse_json_acset</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Deserialize a dictionary from a parsed JSON string to an object of the given ACSet type</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.parse_json_acset-Union{Tuple{T}, Tuple{Type{T}, String}} where T&lt;:ACSet" href="#Catlab.CategoricalAlgebra.CSets.parse_json_acset-Union{Tuple{T}, Tuple{Type{T}, String}} where T&lt;:ACSet"><code>Catlab.CategoricalAlgebra.CSets.parse_json_acset</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Deserialize a JSON string to an object of the given ACSet type</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.read_json_acset-Union{Tuple{T}, Tuple{Type{T}, String}} where T&lt;:ACSet" href="#Catlab.CategoricalAlgebra.CSets.read_json_acset-Union{Tuple{T}, Tuple{Type{T}, String}} where T&lt;:ACSet"><code>Catlab.CategoricalAlgebra.CSets.read_json_acset</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read a JSON file to an object of the given ACSet type</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.write_json_acset-Union{Tuple{T}, Tuple{T, AbstractString}} where T&lt;:ACSet" href="#Catlab.CategoricalAlgebra.CSets.write_json_acset-Union{Tuple{T}, Tuple{T, AbstractString}} where T&lt;:ACSet"><code>Catlab.CategoricalAlgebra.CSets.write_json_acset</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Serialize an ACSet object to a JSON file</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans" href="#Catlab.CategoricalAlgebra.StructuredCospans"><code>Catlab.CategoricalAlgebra.StructuredCospans</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Structured cospans.</p><p>This module provides a generic interface for structured cospans with a concrete implementation for attributed C-sets.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structured cospan.</p><p>The first type parameter <code>L</code> encodes a functor L: A → X from the base category <code>A</code>, often FinSet, to a category <code>X</code> with &quot;extra structure.&quot; An L-structured cospan is then a cospan in X whose feet are images under L of objects in A. The category X is assumed to have pushouts.</p><p>Structured cospans form a double category with no further assumptions on the functor L. To obtain a symmetric monoidal double category, L must preserve finite coproducts. In practice, L usually has a right adjoint R: X → A, which implies that L preserves all finite colimits. It also allows structured cospans to be constructed more conveniently from an object x in X plus a cospan in A with apex R(x).</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan"><code>StructuredMulticospan</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Any, Multicospan{Ob, Hom, &lt;:StaticArrays.StaticVector{2, Hom}} where {Ob, Hom}}} where L" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Any, Multicospan{Ob, Hom, &lt;:StaticArrays.StaticVector{2, Hom}} where {Ob, Hom}}} where L"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct structured cospan in R-form.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Multicospan{Ob, Hom, &lt;:StaticArrays.StaticVector{2, Hom}} where {Ob, Hom}, StaticArrays.StaticVector{2}}} where L" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan-Union{Tuple{L}, Tuple{Multicospan{Ob, Hom, &lt;:StaticArrays.StaticVector{2, Hom}} where {Ob, Hom}, StaticArrays.StaticVector{2}}} where L"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct structured cospan in L-form.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object in the category of L-structured cospans.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structured multicospan.</p><p>A structured multicospan is like a structured cospan except that it may have a number of legs different than two.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospan"><code>StructuredCospan</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan-Union{Tuple{L}, Tuple{Any, Multicospan}} where L" href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan-Union{Tuple{L}, Tuple{Any, Multicospan}} where L"><code>Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct structured multicospan in R-form.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S&lt;:Catlab.Theories.SchemaDescType, X&lt;:(StructACSet{S})}" href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S&lt;:Catlab.Theories.SchemaDescType, X&lt;:(StructACSet{S})}"><code>Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create types for open attributed C-sets from an attributed C-set type.</p><p>Note: the type passed in should <em>not</em> be instantiated with concrete attribute types.</p><p>The resulting types, for objects and morphisms, each have the same type parameters for data types as the original type.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S&lt;:(Catlab.Theories.SchemaDescType{obs, homs, (), ()} where {obs, homs}), X&lt;:(StructCSet{S})}"><code>OpenCSetTypes</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S&lt;:(Catlab.Theories.SchemaDescType{obs, homs, (), ()} where {obs, homs}), X&lt;:(StructCSet{S})}" href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S&lt;:(Catlab.Theories.SchemaDescType{obs, homs, (), ()} where {obs, homs}), X&lt;:(StructCSet{S})}"><code>Catlab.CategoricalAlgebra.StructuredCospans.OpenCSetTypes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create types for open C-sets from a C-set type.</p><p>Returns two types, for objects, a subtype of <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredCospanOb"><code>StructuredCospanOb</code></a>, and for morphisms, a subtype of <a href="#Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan"><code>StructuredMulticospan</code></a>.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.StructuredCospans.OpenACSetTypes-Union{Tuple{X}, Tuple{S}, Tuple{Type{X}, Symbol}} where {S&lt;:Catlab.Theories.SchemaDescType, X&lt;:(StructACSet{S})}"><code>OpenACSetTypes</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.acset_schema" href="#Catlab.ACSetInterface.acset_schema"><code>Catlab.ACSetInterface.acset_schema</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get the schema of an acset at runtime.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.add_part!-Tuple{Any, Symbol, Vararg{Any}}" href="#Catlab.ACSetInterface.add_part!-Tuple{Any, Symbol, Vararg{Any}}"><code>Catlab.ACSetInterface.add_part!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add part of given type to acset, optionally setting its subparts.</p><p>Returns the ID of the added part.</p><p>See also: <a href="#Catlab.ACSetInterface.add_parts!"><code>add_parts!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.add_parts!" href="#Catlab.ACSetInterface.add_parts!"><code>Catlab.ACSetInterface.add_parts!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Add parts of given type to acset, optionally setting their subparts.</p><p>Returns the range of IDs for the added parts.</p><p>See also: <a href="#Catlab.ACSetInterface.add_part!-Tuple{Any, Symbol, Vararg{Any}}"><code>add_part!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.copy_parts!" href="#Catlab.ACSetInterface.copy_parts!"><code>Catlab.ACSetInterface.copy_parts!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Copy parts from a C-set to a C′-set.</p><p>The selected parts must belong to both schemas. All subparts common to the selected parts, including data attributes, are preserved. Thus, if the selected parts form a sub-C-set, then the whole sub-C-set is preserved. On the other hand, if the selected parts do <em>not</em> form a sub-C-set, then some copied parts will have undefined subparts.</p><p>TODO: handle colons</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.copy_parts_only!" href="#Catlab.ACSetInterface.copy_parts_only!"><code>Catlab.ACSetInterface.copy_parts_only!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Copy parts from a C-set to a C′-set, ignoring all non-data subparts.</p><p>The selected parts must belong to both schemas. Attributes common to both schemas are also copied, but no other subparts are copied.</p><p>See also: <a href="#Catlab.ACSetInterface.copy_parts!"><code>copy_parts!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.has_part" href="#Catlab.ACSetInterface.has_part"><code>Catlab.ACSetInterface.has_part</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Whether an acset has a part with the given name.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.incident" href="#Catlab.ACSetInterface.incident"><code>Catlab.ACSetInterface.incident</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get superparts incident to part in acset.</p><p>If the subpart is indexed, this takes constant time; otherwise, it takes linear time. As with <a href="#Catlab.ACSetInterface.subpart"><code>subpart</code></a>, both single and vectorized access, as well as chained access, are supported. Note that sequences of morphisms are supplied in the usual left-to-right order, so that</p><pre><code class="language-none">incident(g, x, [:src, :vattr])</code></pre><p>returns the list of all edges whose source vertex has vertex attribute <code>x</code>.</p><p>Note that when the subpart is indexed, this function returns a view of the underlying index, which should not be mutated. To ensure that a fresh copy is returned, regardless of whether indexing is enabled, set the keyword argument <code>copy=true</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.nparts" href="#Catlab.ACSetInterface.nparts"><code>Catlab.ACSetInterface.nparts</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Number of parts of given type in an acset.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.parts-Tuple{Any, Any}" href="#Catlab.ACSetInterface.parts-Tuple{Any, Any}"><code>Catlab.ACSetInterface.parts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parts of given type in an acset.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.rem_part!" href="#Catlab.ACSetInterface.rem_part!"><code>Catlab.ACSetInterface.rem_part!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Remove part from a C-set.</p><p>The part is removed using the &quot;pop and swap&quot; strategy familiar from <a href="https://github.com/JuliaGraphs/LightGraphs.jl">LightGraphs.jl</a>, where the &quot;removed&quot; part is actually replaced by the last part, which is then deleted. This strategy has important performance benefits since only the last part must be assigned a new ID, as opposed to assigning new IDs to <em>every</em> part following the removed part.</p><p>The removal operation is <em>not</em> recursive. When a part is deleted, any superparts incident to it are retained, but their subparts become undefined (equal to the integer zero). For example, in a graph, if you call <code>rem_part!</code> on a vertex, the edges incident the <code>src</code> and/or <code>tgt</code> vertices of the edge become undefined but the edge itself is not deleted.</p><p>Indexing has both positive and negative impacts on performance. On the one hand, indexing reduces the cost of finding affected superparts from linear time to constant time. On the other hand, the indices of subparts must be updated when the part is removed. For example, in a graph, indexing <code>src</code> and <code>tgt</code> makes removing vertices faster but removing edges (slightly) slower.</p><p>See also: <a href="#Catlab.ACSetInterface.rem_parts!-Tuple{Any, Any, Any}"><code>rem_parts!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.rem_parts!-Tuple{Any, Any, Any}" href="#Catlab.ACSetInterface.rem_parts!-Tuple{Any, Any, Any}"><code>Catlab.ACSetInterface.rem_parts!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Remove parts from a C-set.</p><p>The parts must be supplied in sorted order, without duplicates.</p><p>See also: <a href="#Catlab.ACSetInterface.rem_part!"><code>rem_part!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.set_subpart!" href="#Catlab.ACSetInterface.set_subpart!"><code>Catlab.ACSetInterface.set_subpart!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Mutate subpart of a part in a C-set.</p><p>Both single and vectorized assignment are supported.</p><p>See also: <a href="#Catlab.ACSetInterface.set_subparts!-Tuple{Any, Any, NamedTuple}"><code>set_subparts!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.set_subparts!-Tuple{Any, Any, NamedTuple}" href="#Catlab.ACSetInterface.set_subparts!-Tuple{Any, Any, NamedTuple}"><code>Catlab.ACSetInterface.set_subparts!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Mutate subparts of a part in a C-set.</p><p>Both single and vectorized assignment are supported.</p><p>See also: <a href="#Catlab.ACSetInterface.set_subpart!"><code>set_subpart!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.subpart" href="#Catlab.ACSetInterface.subpart"><code>Catlab.ACSetInterface.subpart</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get subpart of part in acset.</p><p>Both single and vectorized access are supported, with a view of the underlying data being returned in the latter case. Chaining, or composition, of subparts is also supported. For example, given a vertex-attributed graph <code>g</code>,</p><pre><code class="language-none">subpart(g, e, [:src, :vattr])</code></pre><p>returns the vertex attribute of the source vertex of the edge <code>e</code>. As a shorthand, subparts can also be accessed by indexing:</p><pre><code class="language-none">g[e, :src] == subpart(g, e, :src)</code></pre><p>Be warned that indexing with lists of subparts works just like <code>subpart</code>: <code>g[e,[:src,:vattr]]</code> is equivalent to <code>subpart(g, e, [:src,:vattr])</code>. This convention differs from DataFrames but note that the alternative interpretation of <code>[:src,:vattr]</code> as two independent columns does not even make sense, since they have different domains (belong to different tables).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.ACSetInterface.tables" href="#Catlab.ACSetInterface.tables"><code>Catlab.ACSetInterface.tables</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get a named tuple of Tables.jl-compatible tables from an acset</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theories/">« Standard library of theories</a><a class="docs-footer-nextpage" href="../graphs/">Graphs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 10 February 2022 20:43">Thursday 10 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
