<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Release Notes ¬∑ Catlab.jl</title><meta name="title" content="Release Notes ¬∑ Catlab.jl"/><meta property="og:title" content="Release Notes ¬∑ Catlab.jl"/><meta property="twitter:title" content="Release Notes ¬∑ Catlab.jl"/><meta name="description" content="Documentation for Catlab.jl."/><meta property="og:description" content="Documentation for Catlab.jl."/><meta property="twitter:description" content="Documentation for Catlab.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catlab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Seven Sketches in Compositionality</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/sketches/partitions/">Partitions</a></li><li><a class="tocitem" href="../../generated/sketches/preorders/">Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/meets/">Meets in Preorders</a></li><li><a class="tocitem" href="../../generated/sketches/smc/">Symmetric Monoidal Categories</a></li><li><a class="tocitem" href="../../generated/sketches/cat_elements/">The Category of Elements</a></li><li><a class="tocitem" href="../../generated/sketches/sheaves/">Basic Sheaf Constructions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphs/graphs/">The Category of Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/graphs_label/">Labeled Graphs</a></li><li><a class="tocitem" href="../../generated/graphs/subgraphs/">Algebra of subgraphs</a></li></ul></li><li><span class="tocitem">Categorical Algebra</span></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Wiring Diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/wd_cset/">Wiring Diagrams as Attributed C-Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/graphviz_graphs/">Drawing graphs in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../../apis/theories/">Standard library of theories</a></li><li><a class="tocitem" href="../../apis/categorical_algebra/">Categorical algebra</a></li><li><a class="tocitem" href="../../apis/graphs/">Graphs</a></li><li><a class="tocitem" href="../../apis/wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../../apis/graphics/">Graphics</a></li><li><a class="tocitem" href="../../apis/programs/">Programs</a></li><li><a class="tocitem" href="../../apis/sheaves/">Sheaves</a></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li class="is-active"><a class="tocitem" href>Release Notes</a><ul class="internal"><li><a class="tocitem" href="#Migration-guide-for-v0.16-to-v0.17"><span>Migration guide for <code>v&lt;0.16</code> to <code>v0.17</code></span></a></li></ul></li><li><a class="tocitem" href="../style/">Style Guide for AlgebraicJulia</a></li><li><a class="tocitem" href="../../generated/peg-parser/dsl_peg_tutorial/">Domain Specific Parsing Expression Grammars</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Docs</a></li><li class="is-active"><a href>Release Notes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Release Notes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/Catlab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/main/docs/src/devdocs/release.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Release-Notes"><a class="docs-heading-anchor" href="#Release-Notes">Release Notes</a><a id="Release-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Release-Notes" title="Permalink"></a></h1><h2 id="Migration-guide-for-v0.16-to-v0.17"><a class="docs-heading-anchor" href="#Migration-guide-for-v0.16-to-v0.17">Migration guide for <code>v&lt;0.16</code> to <code>v0.17</code></a><a id="Migration-guide-for-v0.16-to-v0.17-1"></a><a class="docs-heading-anchor-permalink" href="#Migration-guide-for-v0.16-to-v0.17" title="Permalink"></a></h2><blockquote><p>Note: this document will be updated as more packages in the AlgebraicJulia ecosystem are brought up to speed with <code>v0.17</code>.</p></blockquote><p>This major release comes with a variety of breaking changes. This guide provides some general advice for getting code which had worked with <code>v0.16</code> to work with <code>v0.17</code>. The difficulty of migrating the code can vary depending on how deep one&#39;s code reaches into Catlab&#39;s internals. We start with some easy fixes that should apply to most uses of Catlab:</p><h3 id="Interacting-with-ACSets"><a class="docs-heading-anchor" href="#Interacting-with-ACSets">Interacting with ACSets</a><a id="Interacting-with-ACSets-1"></a><a class="docs-heading-anchor-permalink" href="#Interacting-with-ACSets" title="Permalink"></a></h3><h4 id="ThACSetCategory-implementations"><a class="docs-heading-anchor" href="#ThACSetCategory-implementations"><code>ThACSetCategory</code> implementations</a><a id="ThACSetCategory-implementations-1"></a><a class="docs-heading-anchor-permalink" href="#ThACSetCategory-implementations" title="Permalink"></a></h4><p>The main change with ACSets is that that we do not infer from the ACSet itself (or its morphisms) what kind of category of ACSets we are working with. Although we can make educated guesses sometimes, this is in principle extra data that must be supplied whenever working with ACSets categorically. There are a variety of <code>ThACSetCategory</code> implementations which Catlab comes with:</p><table><tr><th style="text-align: center">Implementation</th><th style="text-align: center">Has attributes</th><th style="text-align: center">Mark as Deleted</th><th style="text-align: center">Has attribute variables</th><th style="text-align: center">Julia functions in components<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup></th></tr><tr><td style="text-align: center"><code>CSetCat</code></td><td style="text-align: center"><span>$\times$</span></td><td style="text-align: center"><span>$\times$</span></td><td style="text-align: center"><span>$\times$</span></td><td style="text-align: center"><span>$\times$</span></td></tr><tr><td style="text-align: center"><code>ACSetCat</code></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\times$</span></td><td style="text-align: center"><span>$\times$</span></td><td style="text-align: center"><span>$\times$</span></td></tr><tr><td style="text-align: center"><code>MADCSetCat</code></td><td style="text-align: center"><span>$\times$</span></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\times$</span></td><td style="text-align: center"><span>$\times$</span></td></tr><tr><td style="text-align: center"><code>MADACSetCat</code></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\times$</span></td><td style="text-align: center"><span>$\times$</span></td></tr><tr><td style="text-align: center"><code>VarACSetCat</code></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\times$</span></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\times$</span></td></tr><tr><td style="text-align: center"><code>MADVarACSetCat</code></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\times$</span></td></tr><tr><td style="text-align: center"><code>LooseACSetCat</code></td><td style="text-align: center"><span>$\checkmark$</span></td><td style="text-align: center"><span>$\times$</span></td><td style="text-align: center"><span>$\times$</span></td><td style="text-align: center"><span>$\checkmark$</span></td></tr></table><p>Each of these takes in an (arbitrary) <code>ACSet</code> of the kind one wishes to work with. We then wrap the implementation of  <code>ThACSetCategory</code> with its designated wrapper type: <code>ACSetCategory</code>.</p><pre><code class="language-julia hljs">const ùíû = ACSetCategory(CSetCat(Graph()))</code></pre><h4 id="Calling-methods-with-ThACSetCategory-implementations"><a class="docs-heading-anchor" href="#Calling-methods-with-ThACSetCategory-implementations">Calling methods with <code>ThACSetCategory</code> implementations</a><a id="Calling-methods-with-ThACSetCategory-implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-methods-with-ThACSetCategory-implementations" title="Permalink"></a></h4><p>Now we can use this piece of data as a parameter for various ACSet-related operations. Presently this can happen in two ways, depending on whether the method we are using belongs to a formal interface (via GATlab) or not. For example, if we call <code>methods(coproduct)</code> we&#39;ll see a method whose first argument is <code>GATlab.WithModel</code>. This indicates that we should use <code>coproduct</code> like the following:</p><pre><code class="language-julia hljs">G2 = ob(coproduct[ùíû](Graph(1), Graph(1))) # instead of: ob(coproduct(Graph(1), Graph(1)))</code></pre><p>Other methods haven&#39;t yet been put into a formal interface. E.g. <code>is_natural</code> and <code>homomorphism</code> do not have a <code>WithModel</code> parameter, though they do take keyword arguments. In such cases, <code>homomorphism(X,Y; cat=ùíû)</code> is how we signal which category we want to work in.<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2" class="footnote-ref">[2]</a><span class="footnote-preview" id="fn-2"></span></sup> </p><p>The hardest place to insert this extra parameter is binary operators like <code>‚äï</code>. These can&#39;t be modified with the indexing notation. This is where the <code>@withmodel</code> macro is helpful.</p><pre><code class="language-julia hljs">@withmodel TypedCatWithCoproducts(ùíû) (‚äï) begin
  @test is_isomorphic(G2, Graph(1) ‚äï Graph(1))
end</code></pre><p>As you can see, we presently need to wrap <code>ùíû</code> with <code>TypedCatWithCoproducts</code> for this to work. For subobject connectives like <code>‚àß</code>, one can use <code>ùíû</code> directly.</p><h4 id="Interacting-with-category-interface"><a class="docs-heading-anchor" href="#Interacting-with-category-interface">Interacting with category interface</a><a id="Interacting-with-category-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interacting-with-category-interface" title="Permalink"></a></h4><p>One thing we do with morphisms (including <code>ACSetTransformations</code>) is compose them. This is now parameterized by a choice of implementation of <code>ThCategory</code>. Our <code>ùíû</code> from above should be used as a model parameter for <code>compose</code> and <code>id</code>.</p><pre><code class="language-julia hljs">f = ACSetTransformation(G2, Graph(1); V=[1,1], cat=ùíû)
f‚Ä≤ = compose[ùíû](id[ùíû](G2), f)</code></pre><h4 id="Extensional-equality-and-force"><a class="docs-heading-anchor" href="#Extensional-equality-and-force">Extensional equality and <code>force</code></a><a id="Extensional-equality-and-force-1"></a><a class="docs-heading-anchor-permalink" href="#Extensional-equality-and-force" title="Permalink"></a></h4><p>There are many granularities of equality that one may be interested in. <code>==</code> is quite fine grained: <code>f</code> and <code>f‚Ä≤</code> above are not equal under that equivalence relation. However, under <code>‚âÉ</code> (an operator introduced in <code>v0.17</code>) they are equal. This should be used in place of <code>force(f) == force(f‚Ä≤)</code>. </p><p><code>force</code> can be used to improve the performance of a function by replacing it with an equivalent-behavior one, but this is not always a normal form for comparison of extensional behavior (e.g. <code>id(FinSet(100))</code> when converted to a normal form is much less efficient than just leaving it as an <code>IdentityFunction</code>).</p><h3 id="Other-changes"><a class="docs-heading-anchor" href="#Other-changes">Other changes</a><a id="Other-changes-1"></a><a class="docs-heading-anchor-permalink" href="#Other-changes" title="Permalink"></a></h3><h4 id="General"><a class="docs-heading-anchor" href="#General">General</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></h4><ul><li>Pretty printing may have changed, and some things that previously were pretty printed may not be presently pretty printed at all. This can be fixed piecemeal in the future.</li></ul><h4 id="SetFunctions/FinFunctions"><a class="docs-heading-anchor" href="#SetFunctions/FinFunctions">SetFunctions/FinFunctions</a><a id="SetFunctions/FinFunctions-1"></a><a class="docs-heading-anchor-permalink" href="#SetFunctions/FinFunctions" title="Permalink"></a></h4><ul><li>Functions (e.g. <code>FinFunction</code>) previously were able to be applied to a vector, which was taken to mean it should be mapped over its elements. Now, because the function may have a domain which includes vectors as elements, this mapping behavior is best done using Julia&#39;s dot notation</li></ul><pre><code class="language-julia hljs">f = FinFunction([3,2,1], 3)
f(1) == 3
f.([1,1,3,2]) == [3,3,1,2] # instead of: f([1,1,3,2])</code></pre><ul><li><p>It is no longer the case that <code>FinFunction</code> has type parameters for the type of its (co)domain sets. One can get these in a way generic to any implementation of any theory, i.e. <code>impl_type(my_finfunction, :Dom)</code>. Likewise, types in the set hierarchy (<code>FinSet</code>, <code>SetOb</code>) do not have type parameters. These are all wrapper types around models of a particular theory.</p></li><li><p>Catlab no longer infers the codomain of a FinFunction presented by just a vector.</p></li></ul><pre><code class="language-julia hljs">FinFunction([1,2,4], 4) # instead of: FinFunction([1,2,4])</code></pre><ul><li><code>TypeSet(T::Type)</code> is now an <em>implementation</em> of <code>ThSet</code> (something which could be wrapped by <code>SetOb</code>), <em>not</em> a <code>SetOb</code> itself. Old code which explicitly uses <code>TypeSet(T)</code> will likely not work, so instead one should use <code>SetOb(T)</code> which is defined to be <code>SetOb(TypeSet(T))</code>. Likewise, <code>ConstantFunction</code> is not a function but an <em>implementation</em> of <code>ThSetFunction</code>. In this case, however, one must manually apply the wrapper type:</li></ul><pre><code class="language-julia hljs"># Previously:
# c = ConstantFunction(&quot;foo&quot;, TypeSet(Int))
# (dom(c), codom(c)) == (TypeSet(Int), TypeSet(String))

c = SetFunction(ConstantFunction(&quot;foo&quot;, SetOb(Int)))
(dom(c), codom(c)) == (SetOb(Int), SetOb(String))</code></pre><ul><li>There may be subtle differences in how indexing of functions works with composing (e.g. if you (pre/post)compose an indexed <code>FinFunctionVector</code> with some other implementation of <code>FinFunction</code>, is the result indexed?). Trying to make this more systematic or predictable is future work.</li></ul><h4 id="FreeDiagrams"><a class="docs-heading-anchor" href="#FreeDiagrams">FreeDiagrams</a><a id="FreeDiagrams-1"></a><a class="docs-heading-anchor-permalink" href="#FreeDiagrams" title="Permalink"></a></h4><p><code>FreeDiagram</code> is now the wrapper type for implementations of the <code>ThFreeDiagram</code> interface. What was previously called <code>FreeDiagram</code> is now called <code>FreeGraph</code> (it is itself one particular implementation of <code>ThFreeDiagram</code>). </p><p>Now that <code>(co)dom</code> are model-parameterized methods which are called within the constructor of multi(co)spans, one can pass a <code>cat</code> keyword argument to these constructors. Alternatively, one can provide the feet of the span as a vector as well, in which case <code>(co)dom</code> will not be called when constructing the multi(co)span.</p><h4 id="FinCats-/-FinDomFunctors"><a class="docs-heading-anchor" href="#FinCats-/-FinDomFunctors">FinCats / FinDomFunctors</a><a id="FinCats-/-FinDomFunctors-1"></a><a class="docs-heading-anchor-permalink" href="#FinCats-/-FinDomFunctors" title="Permalink"></a></h4><p>There have been subtle changes to the <code>FinCat</code> and <code>Fin(Dom)Functor</code> constructors, as the previous code really presupposed there are only two types of FinCats (graph-like ones with integers as objects and schema-like ones with symbols/presentation generators as objects). We now have FinFunctors which work with anything which implements <code>ThFinCat</code> (which could in principle be done with any Julia types for <code>Ob</code> and <code>Hom</code>), but the tradeoff is that things that were once unambiguous become ambiguous and more data is required to be specified. For example, one previously could define a <code>FinFunctor</code> via an object mapping, a hom mapping, a source schema, and a target schema. Presently, one should be more explicit: plugging in <code>FinCat</code>s for the (co)domain and using the actual objects/homs of that category in the mappings (which happen to GAT generators, not symbols). </p><pre><code class="language-julia hljs"># Previously: 
# F = FinFunctor(Dict(:V =&gt; :El, :E =&gt; :Arr), Dict(:src =&gt; :src, :tgt =&gt; :tgt),
#                 SchGraph, SchElements)
V, E, src, tgt = generators(SchGraph)
El, Arr, _, _, src‚Ä≤, tgt‚Ä≤, _ = generators(SchElements)
src, tgt = 
F = FinFunctor(Dict(V =&gt; El, E =&gt; Arr), Dict(src =&gt; src‚Ä≤, tgt =&gt; tgt‚Ä≤),
                FinCat(SchGraph), FinCat(SchElements); homtype=:generator)</code></pre><p>Another difference is the <code>homtype</code> keyword argument. If the codomain is itself  a <code>FinCat</code>, it has both <code>Hom</code> and <code>Gen</code> Julia types associated with itself.  Therefore we can talk about <code>Hom</code>s in the codomain category in one of  the four following:</p><ul><li><code>:hom</code>: give an element of <code>Hom</code> directly</li><li><code>:generator</code>: give an element of <code>Gen</code> directly (coerce via <code>to_hom(cod, f)</code>)</li><li><code>:list</code>: give a <em>nonempty</em> list of composable <code>Gen</code> (coerce via <code>compose[cod](to_hom.(cod, f))</code>)</li><li><code>:path</code>: give a <code>Path</code> of composable <code>Gen</code> (where <code>Path</code> enforces composability + also allows representing id maps)</li></ul><p>Previously <code>hom_map(F, f)</code> was used <em>both</em> to apply <code>F</code> to generators and homs in the domain of a <code>Fin(Dom)Functor</code>. To do so now would be ambiguous behavior (if <code>DomGen</code> and <code>DomHom</code> are the same Julia type), so <code>gen_map</code> is new a method one can call.</p><p>The <code>ob_generators</code> and <code>hom_generators</code> methods for a <code>FinCat</code> now each return a <code>FinSet</code> rather than an <code>AbstractVector</code>.</p><h4 id="Module-structure"><a class="docs-heading-anchor" href="#Module-structure">Module structure</a><a id="Module-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Module-structure" title="Permalink"></a></h4><p>Because the module structure of CategoricalAlgebra has changed, some code that makes reference to this module structure will need to be fixed:</p><pre><code class="language-julia hljs">using CategoricalAlgebra.Cats.FinCats, # instead of : using CategoricalAlgebra.FinCats</code></pre><p>The main change is that <code>CategoricalAlgebra</code> got split into four pieces: <code>BasicSets</code> along with four submodules of the new <code>CategoricalAlgebra</code> (<code>Cats</code>, <code>SetCats</code>, <code>Pointwise</code>, and <code>Misc</code>).</p><h3 id="Regressions"><a class="docs-heading-anchor" href="#Regressions">Regressions</a><a id="Regressions-1"></a><a class="docs-heading-anchor-permalink" href="#Regressions" title="Permalink"></a></h3><p>The <code>HomomorphismQuery</code> option for computing all the full hom set between two ACSets via a limit computation is currently not yet re-implemented in <code>v0.17</code>. This code is quite complex and will take some time to redo in the future.</p><p>The category of ACSets and LooseACSetTransformations now is defined as having SetFunctions between TypeSets as the category for its attribute types. This means a certain kind of pullback of LooseACSetTransformations (where the components map between <em>finite sets</em>, rather than <code>TypeSet</code>s) is no longer supported. </p><h3 id="Performance-regressions"><a class="docs-heading-anchor" href="#Performance-regressions">Performance regressions</a><a id="Performance-regressions-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-regressions" title="Permalink"></a></h3><p>Performance regressions can be introduced in this migration by naive use of the <code>method[model](args...)</code> idiom. This is because this pattern uses dynamic dispatch and as such shouldn&#39;t be used in hot loops. If one wants to call a method associated with an interface in a more performant manner, the following style is required:</p><pre><code class="language-julia hljs">compose(WithModel(my_cat), f, g) # clunkier, but better performance than: compose[my_cat](f,g)</code></pre><p>Also note the type of <code>my_cat</code> must be known statically.</p><h3 id="Example-migration:-AlgebraicPetri"><a class="docs-heading-anchor" href="#Example-migration:-AlgebraicPetri">Example migration: AlgebraicPetri</a><a id="Example-migration:-AlgebraicPetri-1"></a><a class="docs-heading-anchor-permalink" href="#Example-migration:-AlgebraicPetri" title="Permalink"></a></h3><p>The process of updating <a href="https://github.com/AlgebraicJulia/AlgebraicPetri.jl">AlgebraicPetri.jl</a> to work with Catlab 0.17 was addressed in <a href="https://github.com/AlgebraicJulia/AlgebraicPetri.jl/pull/181">this PR</a>. The required changes were:</p><ul><li>No more <code>LooseACSetTransformation</code>: instead stratification limits are in a <code>LooseACSet</code> category of ACSets.</li><li>Some uses of <code>==</code> in the tests replaced with <code>‚âÉ</code>.</li><li>Components of ACSetTransformations no longer assumed to be <code>FinFunctionVector</code>: to get a vector out of a <code>FinFunction</code> we now call <code>collect(f)</code> instead of <code>f.func</code>.</li><li><code>FinDomFunction</code> ob/hom mappings use presentation generators, not symbols.</li></ul><p>There was one logic error in the previous implementation that was revealed in the update process: when we call <code>flatten_labels</code> to take a stratified model (which has, for example, <code>Name</code> attributes valued in <em>pairs</em> of symbols) and convert it to a regular Petri net (<code>Name</code> valued in just symbols with a <code>_</code> in the middle of the pair), the code previously did not change the components of typing hom that is going out of the model into a typing petri net. This needed to be fixed because otherwise a type error would be encountered (trying to use a function with domain <code>Tuple{String,String}</code>  when a function with domain <code>String</code> was needed).</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Almost always, when attributes are involved, we want maps between ACSets to preserve the attributes on the nose. However, in the category with &quot;loose ACSetTransformations&quot;, we allow maps between ACSets to include the data of a Julia function is not the identity function for some type.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>If the <code>cat</code> kwarg is not provided, most methods will do their best to silently infer what the right category to work in is, based on the ACSet argument provided.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../apis/sheaves/">¬´ Sheaves</a><a class="docs-footer-nextpage" href="../style/">Style Guide for AlgebraicJulia ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 17 December 2025 19:21">Wednesday 17 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
