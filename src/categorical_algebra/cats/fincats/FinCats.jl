export FinCat, ob_generator, hom_generator, decompose,
  ob_generator_name, hom_generator_name, ob_generators, hom_generators,
  equations, is_discrete, is_free, edges, src, tgt, gentype, AbsCat, to_hom

using StructEquality

using GATlab
import GATlab: equations, getvalue

import .....Theories: dom, codom, id, compose, ⋅, ∘
using .....Graphs
import .....Graphs: Graph, NamedGraph, src, tgt
using .....BasicSets: FinSet, SetOb

import ..Paths: Path

using ..Categories: ThCategoryExplicitSets, Cat
import ..Categories: ob_set, hom_set, obtype, homtype


# Theory of Finite Categories
#############################

"""
A FinCat extends a category by having a finite set of Hom generators. Each one 
can be interpreted as a Hom.
"""
@theory ThFinCat <: ThCategoryExplicitSets begin
  Gen(src::Ob,tgt::Ob)::TYPE; 
  to_hom(f::Gen(a,b))::Hom(a,b) ⊣ [(a,b)::Ob]
  FSet′::TYPE{FinSet}
  gen_set()::FSet′
end
  
ThFinCat.Meta.@wrapper FinCat

""" 
Common type for Categories and FinCats to be used by methods which only use 
their common interface. 
""" 
const AbsCat=Union{Cat, FinCat}


# Other methods
#--------------

Base.show(io::IO, C::FinCat) = show(io, getvalue(C))

""" synonym for `ob_set` """
ob_generators(f::FinCat)::SetOb = ob_set(f)

""" synonym for `gen_set` """
hom_generators(f::FinCat)::FinSet = gen_set(f)

obtype(c::FinCat)::Type = eltype(ob_set(c))

homtype(c::FinCat)::Type = impl_type(c, :Hom)

gentype(f::FinCat) = eltype(hom_generators(f))

""" To be implemented on a case-by-case basis """
function decompose end 

""" 
Create path from a vector of generators. If no s/t provided, then the list 
must not be empty 
"""
function Path(f::FinCat, gs::AbstractVector, s=nothing, t=nothing)
  s = isnothing(s) ? src(f, first(gs)) : s
  t = isnothing(t) ? tgt(f, last(gs)) : t
  Path(isempty(gs) ? gentype(f)[] : gs, s, t)
end

""" Is the category discrete?

A category is *discrete* if it is has no non-identity morphisms.
"""
is_discrete(C::FinCat) = isempty(hom_generators(C))

# Second clause should be superfluous, but we'll include it anyway.
Base.isempty(C::FinCat) = isempty(ob_generators(C)) && isempty(hom_generators(C))

# Equations #
#------------
""" Is the category freely generated?
"""
is_free(C::FinCat) = isempty(equations(C))

equations(f::FinCat) = equations(getvalue(f))

# Conversion to Graphs #
#-----------------------
"""
Graph underlying a finitely presented category whose object and hom generators 
are indexable, other than one explicitly generated by a graph.
"""
function NamedGraph(C::FinCat)
  Ob, Gen = obtype(C), gentype(C)
  g = NamedGraph{Ob,Gen}()
  obgens = collect(ob_generators(C))
  homgens = collect(hom_generators(C))
  add_vertices!(g,length(obgens);vname=obgens)
  s(f) = only(indexin([src(C,f)],obgens))
  t(f) = only(indexin([tgt(C,f)],obgens))
  add_edges!(g,Int[s(f) for f in homgens],Int[t(f) for f in homgens];
              ename=homgens) 
  g
end

function Graph(C::FinCat) 
  g = Graph()
  obgens = collect(ob_generators(C))
  homgens = collect(hom_generators(C))
  add_vertices!(g,length(obgens))
  s(f) = only(indexin([src(C,f)],obgens))
  t(f) = only(indexin([tgt(C,f)],obgens))
  add_edges!(g,Int[s(f) for f in homgens],Int[t(f) for f in homgens]) 
  return g
end

