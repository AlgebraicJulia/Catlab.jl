module FinCatGraphs

export FinCatGraph, FreeCatGraph, FinCatGraphEq, get_ob, get_hom, get_ob_set, 
       get_hom_set

using StructEquality

using GATlab, ACSets
import GATlab: equations, getvalue

using ......Graphs: HasGraph, NamedGraph, src, tgt, nv, ne
using ......BasicSets: FinSet
using ...Paths: Path, coerce_path
using ..PathCats: PathCat, ThPathCat
import ..FinCats: FinCat


""" 
Abstract type for both `FreeCatGraph` and `FinCatGraphEq`, where `G` is the 
type of the underlying graph (we dispatch on whether or not this is a 
`NamedGraph` or not).
"""
abstract type FinCatGraph{G,V,E} end

get_ob(g::FinCatGraph, v) = get_ob(getvalue(g), v)

get_hom(g::FinCatGraph, v) = get_hom(getvalue(g), v)

# Free category on graph
#########################

""" Free category generated by a finite graph.

The objects of the free category are vertices in the graph and the morphisms are
(possibly empty) paths.
"""
@struct_hash_equal struct FreeCatGraph{G<:HasGraph, V, E} <: FinCatGraph{G,V,E}
  graph::G
end

getvalue(g::FreeCatGraph) = g.graph

# Constructors
#-------------

function FreeCatGraph(n::T) where {V,E,T<:NamedGraph{V,E}}
  FreeCatGraph{T,V,E}(n)
end

function FreeCatGraph(n::T) where {T<:HasGraph}
  FreeCatGraph{T, Int, Int}(n)
end


# Other methods
#--------------

function Base.show(io::IO, C::FreeCatGraph)
  print(io, "FinCat(")
  show(io, getvalue(C))
  print(io, ")")
end

equations(::FreeCatGraph) = Pair[]

# Category on graph with equations
##################################

""" Category presented by a finite graph together with path equations.

The objects of the category are vertices in the graph and the morphisms are
paths, quotiented by the congruence relation generated by the path equations.
See (Spivak, 2014, *Category theory for the sciences*, ยง4.5).
"""
@struct_hash_equal struct FinCatGraphEq{
    G<:HasGraph,V,E,Eqs<:AbstractVector{<:Pair}} <: FinCatGraph{G, V, E}
  graph::G
  equations::Eqs
end

getvalue(f::FinCatGraphEq) = f.graph


function FinCatGraph(g::G, eqs::AbstractVector=[]) where {G<:HasGraph}
  isempty(eqs) && return FreeCatGraph(g)
  eqs = process_eqs(g, eqs)
  FinCatGraphEq{G, Int,Int,typeof(eqs)}(g, eqs)
end

function FinCatGraph(g::G, eqs::AbstractVector=[]) where {V,E,G<:NamedGraph{V,E}}
  isempty(eqs) && return FreeCatGraph(g)
  eqs = process_eqs(g, eqs)
  FinCatGraphEq{G, V,E,typeof(eqs)}(g, eqs)
end

FinCat(g::HasGraph, args...; kw...) = FinCat(FinCatGraph(g, args...; kw...))

process_eqs(g, eqs) = map(eqs) do eq
  lhs, rhs = coerce_path(g, first(eq)), coerce_path(g, last(eq))
  (src(lhs) == src(rhs) && tgt(lhs) == tgt(rhs)) ||
    error("Paths $lhs and $rhs in equation do not have equal (co)domains")
  lhs => rhs
end

equations(C::FinCatGraphEq) = C.equations


# FinCatGraph
#------------

""" Abstract type for category backed by finite generating graph.

Edges are presumably morphism generators, and paths are the morphisms.
"""

@instance ThPathCat{V,E,Vector{<:Pair}} [model::FinCatGraph{G,V,E}] where {G,V,E} begin
  function src(f::E) 
    g = getvalue(model)
    e = f isa Int ? f : only(incident(g, f, :ename))
    get_ob(g, src(g, e))
  end

  function tgt(f::E) 
    g = getvalue(model)
    e = f isa Int ? f : only(incident(g, f, :ename))
    get_ob(g, tgt(g, e))
  end

  ob_set()::FinSet = get_ob_set(getvalue(model))

  gen_set()::FinSet = get_hom_set(getvalue(model))

  eqs() = model.equations
end



function Base.show(io::IO, C::FinCatGraph)
  print(io, "FinCat(")
  show(io, getvalue(C))
  print(io, ", [")
  join(io, equations(C), ", ")
  print(io, "])")
end


# Common interface for NamedGraphs and other graphs
#--------------------------------------------------

get_ob(g::NamedGraph, v) = g[v, :vname]

get_ob(::HasGraph, v) = v 

get_hom(::NamedGraph, e) = g[e, :ename]

get_hom(g::HasGraph, e) = e

get_ob_set(g::NamedGraph) = FinSet(Set(g[:vname]))
get_ob_set(g::HasGraph) = FinSet(nv(g))

get_hom_set(g::NamedGraph) = FinSet(Set(g[:ename]))
get_hom_set(g::HasGraph) = FinSet(ne(g))

# Alternate constructors
########################

FinCat(g::FinCatGraph) = FinCat(PathCat(g))

end # module
