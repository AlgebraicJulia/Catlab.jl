""" 2-category of finitely presented categories.

This module is to the 2-category **Cat** what the module [`FinSets](@ref) is to
the category **Set**: a finitary, combinatorial setting where explicit
calculations are possible.
"""
module FinCats
export FinCat, FinCatGraph, is_free, ob_generators, hom_generators,
  equations, presentation,
  FinFunctor, FinDomFunctor, is_functorial, collect_ob, collect_hom,
  Vertex, Edge, Path, graph, edges, src, tgt

using AutoHashEquals
using Reexport
using StaticArrays: SVector

@reexport using ..Categories
using ...GAT, ...Present, ...Syntax
import ...Present: equations
using ...Theories: Category, ObExpr, HomExpr
import ...Theories: dom, codom, id, compose, ⋅, ∘
using ...Graphs, ..FreeDiagrams, ..FinSets, ..CSets
import ...Graphs: edges, src, tgt
import ..FreeDiagrams: FreeDiagram, diagram_ob_type, cone_objects, cocone_objects
import ..Limits: limit, colimit
import ..Categories: Ob, ob_map, hom_map

# Categories
############

""" Abstract type for finitely presented category.
"""
abstract type FinCat{Ob,Hom} <: Cat{Ob,Hom} end

FinCat(g::HasGraph, args...; kw...) = FinCatGraph(g, args...; kw...)
FinCat(pres::Presentation, args...; kw...) = FinCatSymbolic(pres, args...; kw...)

""" Is the category freely generated?
"""
is_free(C::FinCat) = isempty(equations(C))

""" Object generators of finitely presented category.

Usually the object generators are the same as the objects, although in principle
it is possible to have equations between objects, so that there are fewer
objects than object generators.
"""
function ob_generators end

""" Morphism generators of finitely presented category.
"""
function hom_generators end

Ob(C::FinCat{Int}) = FinSet(length(ob_generators(C)))

# Categories on graphs
######################

""" Abstract type for category backed by finite generating graph.
"""
abstract type FinCatGraph{Ob,Hom} <: FinCat{Ob,Hom} end

""" Generating graph for a finitely presented category.
"""
graph(C::FinCatGraph) = C.graph

ob_generators(C::FinCatGraph) = vertices(graph(C))
hom_generators(C::FinCatGraph) = edges(graph(C))

# Paths in graphs
#----------------

""" Vertex in a graph.

Like [`Edge`](@ref), this wrapper type is used mainly to control dispatch.
"""
@auto_hash_equals struct Vertex{T}
  vertex::T
end
Base.getindex(v::Vertex) = v.vertex
Base.size(::Vertex) = ()

""" Edge in a graph.

Like [`Vertex`](@ref), this wrapper type is used mainly to control dispatch.
"""
@auto_hash_equals struct Edge{T}
  edge::T
end
Base.getindex(e::Edge) = e.edge
Base.size(::Edge) = ()

""" Path in a graph.

The path may be empty but always has definite start and end points (source and
target vertices).

See also: [`Vertex`](@ref), [`Edge`](@ref).
"""
@auto_hash_equals struct Path{T,Edges<:AbstractVector{T}}
  edges::Edges
  src::T
  tgt::T
end
edges(path::Path) = path.edges
src(path::Path) = path.src
tgt(path::Path) = path.tgt

function Path(g::HasGraph, es::AbstractVector)
  !isempty(es) || error("Nonempty edge list needed for nontrivial path")
  Path(es, src(g, first(es)), tgt(g, last(es)))
end

Path(g::HasGraph, e) = Path(SVector(e), src(g,e), tgt(g,e))
Path(g::HasGraph, e::Edge) = Path(g, e[])

Base.empty(::Type{Path}, v::T) where T = Path(SVector{0,T}(), v, v)
Path(v::Vertex) = empty(Path, v[])

function Base.vcat(p1::Path, p2::Path)
  tgt(p1) == src(p2) ||
    error("Path start/end points do not match: $(tgt(p1)) != $(src(p2))")
  Path(vcat(edges(p1), edges(p2)), src(p1), tgt(p2))
end

@instance Category{Vertex,Path} begin
  dom(path::Path) = Vertex(src(path))
  codom(path::Path) = Vertex(tgt(path))
  id(v::Vertex) = Path(v)
  compose(p1::Path, p2::Path) = vcat(p1, p2)
end

# Free category on graph
#-----------------------

""" Free category generated by a finite graph.

The objects of the free category are vertices in the graph and the morphisms are
(possibly empty) paths.
"""
@auto_hash_equals struct FreeCatGraph{G<:HasGraph} <: FinCatGraph{Int,Path{Int}}
  graph::G
end

FinCatGraph(g::HasGraph) = FreeCatGraph(g)

is_free(::FreeCatGraph) = true

# Category on graph with equations
#---------------------------------

""" Category presented by a finite graph together with path equations.

The objects of the category are vertices in the graph and the morphisms are
paths, quotiented by the congruence relation generated by the path equations.
See (Spivak, 2014, *Category theory for the sciences*, §4.5).
"""
@auto_hash_equals struct FinCatGraphEq{G<:HasGraph,Eqs<:AbstractVector{<:Pair}} <:
    FinCatGraph{Int,Path{Int}}
  graph::G
  equations::Eqs
end

equations(C::FinCatGraphEq) = C.equations

function FinCatGraph(g::HasGraph, eqs::AbstractVector)
  eqs = map(eqs) do eq
    lhs, rhs = as_path(g, first(eq)), as_path(g, last(eq))
    (src(lhs) == src(rhs) && tgt(lhs) == tgt(rhs)) ||
      error("Paths $lhs and $rhs in equation do not have equal (co)domains")
    lhs => rhs
  end
  FinCatGraphEq(g, eqs)
end
as_path(g::HasGraph, path::Path) = path
as_path(g::HasGraph, x) = Path(g, x)

# Symbolic categories
#####################

""" Abstract type for categories presented symbolically.
"""
abstract type FinCatSymbolic{Ob,Hom} <: FinCat{Ob,Hom} end

FinCatSymbolic(pres::Presentation) = FinCatPresentation(pres)

""" Category defined by a `Presentation` object.
"""
struct FinCatPresentation{Ob,Hom} <: FinCatSymbolic{Ob,Hom}
  presentation::Presentation

  function FinCatPresentation(pres::Presentation)
    new{pres.syntax.Ob,pres.syntax.Hom}(pres)
  end
end

presentation(C::FinCatPresentation) = C.presentation
ob_generators(C::FinCatPresentation) = generators(presentation(C), :Ob)
hom_generators(C::FinCatPresentation) = generators(presentation(C), :Hom)
equations(C::FinCatPresentation) = equations(presentation(C))

# Functors
##########

""" Abstract type for functor out of a finitely presented category.
"""
abstract type FinDomFunctor{Dom<:FinCat,Codom<:Cat} <: Functor{Dom,Codom} end

FinDomFunctor(ob_map::Union{AbstractVector,AbstractDict},
              hom_map::Union{AbstractVector,AbstractDict}, dom, codom) =
  FinDomFunctorMap(ob_map, hom_map, dom, codom)
FinDomFunctor(ob_map::Union{AbstractVector{Ob},AbstractDict{<:Any,Ob}},
              hom_map::Union{AbstractVector{Hom},AbstractDict{<:Any,Hom}},
              dom) where {Ob,Hom} =
  FinDomFunctorMap(ob_map, hom_map, dom, TypeCat{Ob,Hom}())
FinDomFunctor(maps::NamedTuple{(:V,:E)}, dom::FinCatGraph, codom::Cat) =
  FinDomFunctor(maps.V, maps.E, dom, codom)

diagram_ob_type(F::FinDomFunctor{Dom,Codom}) where {Ob,Dom,Codom<:Cat{Ob}} = Ob
cone_objects(F::FinDomFunctor) = collect_ob(F)
cocone_objects(F::FinDomFunctor) = collect_ob(F)

ob_map(F::FinDomFunctor{<:FinCatGraph}, v::Vertex) = ob_map(F, v[])
ob_map(F::FinDomFunctor{<:FinCatGraph,<:FinCatGraph}, v::Vertex) =
  Vertex(ob_map(F, v[]))
hom_map(F::FinDomFunctor{<:FinCatGraph}, e::Edge) = hom_map(F, e[])
hom_map(F::FinDomFunctor{<:FinCatGraph}, path::Path) =
  mapreduce(e -> hom_map(F, e), compose, edges(path),
            init=id(ob_map(F, dom(path))))

ob_map(F::FinDomFunctor, x::GATExpr{:generator}) = ob_map(F, first(x))
hom_map(F::FinDomFunctor, f::GATExpr{:generator}) = hom_map(F, first(f))
hom_map(F::FinDomFunctor, f::GATExpr{:id}) = ob_map(F, dom(f))
hom_map(F::FinDomFunctor, f::GATExpr{:compose}) =
  mapreduce(f -> hom_map(F, f), compose, args(f))

(F::FinDomFunctor)(x::Vertex) = ob_map(F, x)
(F::FinDomFunctor)(f::Union{Edge,Path}) = hom_map(F, f)
(F::FinDomFunctor)(expr::ObExpr) = ob_map(F, expr)
(F::FinDomFunctor)(expr::HomExpr) = hom_map(F, expr)

function is_functorial(F::FinDomFunctor{<:FreeCatGraph})
  g = graph(dom(F))
  all(edges(g)) do e
    f = F(Edge(e))
    dom(f) == F(Vertex(src(g,e))) && codom(f) == F(Vertex(tgt(g,e)))
  end
end

""" Abstract type for functor between finitely presented categories.
"""
const FinFunctor{Dom<:FinCat,Codom<:FinCat} = FinDomFunctor{Dom,Codom}

FinFunctor(maps, dom::FinCat, codom::FinCat) = FinDomFunctor(maps, dom, codom)
FinFunctor(ob_map, hom_map, dom::FinCat, codom::FinCat) =
  FinDomFunctor(ob_map, hom_map, dom, codom)
FinFunctor(ob_map, hom_map, dom::Presentation, codom::Presentation) =
  FinDomFunctor(ob_map, hom_map, FinCat(dom), FinCat(codom))

# Mapping-based functor
#######################

""" Functor out of finitely presented category defined by explicit mapping.

The object and morphism mappings can be vectors or dictionaries.
"""
@auto_hash_equals struct FinDomFunctorMap{Dom<:FinCat,Codom<:Cat,ObMap,HomMap} <: FinDomFunctor{Dom,Codom}
  ob_map::ObMap
  hom_map::HomMap
  dom::Dom
  codom::Codom

  function FinDomFunctorMap(ob_map::AbstractVector, hom_map::AbstractVector,
                            dom::Dom, codom::Codom) where {Dom,Codom}
    length(ob_map) == length(ob_generators(dom)) ||
      error("Length of object map $ob_map does not match domain $dom")
    length(hom_map) == length(hom_generators(dom)) ||
      error("Length of morphism map $hom_map does not match domain $dom")
    ob_map = map(x -> normalize_ob_value(codom, x), ob_map)
    hom_map = map(f -> normalize_hom_value(codom, f), hom_map)
    new{Dom,Codom,typeof(ob_map),typeof(hom_map)}(ob_map, hom_map, dom, codom)
  end

  function FinDomFunctorMap(ob_map::ObD, hom_map::HomD, dom::Dom, codom::Codom) where
      {ObD<:AbstractDict, HomD<:AbstractDict, Dom, Codom}
    ob_map = (ObD.name.wrapper)(
      normalize_functor_key(dom, k) => normalize_ob_value(codom, v)
      for (k, v) in ob_map)
    hom_map = (HomD.name.wrapper)(
      normalize_functor_key(dom, k) => normalize_hom_value(codom, v)
      for (k, v) in hom_map)
    new{Dom,Codom,typeof(ob_map),typeof(hom_map)}(ob_map, hom_map, dom, codom)
  end
end

""" Functor b/w finitely presented categories defined by explicit mapping.
"""
const FinFunctorMap{Dom<:FinCat,Codom<:FinCat,ObMap,HomMap} =
  FinDomFunctorMap{Dom,Codom,ObMap,HomMap}

normalize_functor_key(C::FinCat, x) = x
normalize_ob_value(C::Cat, x) = x
normalize_hom_value(C::Cat, f) = f

normalize_ob_value(C::FinCatGraph, v::Vertex) = v[]
normalize_hom_value(C::FinCatGraph, f) = Path(graph(C), f)
normalize_hom_value(C::FinCatGraph, path::Path) = path

normalize_functor_key(C::FinCat, expr::GATExpr) = head(expr) == :generator ?
  first(expr) : error("Functor must be defined on generators")
normalize_ob_value(C::FinCatPresentation, x::Union{AbstractString,Symbol}) =
  presentation(C)[x]
normalize_hom_value(C::FinCatPresentation, f::Union{AbstractString,Symbol}) =
  presentation(C)[f]
normalize_hom_value(C::FinCatPresentation, fs::AbstractVector) =
  mapreduce(f -> normalize_hom_value(C, f), compose, fs)

""" Vector-based functor out of finitely presented category.
"""
const FinDomFunctorVector{Dom<:FinCat{Int},Codom<:Cat,
                          ObMap<:AbstractVector,HomMap<:AbstractVector} =
  FinDomFunctorMap{Dom,Codom,ObMap,HomMap}

ob_map(F::FinDomFunctorVector, x::Integer) = F.ob_map[x]
hom_map(F::FinDomFunctorVector, f::Integer) = F.hom_map[f]

collect_ob(F::FinDomFunctorVector) = F.ob_map
collect_hom(F::FinDomFunctorVector) = F.hom_map

Ob(F::FinDomFunctorVector) = FinDomFunction(F.ob_map, Ob(codom(F)))

""" Dictionary-based functor out of finitely presented category.
"""
const FinDomFunctorDict{ObKey,HomKey,Dom<:FinCat,Codom<:Cat,
                        ObMap<:AbstractDict{ObKey},HomMap<:AbstractDict{HomKey}} =
  FinDomFunctorMap{Dom,Codom,ObMap,HomMap}

ob_map(F::FinDomFunctorDict{ObK,HomK}, x::ObK) where {ObK,HomK} = F.ob_map[x]
hom_map(F::FinDomFunctorDict{ObK,HomK}, f::HomK) where {ObK,HomK} = F.hom_map[f]

# C-set interop
#--------------

function FinDomFunctor(pres::Presentation, X::ACSet)
  ob_map = Dict(c => FinSet(X, nameof(c)) for c in generators(pres, :Ob))
  hom_map = Dict(f => FinFunction(X, nameof(f)) for f in generators(pres, :Hom))
  FinDomFunctor(ob_map, hom_map, FinCat(pres))
end

# Free diagram interop
#---------------------

function FreeDiagram(F::FinDomFunctor{<:FreeCatGraph,<:TypeCat{Ob,Hom}}) where {Ob,Hom}
  diagram = FreeDiagram{Ob,Hom}()
  copy_parts!(diagram, graph(dom(F)))
  diagram[:ob] = collect_ob(F)
  diagram[:hom] = collect_hom(F)
  diagram
end

function FinDomFunctor(diagram::FreeDiagram)
  g = Graph()
  copy_parts!(g, diagram)
  FinDomFunctor(ob(diagram), hom(diagram), FinCat(g))
end

limit(F::FinDomFunctor) = limit(FreeDiagram(F))
colimit(F::FinDomFunctor) = colimit(FreeDiagram(F))

end
