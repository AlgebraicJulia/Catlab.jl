""" 2-category of finitely presented categories.

This module is to the 2-category **Cat** what the module [`FinSets](@ref) is to
the category **Set**: a finitary, combinatorial setting where explicit
computations can be carried out.
"""
module FinCats
export FinCat, FinFunctor, Ob, is_functorial, ob_map, hom_map,
  Vertex, Edge, Path, graph, edges, src, tgt

using AutoHashEquals
using StaticArrays: SVector

using ...GAT
using ...Theories: Category
import ...Theories: Ob, dom, codom, id, compose, ⋅, ∘
using ...Graphs
import ...Graphs: edges, src, tgt
using ..FinSets, ..Categories

# Base types
############

""" Abstract base type for finitely presented category.
"""
abstract type FinCat{Ob,Hom} <: Cat{Ob,Hom} end

""" Abstract type for category with finite generating graph.
"""
abstract type FinCatGraph{Ob,Hom} <: FinCat{Ob,Hom} end

""" Generating graph for a finitely presented category.
"""
graph(C::FinCatGraph) = C.graph

""" Abstract base type for functor between finitely presented categories.
"""
abstract type FinFunctor{Dom<:FinCat,Codom<:FinCat} end

dom(F::FinFunctor) = F.dom
codom(F::FinFunctor) = F.codom

# Free categories
#################

# Paths in graphs
#----------------

""" Vertex in a graph.

Like [`Edge`](@ref), this wrapper type is used mainly to control dispatch.
"""
@auto_hash_equals struct Vertex{T} <: AbstractArray{0,T}
  vertex::T
end
Base.getindex(v::Vertex) = v.vertex

""" Edge in a graph.

Like [`Vertex`](@ref), this wrapper type is used mainly to control dispatch.
"""
@auto_hash_equals struct Edge{T} <: AbstractArray{0,T}
  edge::T
end
Base.getindex(e::Edge) = e.edge

""" Path in a graph.

The path may be empty but always has definite start and end points (source and
target vertices).

See also: [`Vertex`](@ref), [`Edge`](@ref).
"""
@auto_hash_equals struct Path{T,Edges<:AbstractVector{T}}
  edges::Edges
  src::T
  tgt::T
end
edges(path::Path) = path.edges
src(path::Path) = path.src
tgt(path::Path) = path.tgt

function Path(g::HasGraph, es::AbstractVector)
  !isempty(es) || error("Nonempty edge list needed for nontrivial path")
  Path(es, src(g, first(es)), tgt(g, last(es)))
end

Path(g::HasGraph, e) = Path(SVector(e), src(g,e), tgt(g,e))
Path(g::HasGraph, e::Edge) = Path(g, e[])

Base.empty(::Type{Path}, v::T) where T = Path(SVector{0,T}(), v, v)
Path(v::Vertex) = empty(Path, v[])

function Base.vcat(p1::Path, p2::Path)
  tgt(p1) == src(p2) ||
    error("Path start/end points do not match: $(tgt(p1)) != $(src(p2))")
  Path(vcat(edges(p1), edges(p2)), src(p1), tgt(p2))
end

@instance Category{Vertex,Path} begin
  dom(path::Path) = Vertex(src(path))
  codom(path::Path) = Vertex(tgt(path))
  id(v::Vertex) = Path(v)
  compose(p1::Path, p2::Path) = vcat(p1, p2)
end

# Free category on graph
#-----------------------

""" Free category generated by a finite graph.

The objects of the free category are vertices in the graph and the morphisms are
(possibly empty) paths.
"""
struct FreeFinCatGraph{G<:HasGraph} <: FinCatGraph{Int,Path{Int}}
  graph::G
end

FinCat(g::HasGraph) = FreeFinCatGraph(g)

Ob(C::FinCatGraph) = FinSet(nv(graph(C)))

function is_functorial(F::FinFunctor{<:FinCatGraph})
  g = graph(dom(F))
  all(edges(g)) do e
    f = hom_map(F, e)
    src(f) == ob_map(F, src(g,e)) && tgt(f) == ob_map(F, tgt(g,e))
  end
end

""" Functor between finitely presented categories.
"""
@auto_hash_equals struct FinFunctorVector{
    VMap<:AbstractVector{Int}, EMap<:AbstractVector{<:Path{Int}},
    Dom<:FinCat{Int}, Codom<:FinCat{Int}} <: FinFunctor{Dom,Codom}
  vmap::VMap
  emap::EMap
  dom::Dom
  codom::Codom

  function FinFunctorVector(vmap::AbstractVector, emap::AbstractVector,
                            dom::Dom, codom::Codom) where {Dom,Codom}
    vmap = map(x -> coerce_ob(codom, x), vmap)
    emap = map(f -> coerce_hom(codom, f), emap)
    new{typeof(vmap),typeof(emap),Dom,Codom}(vmap, emap, dom, codom)
  end
end

coerce_ob(C::FinCatGraph, v) = v
coerce_ob(C::FinCatGraph, v::Vertex) = v[]
coerce_hom(C::FinCatGraph, path::Path) = path
coerce_hom(C::FinCatGraph, x) = Path(graph(C), x)

FinFunctor(maps::NamedTuple{(:V,:E)}, args...) =
  FinFunctor(maps.V, maps.E, args...)
FinFunctor(vmap::AbstractVector, emap::AbstractVector, dom, codom) =
  FinFunctorVector(vmap, emap, dom, codom)

ob_map(F::FinFunctorVector, v) = F.vmap[v]
ob_map(F::FinFunctorVector, v::Vertex) = Vertex(F.vmap[v[]])

hom_map(F::FinFunctorVector, e) = F.emap[e]
hom_map(F::FinFunctorVector, e::Edge) = F.emap[e[]]
hom_map(F::FinFunctorVector, path::Path) =
  mapreduce(e -> hom_map(F, e), vcat, edges(path),
            init=empty(Path, ob_map(F, src(path))))

(F::FinFunctorVector)(x::Vertex) = ob_map(F, x)
(F::FinFunctorVector)(f::Union{Edge,Path}) = hom_map(F, f)

Ob(F::FinFunctorVector) = FinFunction(F.vmap, Ob(codom(F)))

end
