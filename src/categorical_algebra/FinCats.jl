""" 2-category of finitely presented categories.

This module is to the 2-category **Cat** what the module [`FinSets](@ref) is to
the category **Set**: a finitary, combinatorial setting where explicit
computations can be carried out.
"""
module FinCats
export FinCat, Ob, is_free, ob_generators, hom_generators, equations,
  FinFunctor, FinDomFunctor, is_functorial, ob_map, hom_map,
  collect_ob, collect_hom,
  Vertex, Edge, Path, graph, edges, src, tgt

using AutoHashEquals
using StaticArrays: SVector

using ...GAT
import ...Present: equations
import ...Theories: Category, Ob, dom, codom, id, compose, ⋅, ∘
using ...Graphs
import ...Graphs: edges, src, tgt
using ..FreeDiagrams, ..FinSets, ..CSets, ..Categories
import ..FreeDiagrams: FreeDiagram, diagram_ob_type,
  cone_objects, cocone_objects
import ..Limits: limit, colimit

# Generic interface
###################

""" Abstract type for finitely presented category.
"""
abstract type FinCat{Ob,Hom} <: Cat{Ob,Hom} end

FinCat(g::HasGraph, args...; kw...) = FinCatGraph(g, args...; kw...)

""" Is the category freely generated?
"""
function is_free end

""" Object generators of finitely presented category.

Usually the object generators are the same as the objects, although in principle
it is possible to have equations between objects, so that there are fewer
objects than object generators.
"""
function ob_generators end

""" Morphism generators of finitely presented category.
"""
function hom_generators end

Ob(C::FinCat{Int}) = FinSet(length(ob_generators(C)))

""" Abstract type for functor out of a finitely presented category.
"""
abstract type FinDomFunctor{Dom<:FinCat,Codom<:Cat} end

dom(F::FinDomFunctor) = F.dom
codom(F::FinDomFunctor) = F.codom

diagram_ob_type(F::FinDomFunctor{Dom,Codom}) where {Ob,Dom,Codom<:Cat{Ob}} = Ob
cone_objects(F::FinDomFunctor) = collect_ob(F)
cocone_objects(F::FinDomFunctor) = collect_ob(F)

""" Abstract type for functor between finitely presented categories.
"""
const FinFunctor{Dom,Codom<:FinCat} = FinDomFunctor{Dom,Codom}

FinFunctor(maps, dom::FinCat, codom::FinCat) = FinDomFunctor(maps, dom, codom)
FinFunctor(ob_map, hom_map, dom::FinCat, codom::FinCat) =
  FinDomFunctor(ob_map, hom_map, dom, codom)

# Categories on graphs
######################

""" Abstract type for category with finite generating graph.
"""
abstract type FinCatGraph{Ob,Hom} <: FinCat{Ob,Hom} end

""" Generating graph for a finitely presented category.
"""
graph(C::FinCatGraph) = C.graph

ob_generators(C::FinCatGraph) = vertices(graph(C))
hom_generators(C::FinCatGraph) = edges(graph(C))

# Paths in graphs
#----------------

""" Vertex in a graph.

Like [`Edge`](@ref), this wrapper type is used mainly to control dispatch.
"""
@auto_hash_equals struct Vertex{T}
  vertex::T
end
Base.getindex(v::Vertex) = v.vertex
Base.size(::Vertex) = ()

""" Edge in a graph.

Like [`Vertex`](@ref), this wrapper type is used mainly to control dispatch.
"""
@auto_hash_equals struct Edge{T}
  edge::T
end
Base.getindex(e::Edge) = e.edge
Base.size(::Edge) = ()

""" Path in a graph.

The path may be empty but always has definite start and end points (source and
target vertices).

See also: [`Vertex`](@ref), [`Edge`](@ref).
"""
@auto_hash_equals struct Path{T,Edges<:AbstractVector{T}}
  edges::Edges
  src::T
  tgt::T
end
edges(path::Path) = path.edges
src(path::Path) = path.src
tgt(path::Path) = path.tgt

function Path(g::HasGraph, es::AbstractVector)
  !isempty(es) || error("Nonempty edge list needed for nontrivial path")
  Path(es, src(g, first(es)), tgt(g, last(es)))
end

Path(g::HasGraph, e) = Path(SVector(e), src(g,e), tgt(g,e))
Path(g::HasGraph, e::Edge) = Path(g, e[])

Base.empty(::Type{Path}, v::T) where T = Path(SVector{0,T}(), v, v)
Path(v::Vertex) = empty(Path, v[])

function Base.vcat(p1::Path, p2::Path)
  tgt(p1) == src(p2) ||
    error("Path start/end points do not match: $(tgt(p1)) != $(src(p2))")
  Path(vcat(edges(p1), edges(p2)), src(p1), tgt(p2))
end

@instance Category{Vertex,Path} begin
  dom(path::Path) = Vertex(src(path))
  codom(path::Path) = Vertex(tgt(path))
  id(v::Vertex) = Path(v)
  compose(p1::Path, p2::Path) = vcat(p1, p2)
end

# Free category on graph
#-----------------------

""" Free category generated by a finite graph.

The objects of the free category are vertices in the graph and the morphisms are
(possibly empty) paths.
"""
@auto_hash_equals struct FreeCatGraph{G<:HasGraph} <: FinCatGraph{Int,Path{Int}}
  graph::G
end

FinCatGraph(g::HasGraph) = FreeCatGraph(g)

is_free(::FreeCatGraph) = true

function is_functorial(F::FinDomFunctor{<:FreeCatGraph})
  g = graph(dom(F))
  all(edges(g)) do e
    f = F(Edge(e))
    dom(f) == F(Vertex(src(g,e))) && codom(f) == F(Vertex(tgt(g,e)))
  end
end

# Category on graph with equations
#---------------------------------

""" Category presented by a finite graph together with path equations.

The objects of the category are vertices in the graph and the morphisms are
paths, quotiented by the congruence relation generated by the path equations.
See (Spivak, 2014, *Category theory for the sciences*, §4.5).
"""
@auto_hash_equals struct FinCatGraphEq{G<:HasGraph,Eqs<:AbstractVector{<:Pair}} <:
    FinCatGraph{Int,Path{Int}}
  graph::G
  equations::Eqs
end

function FinCatGraph(g::HasGraph, eqs::AbstractVector)
  eqs = map(eqs) do eq
    lhs, rhs = coerce_path(g, first(eq)), coerce_path(g, last(eq))
    (src(lhs) == src(rhs) && tgt(lhs) == tgt(rhs)) ||
      error("Paths $lhs and $rhs in equation do not have equal (co)domains")
    lhs => rhs
  end
  FinCatGraphEq(g, eqs)
end
coerce_path(g::HasGraph, path::Path) = path
coerce_path(g::HasGraph, x) = Path(g, x)

is_free(C::FinCatGraphEq) = isempty(equations(C))
equations(C::FinCatGraphEq) = C.equations

# Functors
##########

""" Vector-based data structure for functor out of finitely presented category.
"""
@auto_hash_equals struct FinDomFunctorVector{
    ObMap<:AbstractVector, HomMap<:AbstractVector, Dom<:FinCat{Int}, Codom} <:
    FinDomFunctor{Dom,Codom}
  ob_map::ObMap
  hom_map::HomMap
  dom::Dom
  codom::Codom

  function FinDomFunctorVector(ob_map::AbstractVector, hom_map::AbstractVector,
                               dom::Dom, codom::Codom) where {Dom,Codom}
    length(ob_map) == length(ob_generators(dom)) ||
      error("Length of object map $ob_map does not match domain $dom")
    length(hom_map) == length(hom_generators(dom)) ||
      error("Length of morphism map $hom_map does not match domain $dom")
    ob_map = map(x -> coerce_ob(codom, x), ob_map)
    hom_map = map(f -> coerce_hom(codom, f), hom_map)
    new{typeof(ob_map),typeof(hom_map),Dom,Codom}(ob_map, hom_map, dom, codom)
  end
end
coerce_ob(C::Cat, x) = x
coerce_ob(C::FinCatGraph, v::Vertex) = v[]
coerce_hom(C::Cat, f) = f
coerce_hom(C::FinCatGraph, path::Path) = path
coerce_hom(C::FinCatGraph, f) = Path(graph(C), f)

""" Vector-based data structure for functor b/w finitely presented categories.
"""
const FinFunctorVector{ObMap<:AbstractVector,HomMap<:AbstractVector,
                       Dom<:FinCat{Int},Codom<:FinCat} =
  FinDomFunctorVector{ObMap,HomMap,Dom,Codom}

FinDomFunctor(maps::NamedTuple{(:V,:E)}, args...) =
  FinDomFunctor(maps.V, maps.E, args...)
FinDomFunctor(ob_map::AbstractVector, hom_map::AbstractVector, dom, codom) =
  FinDomFunctorVector(ob_map, hom_map, dom, codom)
FinDomFunctor(ob_map::AbstractVector{Ob},
              hom_map::AbstractVector{Hom}, dom) where {Ob,Hom} =
  FinDomFunctorVector(ob_map, hom_map, dom, TypeCat{Ob,Hom}())

ob_map(F::FinDomFunctorVector, v) = F.ob_map[v]
ob_map(F::FinDomFunctorVector, v::Vertex) = F.ob_map[v[]]
ob_map(F::FinFunctorVector, v::Vertex) = Vertex(F.ob_map[v[]])

hom_map(F::FinDomFunctorVector, e) = F.hom_map[e]
hom_map(F::FinDomFunctorVector, e::Edge) = F.hom_map[e[]]
hom_map(F::FinDomFunctorVector, path::Path) =
  mapreduce(e -> hom_map(F, e), compose, edges(path),
            init=id(ob_map(F, dom(path))))

collect_ob(F::FinDomFunctorVector) = F.ob_map
collect_hom(F::FinDomFunctorVector) = F.hom_map

(F::FinDomFunctorVector)(x::Vertex) = ob_map(F, x)
(F::FinDomFunctorVector)(f::Union{Edge,Path}) = hom_map(F, f)

Ob(F::FinDomFunctorVector) = FinDomFunction(F.ob_map, Ob(codom(F)))

# `FreeDiagrams` interop
#-----------------------

function FreeDiagram(F::FinDomFunctor{<:FreeCatGraph,<:TypeCat{Ob,Hom}}) where {Ob,Hom}
  diagram = FreeDiagram{Ob,Hom}()
  copy_parts!(diagram, graph(dom(F)))
  diagram[:ob] = collect_ob(F)
  diagram[:hom] = collect_hom(F)
  diagram
end

function FinDomFunctor(diagram::FreeDiagram)
  g = Graph()
  copy_parts!(g, diagram)
  FinDomFunctor(ob(diagram), hom(diagram), FinCat(g))
end

limit(F::FinDomFunctor) = limit(FreeDiagram(F))
colimit(F::FinDomFunctor) = colimit(FreeDiagram(F))

end
