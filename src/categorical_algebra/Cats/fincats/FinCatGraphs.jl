module FinCatGraphs 
export FinCatGraph, FreeCatGraph, FinCatGraphEq
using StructEquality

import GATlab: equations
import .....Theories: hom, id, dom, codom, compose
using .....Graphs
using ...Paths
using ..FinCats 
import ..FinCats: FinCat, ob_generators, hom_generators, ob_generator, 
  hom_generator, graph, ob_generator_name, hom_generator_name

# Categories on graphs
######################

""" Abstract type for category backed by finite generating graph.
"""
abstract type FinCatGraph{G,Ob,Hom} <: FinCat{Ob,Hom} end

""" Generating graph for a finitely presented category.
"""
graph(C::FinCatGraph) = C.graph
  
graph(C::OppositeCat;kw...) = reverse(graph(op(C);kw...))

ob_generators(C::FinCatGraph) = vertices(graph(C))
hom_generators(C::FinCatGraph) = edges(graph(C))

ob_generator(C::FinCatGraph, x) = all(has_vertex(graph(C), x)) ? x :
  error("Vertex $x not contained in graph $(graph(C))")
hom_generator(C::FinCatGraph, f) = all(has_edge(graph(C), f)) ? f :
  error("Edge $f not contained in graph $(graph(C))")

ob_generator(C::FinCatGraph, x::Union{AbstractString,Symbol}) =
  vertex_named(graph(C), x)
hom_generator(C::FinCatGraph, f::Union{AbstractString,Symbol}) =
  edge_named(graph(C), f)
ob_generator_name(C::FinCatGraph, x) = vertex_name(graph(C), x)
hom_generator_name(C::FinCatGraph, f) = edge_name(graph(C), f)

function Base.show(io::IO, C::FinCatGraph)
  print(io, "FinCat(")
  show(io, graph(C))
  print(io, ", [")
  join(io, equations(C), ", ")
  print(io, "])")
end


""" Abstract type for category whose morphisms are paths in a graph.

(Or equivalence classes of paths in a graph, but we compute with
"""
const FinCatPathGraph{G,V,E} = FinCatGraph{G,V,Path{V,E}}

dom(C::FinCatPathGraph, e) = src(graph(C), e)
dom(C::FinCatPathGraph, path::Path) = src(path)
codom(C::FinCatPathGraph, e) = tgt(graph(C), e)
codom(C::FinCatPathGraph, path::Path) = tgt(path)

id(C::FinCatPathGraph, x) = empty(Path, graph(C), x)
compose(C::FinCatPathGraph, fs...) =
  reduce(vcat, coerce_path(graph(C), f) for f in fs)

hom(C::FinCatPathGraph, f) = coerce_path(graph(C), f)

coerce_path(g::HasGraph, path::Path) = path
coerce_path(g::HasGraph, x) = Path(g, x)

# Free category on graph
#-----------------------

""" Free category generated by a finite graph.

The objects of the free category are vertices in the graph and the morphisms are
(possibly empty) paths.
"""
@struct_hash_equal struct FreeCatGraph{G<:HasGraph} <: FinCatPathGraph{G,Int,Int}
  graph::G
end

FinCatGraph(g::HasGraph) = FreeCatGraph(g)

is_free(::FreeCatGraph) = true
equations(::FreeCatGraph) = []

function Base.show(io::IO, C::FreeCatGraph)
  print(io, "FinCat(")
  show(io, graph(C))
  print(io, ")")
end

# Category on graph with equations
#---------------------------------

""" Category presented by a finite graph together with path equations.

The objects of the category are vertices in the graph and the morphisms are
paths, quotiented by the congruence relation generated by the path equations.
See (Spivak, 2014, *Category theory for the sciences*, ยง4.5).
"""
@struct_hash_equal struct FinCatGraphEq{G<:HasGraph,Eqs<:AbstractVector{<:Pair}} <:
    FinCatPathGraph{G,Int,Int}
  graph::G
  equations::Eqs
end

equations(C::FinCatGraphEq) = C.equations
equations(C::OppositeCat) = map(x->reverse(x.first)=>reverse(x.second),equations(C.cat))

function FinCatGraph(g::HasGraph, eqs::AbstractVector)
  eqs = map(eqs) do eq
    lhs, rhs = coerce_path(g, first(eq)), coerce_path(g, last(eq))
    (src(lhs) == src(rhs) && tgt(lhs) == tgt(rhs)) ||
      error("Paths $lhs and $rhs in equation do not have equal (co)domains")
    lhs => rhs
  end
  FinCatGraphEq(g, eqs)
end

FinCat(g::HasGraph, args...; kw...) = FinCatGraph(g, args...; kw...)

end # module
