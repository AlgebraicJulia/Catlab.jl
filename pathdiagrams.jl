include("sketchgat.jl");

####################
# Helper functions #
####################

function xs(x::Int)::Symbol
    return Symbol("x$x")
end
function xs(xx::AbstractVector{Int})::Vector{Symbol}
    return [Symbol("x$x") for x in xx]
end
function es(x::Int)::Symbol
    return Symbol("e$x")
end
function es(xx::AbstractVector{Int})::Vector{Symbol}
    [Symbol("e$x") for x in xx]
end

##################
# Main functions #
##################

"""Find all paths in a particular diagram"""
function comm_paths(d::CSet; start::Int=0)::Set{Pair{Vector{Int}, Vector{Int}}}
    # Store set of paths between each pair of vertices
    # Also store set of
    paths = Dict{Pair{Int},Set{Pair{Vector{Int},Set{Int}}}}([
        (i=>j)=>Set() for i in 1:nv(d) for j in 1:nv(d)])

    # Initialize paths with edges
    for e in 1:ne(d)
        s, t = d[:src][e], d[:tgt][e]
        push!(paths[s => t], [e] => Set([s,t])) # also keep track of 'seen' nodes
    end

    # iteratively combine paths until convergence
    changed = true
    while changed
        changed = false
        for i in 1:nv(d)
            for j in 1:nv(d)
                fs = paths[i=>j]
                for k in 1:nv(d)
                    gs = paths[j=>k]
                    fgs = paths[i=>k]
                    for (f, fseen) in fs
                        for (g, gseen) in gs
                            ijk = i!=j || j!= k
                            no_repeat_nodes = intersect(fseen, gseen) == Set(i==k ? [i,j] : [j])
                            if ijk && no_repeat_nodes
                                comp = vcat(f,g) => union(fseen, gseen)
                                # NO DUPLICATES
                                if !(comp in fgs)
                                    changed = true
                                    push!(paths[i=>k], comp )
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    # collect all pairs
    pairs = []
    for (ij, pths) in collect(paths)
        pths = collect(pths)  # Set -> Vector
        if start == 0 || ij[1] == start
            if ij[1] == ij[2]
                for (f,_) in pths
                    push!(pairs, f=>Int[])  # loops equal to empty path
                end
            else
                for ((f,_),(g,_)) in zip(pths,pths[2:end])  # a=b,b=c,c=d...
                    push!(pairs, f=>g)
                end
            end
        end
    end
    return Set(pairs)
end

function comm_paths_m(m::ACSetTransformation; start::Int=0)::Set{Pair{Vector{Int}, Vector{Int}}}
    M = m.components[:E]
    return Set(map(x->M(x[1])=>M(x[2]), collect(comm_paths(m.dom; start=start))))
end
"""
Given all the diagrams, which paths (given by pairs of edge sequences) must commute?
"""
function comm_paths_D(fls::FLSketch)::Set{Pair{Vector{Int}, Vector{Int}}}
    return (isempty(fls.D)
            ? Set{Pair{Vector{Int}}}()
            : union(map(comm_paths_m, collect(fls.D))...))
end


"""
Create a CSet type specified by a graph
Vertices are x₁,x₂,..., edges are e₁, e₂,...
all edges are indexed
"""
function graph_to_cset(grph::Graph)::Type
    pres = Presentation(FreeSchema)
    xobs = [Ob(FreeSchema,xs(i)) for i in 1:nv(grph)]
    for x in xobs
        add_generator!(pres, x)
    end
    for (i,(src, tgt)) in enumerate(zip(grph[:src], grph[:tgt]))
        add_generator!(pres, Hom(es(i), xobs[src], xobs[tgt]))
    end
    return CSetType(pres, index=es(1:ne(grph)))
end

"""
Take in a Graph CSet, return wiring diagram Cset that
queries a CSet with the schema generated by `graph_to_cset` above

Actually use morphism which renames objects and edges, in case
d is a pattern to be interpreted in the context of another graph
"""
function diagram_to_query(d::CSet, vcomp::Vector{Int}, ecomp::Vector{Int})
    xtgts = [Symbol("x$(vcomp[i])") for i in 1:nv(d)]
    xnames = [Symbol("$(x)_$i") for (i, x) in enumerate(xtgts)]
    enames = [Symbol("e$(ecomp[i])") for i in 1:ne(d)]
    rel = RelationDiagram{Symbol}(nv(d),port_names=xnames)
    add_junctions!(rel, nv(d),variable=xnames)
    set_subpart!(rel, 1:nv(d), :outer_junction, 1:nv(d))
    for v in 1:nv(d)
        outarrows = d.indices[:src][v]
        b = add_box!(rel, 1+length(outarrows), name=xtgts[v])
        ps = ports(rel, b)
        set_subpart!(rel, ps, :port_name, vcat([:_id],enames[outarrows]))
        set_junction!(rel, ps, vcat([v],d[:tgt][outarrows]))
    end
    return rel
end

"""
Given two paths, [a₁,a₂,...] and [b₁, b₂,...] we want a query that
returns the penultimate and final nodes values along both paths
for each element in the source table, src(a₁)=src(b₁).
"""
function paths_to_query(d::ACSet, p1::Vector{Int}, p2::Vector{Int}; pen::Bool=true)
    n1, n2 = map(length, [p1, p2])
    resnames = vcat(pen ? ["pen"] : [], ["last"])
    res = vcat([:start],[Symbol("$s$i") for s in resnames for i in 1:2])
    n_out = pen ? 5 : 3
    rel = RelationDiagram{Symbol}(n_out, port_names=res)
    root = add_box!(rel, n2 > 0 ? 3 : 2, name=xs(d[:src][p1[1]]))
    ps = ports(rel, root)
    initjunction = add_junctions!(rel, 1, variable=[:init])
    set_junction!(rel, [ps[1]], [1])
    set_subpart!(rel, ps[1], :port_name, :_id)

    for (p_index,path) in [1=>p1, 2=>p2]
        if isempty(path)

        else
            outport = ps[p_index+1]
            lastj, = add_junctions!(rel, 1, variable=[Symbol("p_$(p_index)_1")])
            set_junction!(rel, [outport], [lastj])
            for (i, arr) in enumerate(path)
                set_subpart!(rel, outport, :port_name, es(arr))
                if i < length(path)
                    j, = add_junctions!(rel, 1, variable=[Symbol("p_$(p_index)_$(i+1)")])
                    b = add_box!(rel, 2, name=xs(d[:tgt][arr]))
                    pid, pout = ports(rel, b)
                    set_subpart!(rel, pid, :port_name, :_id)
                    set_junction!(rel, [pid,pout], [lastj, j])
                    outport = pout
                    lastj = j
                end
            end
        end
    end
    set_subpart!(rel, 1:n_out, :outer_junction, vcat([1],(pen ? [
        n1, n2 < 2 ? 1 : n1+n2] : []), [n1+1, n2 == 0 ? 1 : n1+n2+1]))
    return rel
end

"""
Helper function to get the penultimate and
last tables of a pair of commutative paths
(note we only allow p2 to be empty)
"""
function lasttabs(d::ACSet, p1::Vector{Int}, p2::Vector{Int})::Vector{Int}
    root =d[:src][p1[1]]
    penult_1, last_1 = [d[x][p1[end]] for x in [:src, :tgt]]
    penult_2 = isempty(p2) ? root : d[:src][p2[end]]
    last_2 = isempty(p2) ? root : d[:tgt][p2[end]]
    @assert last_1 == last_2
    return [penult_1, penult_2, last_1, last_2]
end


"""
Returns apex table, a diagram of the base of the cone,
and information to relate the base query result to the
original tables in G
"""
function cone_data(fls::FLSketch)::Vector{Tuple{Int, Vector{Int}, ACSet}}
    res = []
    for (apex, m) in fls.C
        tgttab, dia_emap, legs =  cone_dia_map(m, apex)
        conebase_diagram = remove_cone(dom(m),apex)
        q = diagram_to_query(conebase_diagram ,tgttab, dia_emap)
        push!(res, (m[:V](apex), legs, q))
    end
    return res
end
